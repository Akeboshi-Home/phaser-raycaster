{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setRange","range","Phaser","Math","MAX_SAFE_INTEGER","this","Geom","Line","SetToAngle","_ray","origin","x","y","angle","setDetectionRange","detectionRange","detectionRangeCircle","setTo","boundsInRange","objectBounds","bounds","getBounds","Intersects","CircleToRectangle","setAngle","Angle","Normalize","setAngleDeg","DegToRad","setCone","cone","setConeDeg","PhaserRaycaster","scene","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","version","graphics","boundingBox","mappedObjects","sortedPoints","mapSegmentCount","physics","world","setOptions","autoUpdate","add","lineStyle","width","color","fillStyle","objects","mapGameObjects","setBoundingBox","height","rectangle","Rectangle","points","segments","Point","left","top","right","bottom","length","push","dynamic","segmentCount","Array","isArray","includes","data","setDataEnabled","map","Map","set","removeMappedObjects","index","indexOf","splice","mapppedObject","updateMap","createRay","Ray","type","active","_points","_segments","getPoints","getSegments","getIntersections","config","line","polygon","arc","container","setSegmentCount","_getRectanglePoints","_getRectangleSegments","_updateRectangleMap","_getLinePoints","_getLineSegments","_updateLineMap","_getPolygonPoints","_getPolygonSegments","_updatePolygonMap","_getArcPoints","_getArcSegments","_updateArcMap","_getContainerPoints","_getContainerSegments","_updateContainerMap","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","pointA","geom","getPointA","pointB","getPointB","rotation","vectorA","scaleX","scaleY","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","rayLength","sqrt","pow","radius","dAngle","asin","newPoints","getCircles","tempRay","_raycaster","list","child","iterate","childPoints","segment","iLength","childA","mapA","j","jLength","childB","mapB","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","count","raycaster","Circle","ignoreNotIntersectedRays","intersections","setRay","setOrigin","cast","castCircle","castCone","angleDeg","coneDeg","closestIntersection","closestDistance","GetLineToRectangle","distance","Distance","Between","target","Equals","isTangent","circleIntersections","circle","GetLineToCircle","x1","y1","originalAngle","maps","rayTargets","testedObjects","objectB","sort","a","b","intersectionA","intersectionB","minAngle","maxAngle","angleOffsetDeg","RadToDeg","ShortestBetween","abs"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/**\n * Set ray's range.\n *\n * @function Ray.setRange\n * @since 0.6.0\n *\n * @param {integer} [range] = Phaser.Math.MAX_SAFE_INTEGER - Ray's range.\n *\n * @return {object} Ray object.\n */\nexport function setRange(range = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.range = range;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n\n/**\n * Set ray's range.\n *\n * @function Ray.setRange\n * @since 0.6.0\n *\n * @param {integer} [detectionRange] = Phaser.Math.MAX_SAFE_INTEGER - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {object} Ray object.\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @function Ray.boundsInRange\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {Phaser.Geom. Rectangle} / {boolean} [bounds] = false - Tested object's bounds. If not passed bounds will be generated.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else\n        objectBounds = object.getBounds();\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * Set ray angle in radians.\n *\n * @function Ray.setAngle\n * @since 0.6.0\n *\n * @param {float} [angle] - Ray's angle in radians.\n *\n * @return {object} Ray object.\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n\n/**\n * Set ray angle in degrees.\n *\n * @function Ray.setAngleDeg\n * @since 0.6.1\n *\n * @param {float} [angle] - Ray's angle in degrees.\n *\n * @return {object} Ray object.\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n","/**\n * Set ray's cone angle in radians.\n *\n * @function Ray.setAngle\n * @since 0.7.0\n *\n * @param {float} [cone] - Ray's cone angle in radians.\n *\n * @return {object} Ray object.\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle in degrees.\n *\n * @function Ray.setAngleDeg\n * @since 0.7.0\n *\n * @param {float} [cone] - Ray's cone angle in degrees.\n *\n * @return {object} Ray object.\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","var PhaserRaycaster = function (scene)\r\n{\r\n    //The Scene that owns this plugin\r\n    this.scene = scene;\r\n\r\n    this.systems = scene.sys;\r\n\r\n    if (!scene.sys.settings.isBooted)\r\n    {\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    }\r\n};\r\n\r\n//Static function called by the PluginFile Loader.\r\nPhaserRaycaster.register = function (PluginManager)\r\n{\r\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\r\n\r\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\r\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\r\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\r\n    //  it has an entry in the InjectionMap.\r\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\r\n};\r\n\r\nPhaserRaycaster.prototype = {\r\n\r\n    //  Called when the Plugin is booted by the PluginManager.\r\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\r\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\r\n\r\n        eventEmitter.on('start', this.start, this);\r\n\r\n        eventEmitter.on('preupdate', this.preUpdate, this);\r\n        eventEmitter.on('update', this.update, this);\r\n        eventEmitter.on('postupdate', this.postUpdate, this);\r\n\r\n        eventEmitter.on('pause', this.pause, this);\r\n        eventEmitter.on('resume', this.resume, this);\r\n\r\n        eventEmitter.on('sleep', this.sleep, this);\r\n        eventEmitter.on('wake', this.wake, this);\r\n\r\n        eventEmitter.on('shutdown', this.shutdown, this);\r\n        eventEmitter.on('destroy', this.destroy, this);\r\n    },\r\n\r\n    //A test method.\r\n    test: function (name)\r\n    {\r\n        console.log('RaycasterPlugin says hello ' + name + '!');\r\n    },\r\n\r\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\r\n    start: function ()\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 1\r\n    preUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 2\r\n    update: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 3\r\n    postUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\r\n    pause: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is resumed from a paused state.\r\n    resume: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\r\n    sleep: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is woken from a sleeping state.\r\n    wake: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\r\n    shutdown: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n    },\r\n\r\n    //Create Raycaster object\r\n    createRaycaster: function(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n\r\n};\r\n\r\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\r\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\r\n\r\n//Make sure you export the plugin for webpack to expose\r\n\r\nmodule.exports = PhaserRaycaster;\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responible for creating ray objects and managing mapped objects.\r\n *\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Ray specific configuration settings.\r\n */\r\nexport function Raycaster(options) {\r\n    this.version = '0.7.1';\r\n    this.scene;\r\n    this.graphics;\r\n    this.boundingBox = false;\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    this.mapSegmentCount = 0;   //quantity of segments of map of circle\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined && options.scene.physics !== undefined)\r\n            options.boundingBox = options.scene.physics.world.bounds;\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    //set options\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    //set bounding box\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    //map object\r\n    mapGameObjects: function(objects, dynamic = false, segmentCount = this.mapSegmentCount) {\r\n        if(!Array.isArray(objects)) {\r\n            if(this.mappedObjects.includes(objects))\r\n                return this;\r\n\r\n            if(!objects.data)\r\n                objects.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: objects,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            });\r\n\r\n            objects.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(objects);\r\n\r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            if(!object.data)\r\n                object.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: object,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            });\r\n\r\n            object.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    //remove mapped Objects\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            let index = this.mappedObjects.indexOf(objects);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n            return this;\r\n        }\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    //scene update event listener\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                if(mapppedObject.data === undefined)\r\n                    continue;\r\n\r\n                let map = mapppedObject.data.get('raycasterMap')\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    //ray factory\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responible for mapping game objects.\r\n *\r\n * @class Map\r\n * @memberof Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options) {\r\n    this.type;\r\n    this.active;\r\n    this.dynamic;\r\n    this.object;\r\n    this._points = [];\r\n    this._segments = [];\r\n    this.getPoints;\r\n    this.getSegments;\r\n    this.getIntersections;\r\n    this.segmentCount = 0;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nlet rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet container = require('./map-container-methods.js');\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config,\r\n    setSegmentCount: require('./segmentsCount.js').setSegmentCount,\r\n    //methods for rectangle maps\r\n    _getRectanglePoints: rectangle.getPoints,\r\n    _getRectangleSegments: rectangle.getSegments,\r\n    _updateRectangleMap: rectangle.updateMap,\r\n    //methods for line maps\r\n    _getLinePoints: line.getPoints,\r\n    _getLineSegments: line.getSegments,\r\n    _updateLineMap: line.updateMap,\r\n    //methods for polygon maps\r\n    _getPolygonPoints: polygon.getPoints,\r\n    _getPolygonSegments: polygon.getSegments,\r\n    _updatePolygonMap: polygon.updateMap,\r\n    //methods for circle maps\r\n    _getArcPoints: arc.getPoints,\r\n    _getArcSegments: arc.getSegments,\r\n    _updateArcMap: arc.updateMap,\r\n    //methods for container maps\r\n    _getContainerPoints: container.getPoints,\r\n    _getContainerSegments: container.getSegments,\r\n    _updateContainerMap: container.updateMap\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n","/*Map methods for rectangles*/\r\n/**\r\n * Get array of rectangle's points.\r\n *\r\n * @function Map._getRectanglePoints\r\n * @since 0.6.0\r\n *\r\n * @param {object} [ray] - Ray object.\r\n *\r\n * @return {array} Array of points.\r\n */\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n/**\r\n * Get array of segments representing rectangle.\r\n *\r\n * @function Map._getRectangleSegments\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {array} Array of Phaser.Geom.Line objects.\r\n */\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n * Update rectangle's map of points and segments.\r\n *\r\n * @function Map._updateRectangleMap\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {object} Map object.\r\n */\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for lines*/\r\n/**\r\n * Get array of points for line.\r\n *\r\n * @function Map._getLinePoints\r\n * @since 0.6.0\r\n *\r\n * @param {object} [ray] - Ray object.\r\n *\r\n * @return {array} Array of points.\r\n */\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n/**\r\n * Get array of segments representing line.\r\n *\r\n * @function Map._getLineSegments\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {array} Array of Phaser.Geom.Line objects.\r\n */\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n * Update line's map of points and segments.\r\n *\r\n * @function Map._updateLineMap\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {object} Map object.\r\n */\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for polygons*/\r\n/**\r\n * Get array of polygon's points.\r\n *\r\n * @function Map._getPolygonPoints\r\n * @since 0.6.0\r\n *\r\n * @param {object} [ray] - Ray object.\r\n *\r\n * @return {array} Array of points.\r\n */\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n/**\r\n * Get array of segments representing polygon.\r\n *\r\n * @function Map._getPolygonSegments\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {array} Array of Phaser.Geom.Line objects.\r\n */\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n * Update polygon's map of points and segments.\r\n *\r\n * @function Map._updatePolygonMap\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {object} Map object.\r\n */\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for circles*/\r\n/**\r\n * Get array of points on circle.\r\n *\r\n * @function Map._getArcPoints\r\n * @since 0.6.0\r\n *\r\n * @param {object} [ray] - Ray object. Used to generate points of rays tangent to circle, from ray origin.\r\n *\r\n * @return {array} Array of Phaser.GeomLine objects.\r\n */\r\nexport function getPoints(ray = false) {\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n * Get array of segments representing circle.\r\n *\r\n * @function Map._getArcSegments\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {array} Array of Phaser.Geom.Line objects.\r\n */\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n * Update circle's map of points and segments. If segmentCount == 0. Map is generated dynamically by calculating points of rays tangent to circle, from ray origin.\r\n *\r\n * @function Map._updateArcMap\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {object} Map object.\r\n */\r\nexport function updateMap() {\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for containers*/\n/**\n * Get array of container's children points.\n *\n * @function Map._getContainerPoints\n * @since 0.7.1\n *\n * @param {object} [ray] - Ray object.\n *\n * @return {array} Array of points.\n */\nexport function getPoints(ray = false, getCircles = false) {\n    let points = [];\n    if(!getCircles)\n        points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(ray){\n        //create temporary ray\n        let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n        let tempRay = ray._raycaster.createRay({\n            origin: {\n                x: vector.getPointB().x,\n                y: vector.getPointB().y\n            }\n        });\n\n        for(let child of this.object.list){\n            if(child.type === 'Arc'){\n\n                let map = child.data.get('raycasterMap');\n                if(map._points.length == 0){\n                    for(let point of map.getPoints(tempRay, true)){\n                        let vector = new Phaser.Geom.Line(0, 0, point.x, point.y);\n                        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n                        points.push(new Phaser.Geom.Point(vector.getPointB().x + offset.x, vector.getPointB().y + offset.y));\n                    }\n                }\n            }\n            else if(child.type === 'Container') {\n                for(let point of child.data.get('raycasterMap').getPoints(tempRay, true)){\n                    if(this.object.rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n                }\n            }\n\n        }\n    }\n\n    return points;\n};\n\n/**\n * Get array of segments representing container's children.\n *\n * @function Map._getContainerSegments\n * @since 0.7.1\n *\n *\n * @return {array} Array of Phaser.Geom.Line objects.\n */\nexport function getSegments(ray = false) {\n    return this._segments;\n};\n\n/**\n * Update containers's map of points and segments.\n *\n * @function Map._updateContainerleMap\n * @since 0.7.1\n *\n *\n * @return {object} Map object.\n */\nexport function updateMap() {\n    let points = [];\n    let segments = [];\n    let container = this.object;\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    //iterate through container's children\n    container.iterate(function(child){\n        if(!child.data)\n            child.setDataEnabled();\n\n        //get child map\n        let map = child.data.get('raycasterMap');\n        if(!map) {\n            map = new this.constructor({\n                object: child,\n                segmentCount: this.segmentCount\n            });\n            child.data.set('raycasterMap', map);\n        }\n        else\n            map.updateMap();\n\n        //add child points\n        let childPoints = [];\n        for(let point of map.getPoints()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                points.push(vector.getPointB());\n            }\n            //if rotation === 0\n            else\n                points.push(new Phaser.Geom.Point(point.x * container.scaleX + offset.x, point.y * container.scaleX + offset.y));\n\n            childPoints.push(points[points.length - 1])\n        }\n\n        //add child segments\n        for(let segment of map.getSegments()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let pointA = segment.getPointA();\n                let pointB = segment.getPointB();\n                let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n                let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n                Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n                segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n            }\n            //if rotation === 0\n            else\n                segments.push(new Phaser.Geom.Line(segment.getPointA().x * container.scaleX + offset.x, segment.getPointA().y * container.scaleY + offset.y, segment.getPointB().x * container.scaleX + offset.x, segment.getPointB().y * container.scaleY + offset.y));\n        }\n\n    }.bind(this));\n\n    //get children intersections\n    for(let i = 0, iLength = container.list.length; i < iLength; i++){\n        let childA = container.list[i];\n        let mapA = childA.data.get('raycasterMap');\n\n        for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n            let childB = container.list[j];\n            let mapB = childB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                continue;\n\n            //find objects intersections\n            for(let segmentA of mapA.getSegments()) {\n                for(let segmentB of mapB.getSegments()) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                     //calculate positions after container's rotation\n                    if(rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, intersection.x * this.object.scaleX + offset.x, intersection.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/**\n * Configure map on creation.\n *\n * @function Map.config\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * - {object} object - Mapped game object\n * - {string} [type] - Map type. If not defined, will be determined from object\n * - {boolean} [dynamic] = false - If set true, map will be dynamic (updated on scene update event).\n * - {integer} [segmentCount] = 0 - Circle map's segment count. If set to 0, map won't be generating segments and relay only on generated tangent point to actually testing ray.\n *\n * @return {object} Map object.\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    this.type = options.type;\n\n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = this._getPolygonPoints;\n            this.getSegments = this._getPolygonSegments;\n            this.updateMap = this._updatePolygonMap;\n            break;\n        case 'Arc':\n            this.getPoints = this._getArcPoints;\n            this.getSegments = this._getArcSegments;\n            this.updateMap = this._updateArcMap;\n            break;\n        case 'Line':\n            this.getPoints = this._getLinePoints;\n            this.getSegments = this._getLineSegments;\n            this.updateMap = this._updateLineMap;\n            break;\n        case 'Container':\n            this.getPoints = this._getContainerPoints;\n            this.getSegments = this._getContainerSegments;\n            this.updateMap = this._updateContainerMap;\n            break;\n        default:\n            this.getPoints = this._getRectanglePoints;\n            this.getSegments = this._getRectangleSegments;\n            this.updateMap = this._updateRectangleMap;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n    this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n *\n * @function Map.setSegmentCount\n * @since 0.6.0\n *\n * @param {integer} [count] - Circle's map segments count.\n *\n * @return {object} Map object.\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n        this.updateMap();\n        return this;\n}\n","/**\r\n * @classdesc\r\n *\r\n * Ray class responible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @class Ray\r\n * @memberof Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Ray specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    this.origin = new Phaser.Geom.Point();\r\n    this._ray = new Phaser.Geom.Line();\r\n    this.angle = 0;\r\n    this.cone = 0;\r\n    this.range = Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.detectionRange = 0;\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    this.ignoreNotIntersectedRays = true;\r\n    this.intersections = [];\r\n    this._raycaster = raycaster ? raycaster : false;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRange: require('./range.js').setRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone\r\n};\r\n","/**\n * Configure ray on creation.\n *\n * @function Ray.config\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * - {Phaser.Types.Math.Vector2Like} [origin] = {x:0, y:0} - Ray's position.\n * - {float} [angle] = 0 - Ray's angle in radians.\n * - {float} [angleDeg] = 0 - Ray's angle in degrees.\n * - {float} [cone] = 0 - Ray's cone angle in radians.\n * - {float} [coneDeg] = 0 - Ray's cone angle in degrees.\n * - {integer} [range] = Phaser.Math.MAX_SAFE_INTEGER - Ray's range.\n * - {integer} [detectionRange] = Phaser.Math.MAX_SAFE_INTEGER - Maximum distance between ray's position and tested objects bounding boxes.\n * - {boolean} [ignoreNotIntersectedRays] = true - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target.\n *\n * @return {object} Ray object.\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //range (0 = max)\n    if(options.range)\n        this.range = options.range;\n\n    //detection range (0 = max)\n    if(options.detectionRange)\n        this.detectionRange = options.detectionRange;\n\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @function Ray.setAngle\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n * @param {float} [angle] - Ray's angle in radians.\n * @param {integer} [range] = Phaser.Math.MAX_SAFE_INTEGER - Ray's range.\n *\n * @return {object} Ray object.\n */\nexport function setRay(x, y, angle, range = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.range = range;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n","/**\n * Set ray's position.\n *\n * @function Ray.setOrigin\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {object} Ray object.\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @function Ray.cast\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n * - {Phaser.Types.Math.Vector2Like} [target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n *\n * @return {Phaser.Types.Math.Vector2Like} / {boolean} - Point object of ray's closest intersection with tested objects. Returns false if no intersection has been found.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestDistance = this.range;\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.range > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        //check if object is intersected by ray\n        if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\n            continue;\n\n        let map = object.data.get('raycasterMap');\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n            }\n        }\n\n        //check arc intersections if its not\n        if(map.type === 'Arc') {\n           //if arc has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                    }\n                }\n            }\n        }\n    }\n\n    if(!closestIntersection)\n        return (this.ignoreNotIntersectedRays) ? false : this._ray.getPointB();\n    return new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n}\n","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @function Ray.castCircle\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n *\n * @return {array} - Array of Point objects of ray's closest intersections with tested objects.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n        }\n\n        for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n            let object = options.objects[i];\n            //if bound in range\n            if(!this.boundsInRange(object))\n                continue;\n            \n            testedObjects.push(object);\n\n            let map = object.data.get('raycasterMap');\n            maps.push(map);\n            //get points and angles\n            for(let point of map.getPoints(this)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n\n            //get objects intersections\n            for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n                let objectB = options.objects[j];\n                let mapB = objectB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\n                    continue;\n                \n                //find objects intersections\n                for(let segmentA of map.getSegments(this)) {\n                    for(let segmentB of mapB.getSegments(this)) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                        });\n                    }\n                }\n            }\n        }\n\n        //sort target points by angle\n        rayTargets.sort(function(a, b){\n            //if rays towards points have the same angles promote closer one\n            if(a.angle == b.angle) {\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                    return 1;\n                else\n                    return -1;\n            }\n\n            return a.angle - b.angle;\n        }.bind(this));\n\n        //cast rays\n        for(let target of rayTargets){\n            this.setAngle(target.angle);\n            let intersection = this.cast({\n                objects: testedObjects,\n                target: target.point\n            });\n            if(intersection){\n                //if intersection hits target point cast two additional rays\n                if(Phaser.Geom.Point.Equals(target.point, intersection)) {\n                    this.setAngle(target.angle - 0.0001);\n                    let intersectionA = this.cast({\n                        objects: testedObjects\n                    });\n                    if(intersectionA)\n                        intersections.push(intersectionA);\n                    \n                    intersections.push(intersection);\n\n                    this.setAngle(target.angle + 0.0001);\n                    let intersectionB = this.cast({\n                        objects: testedObjects\n                    });\n                    if(intersectionB)\n                        intersections.push(intersectionB);\n\n                    continue;\n                }\n                intersections.push(intersection);\n            }\n        }\n    }\n\n    this.setAngle(originalAngle);\n    return intersections;\n}\n","/**\n * Cast ray in cone to find closest intersections with tested mapped objects.\n *\n * @function Ray.castCone\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n *\n * @return {array} - Array of Point objects of ray's closest intersections with tested objects.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n\n                let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n                let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                    rayTargets.push({\n                        point: point,\n                        angle: angle,\n                        angleOffsetDeg: -angleOffsetDeg\n                    });\n                }\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map = object.data.get('raycasterMap');\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    //cast rays\n    for(let target of rayTargets){\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            if(Phaser.Geom.Point.Equals(target.point, intersection)) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects\n                });\n                if(intersectionA)\n                    intersections.push(intersectionA);\n                \n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects\n                });\n                if(intersectionB)\n                    intersections.push(intersectionB);\n\n                continue;\n            }\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    return intersections;\n}\n"],"sourceRoot":""}