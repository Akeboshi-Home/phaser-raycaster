{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/enableArcadePhysics.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setRayRange","rayRange","Phaser","Math","MAX_SAFE_INTEGER","this","Geom","Line","SetToAngle","_ray","origin","x","y","angle","setDetectionRange","detectionRange","detectionRangeCircle","setTo","setCollisionRange","collisionRange","body","arcadePhysicsCircle","setRadius","setCircle","boundsInRange","objectBounds","bounds","getBounds","Intersects","CircleToRectangle","overlap","objects","targets","bodies","overlapCircle","Circle","undefined","_raycaster","scene","physics","overlapCirc","Array","isArray","hitbox","isCircle","position","halfWidth","Rectangle","width","height","testOverlap","push","gameObject","CircleToCircle","processOverlap","object1","object2","target","obj1","length","slicedIntersections","slice","type","TriangleToCircle","RectangleToTriangle","setAngle","Angle","Normalize","setAngleDeg","DegToRad","setCone","cone","setConeDeg","PhaserRaycaster","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","createRaycaster","options","_Raycaster","constructor","require","Raycaster","version","graphics","boundingBox","mappedObjects","sortedPoints","mapSegmentCount","world","setOptions","autoUpdate","add","lineStyle","color","fillStyle","mapGameObjects","setBoundingBox","rectangle","points","segments","Point","left","top","right","bottom","dynamic","segmentCount","includes","data","setDataEnabled","map","Map","set","config","option","removeMappedObjects","index","indexOf","splice","enableMaps","active","disableMaps","mapppedObject","updateMap","createRay","Ray","_points","_segments","getPoints","getSegments","getIntersections","line","polygon","arc","container","tilemap","setSegmentCount","collisionTiles","setCollisionTiles","setOrigin","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","pointA","geom","getPointA","pointB","getPointB","rotation","vectorA","scaleX","scaleY","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","rayLength","sqrt","pow","radius","dAngle","asin","newPoints","count","getCircles","tempRay","list","child","iterate","childPoints","segment","iLength","childA","mapA","j","jLength","childB","mapB","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","Distance","Between","x1","y1","x2","y2","LineToCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","leftEdge","vertical","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","raycaster","ignoreNotIntersectedRays","round","autoSlice","intersections","setRay","cast","castCircle","castCone","enableArcadePhysics","angleDeg","coneDeg","closestIntersection","closestDistance","GetLineToRectangle","distance","result","Equals","isTangent","circleIntersections","circle","GetLineToCircle","originalAngle","maps","rayTargets","testedObjects","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","minAngle","maxAngle","angleOffsetDeg","RadToDeg","ShortestBetween","abs","closed","slices","Triangle","existing","setAllowGravity","setImmovable"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/**\r\n * Set ray's range.\r\n *\r\n * @method Raycaster.Ray#setRayRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.rayRange = rayRange;\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\r\n * Ray tests all objects when set to 0.\r\n *\r\n * @method Raycaster.Ray#setDetectionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setDetectionRange(detectionRange = 0) {\r\n    this.detectionRange = detectionRange;\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\r\n * Determines ray's physics body radius.\r\n *\r\n * @method Raycaster.Ray#setCollisionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {integer} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.collisionRange = collisionRange;\r\n    if(this.body) {\r\n        this.arcadePhysicsCircle.setRadius(this.collisionRange);\r\n        this.body.setCircle(this.collisionRange);\r\n    }\r\n    return this;\r\n}\r\n\r\n/**\r\n * Test if object's bounding box is in ray's detection range.\r\n *\r\n * @method Raycaster.Ray#boundsInRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} object - Tested object\r\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\r\n *\r\n * @return {boolean} Information if object is in ray's detection range.\r\n */\r\nexport function boundsInRange(object, bounds = false) {\r\n    if(!this.detectionRange)\r\n        return true;\r\n\r\n    let objectBounds;\r\n    if(bounds)\r\n        objectBounds = bounds;\r\n    else\r\n        objectBounds = object.getBounds();\r\n\r\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n","/**\r\n * Get game objects overlaping field of view.\r\n *\r\n * @method Raycaster.Ray#overlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\r\n *\r\n * @return {object[]} Array of game objects that overlaps with field of view.\r\n */\r\nexport function overlap(objects) {\r\n    let targets = [];\r\n    let bodies = false;\r\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\r\n\r\n    //get bodies in range\r\n    if(objects === undefined) {\r\n        objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\r\n        bodies = true;\r\n    }\r\n    //get object's body\r\n    else if(!Array.isArray(objects)) {\r\n        objects = [objects];\r\n    }\r\n    //if objects are bodies\r\n    if(bodies) {\r\n        for(let body of objects) {\r\n            if(body === this.body)\r\n                continue;\r\n            \r\n            let hitbox;\r\n            //get physics body hitbox\r\n            if(body.isCircle) {\r\n                hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\r\n            }\r\n            else {\r\n                hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\r\n            }\r\n\r\n            if(this.testOverlap(hitbox))\r\n                targets.push(body.gameObject);\r\n        }\r\n    }\r\n    //if objects are game objects\r\n    else {\r\n        for(let object of objects) {\r\n            if(object.body === undefined)\r\n                continue;\r\n\r\n            let hitbox;\r\n            //get physics body hitbox\r\n            if(object.body.isCircle) {\r\n                hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\r\n                if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\r\n                    continue;\r\n            }\r\n            else {\r\n                hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\r\n                if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\r\n                    continue;\r\n            }\r\n\r\n            if(this.testOverlap(hitbox))\r\n                targets.push(object);\r\n        }\r\n    }\r\n\r\n    return targets;\r\n}\r\n\r\n/**\r\n * Process callback for arcade physics collider / overlap.\r\n *\r\n * @method Raycaster.Ray#processOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object} object1 - Game object passed by collider / overlap.\r\n * @param {object} object2 - Game object passed by collider / overlap.\r\n *\r\n * @return {boolean} Return true if game object is overlapping ray's field of view.\r\n */\r\nexport function processOverlap(object1, object2) {\r\n    let target;\r\n\r\n    if(object1._ray === this)\r\n        target = object2;\r\n    else if(object2._ray === this)\r\n        target = obj1;\r\n    else\r\n        return false;\r\n\r\n    return (this.overlap(target).length > 0);\r\n}   \r\n\r\n/**\r\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.8.0\r\n *\r\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testOverlap(hitbox) {\r\n    let overlap = false;\r\n\r\n    //iterate through field of view slices to check collisions with target\r\n    for(let slice of this.slicedIntersections) {\r\n        //if hitbox is a circle\r\n        if(hitbox.type == 0) {\r\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\r\n        }\r\n        //if hitbox is a rectangle\r\n        else {\r\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\r\n        }\r\n\r\n        if(overlap) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n","/**\r\n * Set ray's angle (direction) in radians.\r\n *\r\n * @method Raycaster.Ray#setAngle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {float} [angle = 0] - Ray's angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngle(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's angle (direction) in degrees.\r\n *\r\n * @method Raycaster.Ray#setAngleDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.1\r\n *\r\n * @param {float} [angle = 0] - Ray's angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngleDeg(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n","/**\r\n * Set ray's cone angle (width) in radians.\r\n *\r\n * @method Raycaster.Ray#setCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {float} [cone = 0] - Ray's cone angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCone(cone = 0) {\r\n    this.cone = cone;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's cone angle (width) in degrees.\r\n *\r\n * @method Raycaster.Ray#setConeDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {float} [cone = 0] - Ray's cone angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setConeDeg(cone = 0) {\r\n    this.cone = Phaser.Math.DegToRad(cone);\r\n    return this;\r\n}\r\n","var PhaserRaycaster = function (scene)\r\n{\r\n    //The Scene that owns this plugin\r\n    this.scene = scene;\r\n\r\n    this.systems = scene.sys;\r\n\r\n    if (!scene.sys.settings.isBooted)\r\n    {\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    }\r\n};\r\n\r\n//Static function called by the PluginFile Loader.\r\nPhaserRaycaster.register = function (PluginManager)\r\n{\r\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\r\n\r\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\r\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\r\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\r\n    //  it has an entry in the InjectionMap.\r\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\r\n};\r\n\r\nPhaserRaycaster.prototype = {\r\n\r\n    //  Called when the Plugin is booted by the PluginManager.\r\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\r\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\r\n\r\n        eventEmitter.on('start', this.start, this);\r\n\r\n        eventEmitter.on('preupdate', this.preUpdate, this);\r\n        eventEmitter.on('update', this.update, this);\r\n        eventEmitter.on('postupdate', this.postUpdate, this);\r\n\r\n        eventEmitter.on('pause', this.pause, this);\r\n        eventEmitter.on('resume', this.resume, this);\r\n\r\n        eventEmitter.on('sleep', this.sleep, this);\r\n        eventEmitter.on('wake', this.wake, this);\r\n\r\n        eventEmitter.on('shutdown', this.shutdown, this);\r\n        eventEmitter.on('destroy', this.destroy, this);\r\n    },\r\n\r\n    //A test method.\r\n    test: function (name)\r\n    {\r\n        console.log('RaycasterPlugin says hello ' + name + '!');\r\n    },\r\n\r\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\r\n    start: function ()\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 1\r\n    preUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 2\r\n    update: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 3\r\n    postUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\r\n    pause: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is resumed from a paused state.\r\n    resume: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\r\n    sleep: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is woken from a sleeping state.\r\n    wake: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\r\n    shutdown: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n    },\r\n\r\n    //Create Raycaster object\r\n    createRaycaster: function(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n\r\n};\r\n\r\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\r\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\r\n\r\n//Make sure you export the plugin for webpack to expose\r\n\r\nmodule.exports = PhaserRaycaster;\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.8.0';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    this.graphics;\r\n\r\n    /**\r\n    * Raycaster's bounding box.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {integer}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined && options.scene.physics !== undefined)\r\n            options.boundingBox = options.scene.physics.world.bounds;\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycatser's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {integer} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {integer} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {integer} width - The width of bounding box.\r\n    * @param {integer} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object or array of game objects to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects)) {\r\n            if(this.mappedObjects.includes(objects))\r\n                return this;\r\n\r\n            if(!objects.data)\r\n                objects.setDataEnabled();\r\n\r\n            options.object = objects;\r\n\r\n            let map = new this.Map(options);\r\n\r\n            objects.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(objects);\r\n\r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            if(!object.data)\r\n                object.setDataEnabled();\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config);\r\n\r\n            object.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            let index = this.mappedObjects.indexOf(objects);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n            return this;\r\n        }\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            if(objects.data) {\r\n                let map = objects.data.get('raycasterMap');\r\n                if(map)\r\n                    map.active = true;\r\n            }\r\n                \r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(object.data) {\r\n                let map = object.data.get('raycasterMap');\r\n                if(map)\r\n                    map.active = true;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            if(objects.data) {\r\n                let map = objects.data.get('raycasterMap');\r\n                if(map)\r\n                    map.active = false;\r\n            }\r\n                \r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(object.data) {\r\n                let map = object.data.get('raycasterMap');\r\n                if(map)\r\n                    map.active = false;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                if(mapppedObject.data === undefined)\r\n                    continue;\r\n\r\n                let map = mapppedObject.data.get('raycasterMap')\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray options:\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responsible for mapping game objects.\r\n *\r\n * @namespace Raycaster.Map\r\n * @class Raycaster.Map\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options) {\r\n    /**\r\n    * Mapped object's type\r\n    *\r\n    * @name Raycaster.Map#type\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.type;\r\n    /**\r\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\r\n    *\r\n    * @name Raycaster.Map#active\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.7.2\r\n    */\r\n    this.active;\r\n    /**\r\n    * If set true, map will be automatically updated on scene update event.\r\n    *\r\n    * @name Raycaster.Map#dynamic\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.6.0\r\n    */\r\n    this.dynamic;\r\n    /**\r\n    * Reference to mapped object.\r\n    *\r\n    * @name Raycaster.Map#object\r\n    * @type {object}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.object;\r\n    /**\r\n    * Array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @name Raycaster.Map#_points\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._points = [];\r\n    /**\r\n    * Array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @name Raycaster.Map#_segments\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._segments = [];\r\n    /**\r\n    * Get array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @method Raycaster.Map#getPoints\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n    */\r\n    this.getPoints;\r\n    /**\r\n    * Get array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @method Raycaster.Map#getSegments\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n    */\r\n    this.getSegments;\r\n    /**\r\n    * Update object's map of points and segments.\r\n    *\r\n    * @method Raycaster.Map#updateMap\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n    */\r\n    this.updateMap;\r\n    this.getIntersections;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n","let rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet segmentCount = require('./segmentsCount.js');\r\nlet container = require('./map-container-methods.js');\r\nlet tilemap = require('./map-tilemap-methods.js');\r\n\r\n/**\r\n * Configure map.\r\n *\r\n * @method Raycaster.Map#config\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Map's congfiguration options. May include:\r\n * @param {object} options.object - Game object to map\r\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\r\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\r\n * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\r\n * \r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //object type\r\n    if(options.type === undefined)\r\n        options.type = options.object.type;\r\n    this.type = options.type;\r\n    \r\n    switch(options.type) {\r\n        case 'Polygon':\r\n            this.getPoints = polygon.getPoints;\r\n            this.getSegments = polygon.getSegments;\r\n            this.updateMap = polygon.updateMap;\r\n            break;\r\n        case 'Arc':\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            this.getPoints = arc.getPoints;\r\n            this.getSegments = arc.getSegments;\r\n            this.updateMap = arc.updateMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'Line':\r\n            this.getPoints = line.getPoints;\r\n            this.getSegments = line.getSegments;\r\n            this.updateMap = line.updateMap;\r\n            break;\r\n        case 'Container':\r\n            this.getPoints = container.getPoints;\r\n            this.getSegments = container.getSegments;\r\n            this.updateMap = container.updateMap;\r\n            break;\r\n        case 'StaticTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'DynamicTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        default:\r\n            this.getPoints = rectangle.getPoints;\r\n            this.getSegments = rectangle.getSegments;\r\n            this.updateMap = rectangle.updateMap;\r\n    }\r\n\r\n    //dynamic map\r\n    this.dynamic = (options.dynamic == true) ? true : false;\r\n\r\n    //enable/disable map\r\n    this.active = (options.active !== undefined) ? options.active : true;\r\n\r\n    return this;\r\n}\r\n","/*Map methods for rectangles*/\r\n/**\r\n* Get array of mapped rectangle's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#rectangle.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#rectangle.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update rectangle's map of points and segments.\r\n*\r\n* @method Raycaster.Map#rectangle.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n        \r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for lines*/\r\n/**\r\n* Get array of mapped line's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#line.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped line's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#line.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update line's map of points and segments.\r\n*\r\n* @method Raycaster.Map#line.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for polygons*/\r\n/**\r\n* Get array of mapped polygon's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#polygon.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped polygon's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#polygon.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update polygon's map of points and segments.\r\n*\r\n* @method Raycaster.Map#polygon.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for circles*/\r\n/**\r\n* Get array of mapped circle's vertices used as rays targets.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\r\n*\r\n* @method Raycaster.Map#arc.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped circle's segments used to test object's intersection with ray.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\r\n*\r\n* @method Raycaster.Map#arc.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update circles's map of points and segments.\r\n*\r\n* @method Raycaster.Map#arc.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/**\r\n * Set segment count for cirle's map.\r\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n *\r\n * @method Raycaster.Map#setSegmentCount\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} count - Circle map's segment count.\r\n *\r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function setSegmentCount(count) {\r\n    this.segmentCount = count;\r\n        this.updateMap();\r\n        return this;\r\n}\r\n","/*Map methods for containers*/\r\n/**\r\n* Get array of mapped container's and its children vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#container.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false, getCircles = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let points = [];\r\n    if(!getCircles)\r\n        points = this._points;\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    //get tangent points of container's circles\r\n    if(ray){\r\n        //create temporary ray\r\n        let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n\r\n        let tempRay = ray._raycaster.createRay({\r\n            origin: {\r\n                x: vector.getPointB().x,\r\n                y: vector.getPointB().y\r\n            }\r\n        });\r\n\r\n        for(let child of this.object.list){\r\n            if(child.type === 'Arc'){\r\n\r\n                let map = child.data.get('raycasterMap');\r\n                if(map._points.length == 0){\r\n                    for(let point of map.getPoints(tempRay, true)){\r\n                        let vector = new Phaser.Geom.Line(0, 0, point.x, point.y);\r\n                        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n\r\n                        points.push(new Phaser.Geom.Point(vector.getPointB().x + offset.x, vector.getPointB().y + offset.y));\r\n                    }\r\n                }\r\n            }\r\n            else if(child.type === 'Container') {\r\n                for(let point of child.data.get('raycasterMap').getPoints(tempRay, true)){\r\n                    if(this.object.rotation !== 0) {\r\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n                        points.push(vector.getPointB());\r\n                    }\r\n                    //if rotation === 0\r\n                    else\r\n                        points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#container.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update container's and its children maps of points and segments.\r\n*\r\n* @method Raycaster.Map#container.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let container = this.object;\r\n\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    let rotation = container.rotation;\r\n\r\n    //iterate through container's children\r\n    container.iterate(function(child){\r\n        if(!child.data)\r\n            child.setDataEnabled();\r\n\r\n        //get child map\r\n        let map = child.data.get('raycasterMap');\r\n        if(!map) {\r\n            map = new this.constructor({\r\n                object: child,\r\n                segmentCount: this.segmentCount\r\n            });\r\n            child.data.set('raycasterMap', map);\r\n        }\r\n        else\r\n            map.updateMap();\r\n\r\n        //add child points\r\n        let childPoints = [];\r\n        for(let point of map.getPoints()) {\r\n            //calculate positions after container's rotation\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                points.push(vector.getPointB());\r\n            }\r\n            //if rotation === 0\r\n            else\r\n                points.push(new Phaser.Geom.Point(point.x * container.scaleX + offset.x, point.y * container.scaleX + offset.y));\r\n\r\n            childPoints.push(points[points.length - 1])\r\n        }\r\n\r\n        //add child segments\r\n        for(let segment of map.getSegments()) {\r\n            //calculate positions after container's rotation\r\n            if(rotation !== 0) {\r\n                let pointA = segment.getPointA();\r\n                let pointB = segment.getPointB();\r\n                let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n                let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n                Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n\r\n                segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\r\n            }\r\n            //if rotation === 0\r\n            else\r\n                segments.push(new Phaser.Geom.Line(segment.getPointA().x * container.scaleX + offset.x, segment.getPointA().y * container.scaleY + offset.y, segment.getPointB().x * container.scaleX + offset.x, segment.getPointB().y * container.scaleY + offset.y));\r\n        }\r\n\r\n    }.bind(this));\r\n\r\n    //get children intersections\r\n    for(let i = 0, iLength = container.list.length; i < iLength; i++){\r\n        let childA = container.list[i];\r\n        let mapA = childA.data.get('raycasterMap');\r\n\r\n        for(let j = i+1, jLength = container.list.length; j < jLength; j++){\r\n            let childB = container.list[j];\r\n            let mapB = childB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\r\n                continue;\r\n\r\n            //find objects intersections\r\n            for(let segmentA of mapA.getSegments()) {\r\n                for(let segmentB of mapB.getSegments()) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    \r\n                     //calculate positions after container's rotation\r\n                    if(rotation !== 0) {\r\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, intersection.x * this.object.scaleX + offset.x, intersection.y * this.object.scaleY + offset.y);\r\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                        points.push(vector.getPointB());\r\n                    }\r\n                    //if rotation === 0\r\n                    else\r\n                        points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for tilemaps*/\r\n/**\r\n* Get array of mapped tilemap's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#tilemap.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._points;\r\n\r\n    let points = [];\r\n    for(let point of this._points) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\r\n            points.push(point);\r\n    }\r\n\r\n    //get intersections between tilemap's segments and ray's detection range edge\r\n    let segments = this.getSegments(ray);\r\n\r\n    for(let segment of segments) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\r\n        \r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#tilemap.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._segments;\r\n\r\n    let segments = [];\r\n    for(let segment of this._segments) {\r\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\r\n            segments.push(segment);\r\n        }\r\n    }\r\n\r\n    return segments;\r\n};\r\n\r\n/**\r\n* Update tilemap's map of points and segments.\r\n*\r\n* @method Raycaster.Map#tilemap.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x;\r\n    offset.y = this.object.y;\r\n\r\n    let horizontal = false;\r\n    let horizontals = [];\r\n    let verticals = [];\r\n\r\n    //iterate rows\r\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\r\n        let row = this.object.layer.data[i];\r\n\r\n        //iterate row's tiles\r\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\r\n            let tile = row[j];\r\n\r\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\r\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\r\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\r\n\r\n            //get current tile's column last vertical line\r\n            let vertical = false;\r\n            if(verticals.length <= j)\r\n                verticals[j] = [];\r\n            else if(verticals[j].length > 0)\r\n                vertical = verticals[j][verticals[j].length - 1];\r\n\r\n            //check if tile has edge from left\r\n            if(leftEdge) {\r\n                if(vertical && vertical.y + vertical.height == i)\r\n                    vertical.height++;\r\n                else {\r\n                    verticals[j].push({\r\n                        x: tile.x,\r\n                        y: tile.y,\r\n                        height: 1\r\n                    });\r\n                }\r\n            }\r\n\r\n            //check if tile has edge from top\r\n            if(upperEdge) {\r\n                if(horizontal)\r\n                    horizontal.width++;\r\n                else\r\n                    horizontal = {\r\n                        x: tile.x,\r\n                        y: tile.y,\r\n                        width: 1\r\n                    };\r\n                continue;\r\n            }\r\n\r\n            if(horizontal) {\r\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n                segments.push(segment);\r\n                horizontals.push(segment);\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n                horizontal = false;\r\n            }\r\n        }\r\n        \r\n        //at the end of row add segment if exist\r\n        if(horizontal) {\r\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n            segments.push(segment);\r\n            horizontals.push(segment);\r\n            points.push(new Phaser.Geom.Point(x, y));\r\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n            horizontal = false;\r\n        }\r\n    }\r\n\r\n    //add bottom horizontal segments\r\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\r\n        if(this.collisionTiles.includes(tile.index)) {\r\n            if(horizontal)\r\n                horizontal.width++;\r\n            else\r\n                horizontal = {\r\n                    x: tile.x,\r\n                    y: tile.y + 1,\r\n                    width: 1\r\n                };\r\n            continue;\r\n        }\r\n\r\n        if(horizontal) {\r\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n            segments.push(segment);\r\n            horizontals.push(segment);\r\n            points.push(new Phaser.Geom.Point(x, y));\r\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n            horizontal = false;\r\n        }\r\n    }\r\n\r\n    //add segment if exist\r\n    if(horizontal) {\r\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n        segments.push(segment);\r\n        horizontals.push(segment);\r\n        points.push(new Phaser.Geom.Point(x, y));\r\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n        horizontal = false;\r\n    }\r\n    \r\n    //add right vertical segments\r\n    let vertical = false;\r\n    let verticalsLastColumn = [];\r\n    for(let row of this.object.layer.data) {\r\n        let tile = row[row.length - 1];\r\n\r\n        //if tile blocks ray\r\n        if(this.collisionTiles.includes(tile.index)) {\r\n            if(vertical) {\r\n                vertical.height++;\r\n            }\r\n            else {\r\n                vertical = {\r\n                    x: tile.x + 1,\r\n                    y: tile.y,\r\n                    height: 1\r\n                };\r\n            }\r\n\r\n            continue;\r\n        }\r\n\r\n        if(vertical) {\r\n            verticalsLastColumn.push(vertical);\r\n            vertical = false;\r\n        }\r\n    }\r\n\r\n    verticals.push(verticalsLastColumn);\r\n    \r\n    //add vertical segments\r\n    for(let column of verticals) {\r\n        if(!column)\r\n            continue;\r\n\r\n        for(let vertical of column) {\r\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\r\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\r\n            segments.push(segment);\r\n\r\n            //add points if they're not already there\r\n            if(!points.filter(point => point.x == x && point.y == y1))\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n\r\n            if(!points.filter(point => point.x == x && point.y == y2))\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n\r\n            //get intersections between horizontal segments and vertical\r\n            for(let horizontalSegment of horizontals) {\r\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\r\n                    continue;\r\n\r\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\r\n                    continue;\r\n\r\n                let point = new Phaser.Geom.Point();\r\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\r\n                    points.push(point);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n\r\n/**\r\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\r\n*\r\n* @method Raycaster.Map#setCollisionTiles\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @since 0.7.3\r\n*\r\n* @param {array} [tiles = []] - Set of tile's indexes to map.\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function setCollisionTiles(tiles = []) {\r\n    this.collisionTiles = tiles;\r\n    return this;\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @namespace Raycaster.Ray\r\n * @class Raycaster.Ray\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Ray specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Ray#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Ray's source position.\r\n    *\r\n    * @name Raycaster.Ray#origin\r\n    * @type {Phaser.Geom.Point}\r\n    * @since 0.6.0\r\n    */\r\n    this.origin = new Phaser.Geom.Point();\r\n    /**\r\n    * Ray's representation used to calculating intersections.\r\n    *\r\n    * @name Raycaster.Ray#_ray\r\n    * @type {Phaser.Geom.Line}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._ray = new Phaser.Geom.Line();\r\n    /**\r\n    * Ray's angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#angle\r\n    * @type {float}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.angle = 0;\r\n    /**\r\n    * Ray's cone width angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#cone\r\n    * @type {float}\r\n    * @default 0\r\n    * @since 0.7.0\r\n    */\r\n    this.cone = 0;\r\n    /**\r\n    * Ray's maximum range\r\n    *\r\n    * @name Raycaster.Ray#rayRange\r\n    * @type {integer}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.6.0\r\n    */\r\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\r\n    * Ray tests all objects when set to 0.\r\n    *\r\n    * @name Raycaster.Ray#detectionRange\r\n    * @type {integer}\r\n    * @default\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRange = 0;\r\n    /**\r\n    * Ray's representation of detection range used in calculating if objects are in range.\r\n    *\r\n    * @name Raycaster.Ray#detectionRangeCircle\r\n    * @type {Phaser.Geom.Circle}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    /**\r\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\r\n    *\r\n    * @name Raycaster.Ray#collisionRange\r\n    * @type {integer}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.8.0\r\n    */\r\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    *\r\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.6.0\r\n    */\r\n    this.ignoreNotIntersectedRays = true;\r\n    /**\r\n    * If set true, ray's hit points will be rounded.\r\n    *\r\n    * @name Raycaster.Ray#round\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.1\r\n    */\r\n    this.round = false;\r\n    /**\r\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    *\r\n    * @name Raycaster.Ray#autoSlice\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.0\r\n    */\r\n    this.autoSlice = false;\r\n    /**\r\n    * Array of intersections from last raycast representing field of view.\r\n    *\r\n    * @name Raycaster.Ray#intersections\r\n    * @type {object[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.intersections = [];\r\n    /**\r\n    * Array of triangles representing slices of field of view from last raycast.\r\n    *\r\n    * @name Raycaster.Ray#slicedIntersections\r\n    * @type {Phaser.Geom.Triangle[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.slicedIntersections = [];\r\n\r\n    /**\r\n    * Physics body for testing field of view collisions.\r\n    *\r\n    * @name Raycaster.Ray#body\r\n    * @type {(object|bolean)}\r\n    * @default undefined\r\n    * @since 0.8.0\r\n    */\r\n    //this.body = false;\r\n    //this.arcadePhysicsCircle;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRayRange: require('./range.js').setRayRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone,\r\n    slice: require('./slice.js').slice,\r\n    setCollisionRange: require('./range.js').setCollisionRange,\r\n    enableArcadePhysics: require('./enableArcadePhysics.js').enableArcadePhysics,\r\n    overlap: require('./overlap.js').overlap,\r\n    processOverlap: require('./overlap.js').processOverlap,\r\n    testOverlap: require('./overlap.js').testOverlap\r\n};\r\n","/**\r\n * Configure ray.\r\n *\r\n * @method Raycaster.Ray#config\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {float} [options.angle = 0] - Ray's angle in radians.\r\n * @param {float} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {float} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //origin\r\n    if(options.origin !== undefined)\r\n        this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n    //angle\r\n    if(options.angle !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\r\n\r\n    //angle deg\r\n    if(options.angleDeg !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\r\n\r\n    //cone angle\r\n    if(options.cone !== undefined)\r\n        this.cone = options.cone;\r\n\r\n    //cone angle deg\r\n    if(options.coneDeg !== undefined)\r\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //ray range (0 = max)\r\n    if(options.rayRange !== undefined)\r\n        this.rayRange = options.rayRange;\r\n\r\n    //collision range (0 = max)\r\n    if(options.collisionRange !== undefined)\r\n        this.collisionRange = options.collisionRange;\r\n\r\n    //detection range (0 = max)\r\n    if(options.detectionRange !== undefined)\r\n        this.detectionRange = options.detectionRange;\r\n\r\n    //ignore not intersected rays\r\n    if(options.ignoreNotIntersectedRays !== undefined)\r\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n    \r\n    //round\r\n    if(options.round !== undefined)\r\n        this.round = (options.round == true)\r\n\r\n    //auto slice\r\n    if(options.autoSlice !== undefined)\r\n        this.autoSlice = (options.autoSlice == true)\r\n    \r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Set ray's position, direction (angle) and range.\r\n *\r\n * @method Raycaster.Ray#setRay\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} x - X coordinate.\r\n * @param {integer} y - Y coordinate.\r\n * @param {float} [angle] - Ray's angle in radians.\r\n * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.origin.setTo(x, y);\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    this.rayRange = rayRange;\r\n\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n    return this;\r\n}\r\n","/**\r\n * Set ray's source position.\r\n *\r\n * @method Raycaster.Ray#setOrigin\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} x - X coordinate.\r\n * @param {integer} y - Y coordinate.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOrigin(x, y) {\r\n    this.origin.setTo(x, y);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this.body !== undefined) {\r\n        this.arcadePhysicsCircle.x = x;\r\n        this.arcadePhysicsCircle.y = y;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Cast ray to find closest intersection with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#cast\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\r\n * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\r\n *\r\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found.\r\n */\r\nexport function cast(options = {}) {\r\n    let closestIntersection;\r\n    let closestDistance = this.rayRange;\r\n    //if bounding box is defined check bounding box intersection\r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        let intersections = [];\r\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n        if(intersections.length === 1)\r\n            closestIntersection = intersections[0];\r\n        else if(intersections.length > 1) {\r\n            for(let intersection of intersections) {\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n        }\r\n        //if ray target is declared\r\n        else if(options.target){\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n            //if target is within ray range\r\n            if(this.rayRange > distance) {\r\n                closestDistance = distance;\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n    }\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n    \r\n    for(let object of options.objects) {\r\n        //check if object is intersected by ray\r\n        if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\r\n            continue;\r\n\r\n        let map = object.data.get('raycasterMap');\r\n        \r\n        //check intersections\r\n        for(let segment of map.getSegments(this)) {\r\n            let intersection = [];\r\n\r\n            //if target point is segmemt point\r\n            if(options.target) {\r\n                if(\r\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                ) {\r\n                    intersection = options.target;\r\n                }\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                    continue;\r\n            }\r\n            //if no intersection continue\r\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n              continue;\r\n            \r\n            //get closest intersection\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n            if(distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestIntersection = intersection;\r\n            }\r\n        }\r\n\r\n        //check arc intersections if its not\r\n        if(map.type === 'Arc') {\r\n           //if arc has generated points (besides tangent points to ray)\r\n            if(map._points.length > 0) {\r\n                continue;\r\n            }\r\n            \r\n            //check if target point is a circle tangent point to ray\r\n            if(options.target) {\r\n                let points = map.getPoints(this);\r\n                let isTangent = false;\r\n                for(let point of points) {\r\n\r\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = point;\r\n                            isTangent = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(isTangent)\r\n                    continue;\r\n            }\r\n\r\n            let circleIntersections = [];\r\n            let offset = new Phaser.Geom.Point();\r\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n            //calculate circle's center after rotation\r\n            let rotation = map.object.rotation;\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                let cB = vector.getPointB();\r\n                offset.x = cB.x;\r\n                offset.y = cB.y;\r\n            }\r\n\r\n            //create transformed circle\r\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                for(let intersection of circleIntersections) {\r\n                    //get closest intersection\r\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                    if(distance < closestDistance) {\r\n\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let result;\r\n    if(!closestIntersection) {\r\n        if(this.ignoreNotIntersectedRays)\r\n            return false;\r\n\r\n        result = this._ray.getPointB();\r\n    }\r\n    else {\r\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n    }\r\n\r\n    if(this.round) {\r\n        result.x = Math.round(result.x);\r\n        result.y = Math.round(result.y);\r\n    }\r\n    \r\n    return result;\r\n}\r\n","/**\r\n * Cast ray in all directions to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCircle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n */\r\nexport function castCircle(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n\r\n        //if bounding box is defined add bounding box points to \r\n        if(this._raycaster && this._raycaster.boundingBox) {\r\n            for(let point of this._raycaster.boundingBox.points) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                });\r\n            }\r\n        }\r\n\r\n        for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n            let object = options.objects[i];\r\n            //if bound in range\r\n            if(!this.boundsInRange(object))\r\n                continue;\r\n            \r\n            testedObjects.push(object);\r\n\r\n            let map = object.data.get('raycasterMap');\r\n            maps.push(map);\r\n            //get points and angles\r\n            for(let point of map.getPoints(this)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                });\r\n            }\r\n\r\n            //get objects intersections\r\n            for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n                let objectB = options.objects[j];\r\n                let mapB = objectB.data.get('raycasterMap');\r\n                //check if bounding boxes overlap\r\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\r\n                    continue;\r\n                \r\n                //find objects intersections\r\n                for(let segmentA of map.getSegments(this)) {\r\n                    for(let segmentB of mapB.getSegments(this)) {\r\n                        let intersection = [];\r\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                            continue;\r\n                        \r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //sort target points by angle\r\n        rayTargets.sort(function(a, b){\r\n            //if rays towards points have the same angles promote closer one\r\n            if(a.angle == b.angle) {\r\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                    return 1;\r\n                else\r\n                    return -1;\r\n            }\r\n\r\n            return a.angle - b.angle;\r\n        }.bind(this));\r\n\r\n        let previousTarget = {\r\n            angle: false\r\n        };\r\n\r\n        //cast rays\r\n        for(let target of rayTargets){\r\n            //if current target is the same as previous one skip loop\r\n            if(target.angle === previousTarget.angle) {\r\n                continue;\r\n            }\r\n\r\n            previousTarget = target;\r\n\r\n            this.setAngle(target.angle);\r\n            let intersection = this.cast({\r\n                objects: testedObjects,\r\n                target: target.point\r\n            });\r\n\r\n            if(intersection){\r\n                //if intersection hits target point cast two additional rays\r\n                let castSides = false;\r\n                if(this.round) {\r\n                    let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                    castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n                }\r\n                else {\r\n                    castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n                }\r\n                if(castSides) {\r\n                    this.setAngle(target.angle - 0.0001);\r\n                    let intersectionA = this.cast({\r\n                        objects: testedObjects\r\n                    });\r\n\r\n                    if(intersectionA) {\r\n                        intersections.push(intersectionA);\r\n                    }\r\n\r\n                    intersections.push(intersection);\r\n\r\n                    this.setAngle(target.angle + 0.0001);\r\n                    let intersectionB = this.cast({\r\n                        objects: testedObjects\r\n                    });\r\n\r\n                    if(intersectionB) {\r\n                        intersections.push(intersectionB);\r\n                    }\r\n\r\n                    continue;\r\n                }\r\n\r\n                intersections.push(intersection);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice();\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Cast ray in a cone to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n */\r\nexport function castCone(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let cone = this.cone;\r\n    let minAngle = 0;\r\n    let maxAngle = 0;\r\n    let angleOffset = 0;\r\n\r\n    //set cone\r\n    if(options.cone !== undefined)\r\n        cone = options.cone;\r\n    if(options.coneDeg !== undefined)\r\n        cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //set cone min and max angle\r\n    minAngle = this.angle - cone / 2;\r\n    maxAngle = this.angle + cone / 2;\r\n\r\n    //add min and max angle points\r\n    this.setAngle(minAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: minAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\r\n    });\r\n\r\n    this.setAngle(maxAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: maxAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\r\n    });\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n\r\n        //if bounding box is defined add bounding box points to \r\n        if(this._raycaster && this._raycaster.boundingBox) {\r\n            for(let point of this._raycaster.boundingBox.points) {\r\n\r\n                let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n                let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                    rayTargets.push({\r\n                        point: point,\r\n                        angle: angle,\r\n                        angleOffsetDeg: -angleOffsetDeg\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map = object.data.get('raycasterMap');\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB = objectB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\r\n                            angleOffsetDeg: -angleOffsetDeg\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angleOffsetDeg - b.angleOffsetDeg;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n        \r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point\r\n        });\r\n        if(intersection){\r\n            //if intersection hits target point cast two additional rays\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice(intersections, false);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\r\n *\r\n * @method Raycaster.Ray#slice\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\r\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\r\n *\r\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\r\n */\r\nexport function slice(intersections = this.intersections, closed = true) {\r\n    //if intersections is Phaser.Geom.Polygon object\r\n    if(!Array.isArray(intersections)) {\r\n        if(intersections.type === 4)\r\n            intersections = intersections.points;\r\n        else\r\n            return [];\r\n    }\r\n\r\n    if(intersections.length === 0)\r\n        return [];\r\n\r\n    let slices = [];\r\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\r\n    }\r\n\r\n    if(closed)\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\r\n\r\n    return slices;\r\n}\r\n","/**\r\n * Add to ray arcade physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}.\r\n *\r\n * @method Raycaster.Ray#enableArcadePhysics\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function enableArcadePhysics() {\r\n    \r\n    if(this.body !== undefined)\r\n        return this;\r\n\r\n    this.arcadePhysicsCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\r\n    this.arcadePhysicsCircle._ray = this;\r\n    this._raycaster.scene.physics.add.existing(this.arcadePhysicsCircle);\r\n\r\n    this.body = this.arcadePhysicsCircle.body;\r\n    this.body\r\n        .setCircle(this.collisionRange)\r\n        .setAllowGravity(false)\r\n        .setImmovable(true);\r\n\r\n    return this;\r\n}\r\n"],"sourceRoot":""}