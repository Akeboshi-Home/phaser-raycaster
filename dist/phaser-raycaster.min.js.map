{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setRange","range","Phaser","Math","MAX_SAFE_INTEGER","this","Geom","Line","SetToAngle","_ray","origin","x","y","angle","setDetectionRange","detectionRange","rangeCircle","setTo","boundsInRange","objectBounds","bounds","getBounds","Intersects","CircleToRectangle","detectionRangeCircle","setAngle","Angle","Normalize","setAngleDeg","DegToRad","setCone","cone","setConeDeg","PhaserRaycaster","scene","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","version","graphics","boundingBox","mappedObjects","sortedPoints","mapSegmentCount","physics","world","setOptions","add","lineStyle","width","color","fillStyle","objects","mapGameObjects","setBoundingBox","height","rectangle","Rectangle","points","segments","Point","left","top","right","bottom","length","push","dynamic","segmentCount","Array","isArray","includes","data","setDataEnabled","map","Map","set","removeMappedObjects","index","indexOf","splice","mapppedObject","updateMap","createRay","Ray","type","active","_object","_points","_segments","getPoints","getSegments","getIntersections","config","_getPolygonPoints","_getPolygonSegments","_updatePolygonMap","_getArcPoints","_getArcSegments","_updateArcMap","_getLinePoints","_getLineSegments","_updateLineMap","_getRectanglePoints","_getRectangleSegments","_updateRectangleMap","setSegmentCount","count","line","polygon","arc","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","pointA","geom","getPointA","pointB","getPointB","rotation","vectorA","scaleX","scaleY","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","rayLength","sqrt","pow","radius","dAngle","asin","newPoints","raycaster","Circle","ignoreNotIntersectedRays","intersections","_raycaster","setRay","setOrigin","cast","castCircle","castCone","angleDeg","coneDeg","closestIntersection","closestDistance","GetLineToRectangle","intersection","distance","Distance","Between","target","segment","Equals","LineToLine","isTangent","circleIntersections","circle","GetLineToCircle","x1","y1","originalAngle","maps","rayTargets","testedObjects","iLength","j","jLength","objectB","mapB","RectangleToRectangle","segmentA","segmentB","sort","a","b","intersectionA","intersectionB","minAngle","maxAngle","angleOffsetDeg","RadToDeg","ShortestBetween","abs"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,kBAAmB,GAAIH,GACJ,iBAAZC,QACdA,QAAyB,gBAAID,IAE7BD,EAAsB,gBAAIC,IAR5B,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,+BCxE9C,SAASC,IAA+C,IAAtCC,EAAsC,uDAA9BC,OAAOC,KAAKC,iBAGzC,OAFAC,KAAKJ,MAAQA,EACbC,OAAOI,KAAKC,KAAKC,WAAWH,KAAKI,KAAMJ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGP,KAAKQ,MAAOR,KAAKJ,OAC/EI,KAaJ,SAASS,IAAsC,IAApBC,EAAoB,uDAAH,EAG/C,OAFAV,KAAKU,eAAiBA,EACtBV,KAAKW,YAAYC,MAAMZ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAEP,KAAKU,gBAClDV,KAcJ,SAASa,EAAcxB,GAAwB,IAI9CyB,EAJ8BC,EAAgB,wDAClD,OAAIf,KAAKU,iBAKLI,EADDC,GAGgB1B,EAAO2B,cAEvBnB,OAAOI,KAAKgB,WAAWC,kBAAkBlB,KAAKmB,qBAAsBL,IArD3E,iJ,6BCUO,SAASM,IAAoB,IAAXZ,EAAW,uDAAH,EAG7B,OAFAR,KAAKQ,MAAQX,OAAOC,KAAKuB,MAAMC,UAAUd,GACzCX,OAAOI,KAAKC,KAAKC,WAAWH,KAAKI,KAAMJ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGP,KAAKQ,MAAOR,KAAKJ,OAC/EI,KAaJ,SAASuB,IAAuB,IAAXf,EAAW,uDAAH,EAGhC,OAFAR,KAAKQ,MAAQX,OAAOC,KAAKuB,MAAMC,UAAUzB,OAAOC,KAAK0B,SAAShB,IAC9DX,OAAOI,KAAKC,KAAKC,WAAWH,KAAKI,KAAMJ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGP,KAAKQ,MAAOR,KAAKJ,OAC/EI,KA7BX,6F,6BCUO,SAASyB,IAAkB,IAAVC,EAAU,uDAAH,EAE3B,OADA1B,KAAK0B,KAAOA,EACL1B,KAaJ,SAAS2B,IAAqB,IAAVD,EAAU,uDAAH,EAE9B,OADA1B,KAAK0B,KAAO7B,OAAOC,KAAK0B,SAASE,GAC1B1B,KA3BX,2F;;;;;;ACMA,IAAI4B,EAAkB,SAAUC,GAG5B7B,KAAK6B,MAAQA,EAEb7B,KAAK8B,QAAUD,EAAME,IAEhBF,EAAME,IAAIC,SAASC,UAEpBJ,EAAME,IAAIG,OAAOC,KAAK,OAAQnC,KAAKoC,KAAMpC,OAKjD4B,EAAgBS,SAAW,SAAUC,GAQjCA,EAAcD,SAAS,kBAAmBT,EAAiB,UAG/DA,EAAgBrC,UAAY,CAIxB6C,KAAM,WAEF,IAAIG,EAAevC,KAAK8B,QAAQI,OAKhCK,EAAaC,GAAG,QAASxC,KAAKyC,MAAOzC,MAErCuC,EAAaC,GAAG,YAAaxC,KAAK0C,UAAW1C,MAC7CuC,EAAaC,GAAG,SAAUxC,KAAK2C,OAAQ3C,MACvCuC,EAAaC,GAAG,aAAcxC,KAAK4C,WAAY5C,MAE/CuC,EAAaC,GAAG,QAASxC,KAAK6C,MAAO7C,MACrCuC,EAAaC,GAAG,SAAUxC,KAAK8C,OAAQ9C,MAEvCuC,EAAaC,GAAG,QAASxC,KAAK+C,MAAO/C,MACrCuC,EAAaC,GAAG,OAAQxC,KAAKgD,KAAMhD,MAEnCuC,EAAaC,GAAG,WAAYxC,KAAKiD,SAAUjD,MAC3CuC,EAAaC,GAAG,UAAWxC,KAAKkD,QAASlD,OAI7CmD,KAAM,SAAUjF,GAEZkF,QAAQC,IAAI,8BAAgCnF,EAAO,MAIvDuE,MAAO,aAKPC,UAAW,SAAUY,EAAMC,KAK3BZ,OAAQ,SAAUW,EAAMC,KAKxBX,WAAY,SAAUU,EAAMC,KAK5BV,MAAO,aAKPC,OAAQ,aAKRC,MAAO,aAKPC,KAAM,aAKNC,SAAU,aAKVC,QAAS,WAELlD,KAAKiD,WAELjD,KAAK6B,WAAQ2B,GAIjBC,gBAAiB,WAAuB,IAAdC,EAAc,uDAAJ,GAEhC,OADAA,EAAQ7B,MAAQ7B,KAAK6B,MACd,IAAI7B,KAAK2D,WAAWD,MAKTE,YAAchC,EACxCA,EAAgBrC,UAAUoE,WAAaE,EAAQ,GAAuBC,UAItE1G,EAAOD,QAAUyE,G;;;;;;AC5HV,SAASkC,EAAUJ,GAmBtB,OAlBA1D,KAAK+D,QAAU,QACf/D,KAAK6B,MACL7B,KAAKgE,SACLhE,KAAKiE,aAAc,EACnBjE,KAAKkE,cAAgB,GACrBlE,KAAKmE,aAAe,GACpBnE,KAAKoE,gBAAkB,OAERZ,IAAZE,SAC4BF,IAAxBE,EAAQO,kBAA+CT,IAAlBE,EAAQ7B,YAAiD2B,IAA1BE,EAAQ7B,MAAMwC,UACjFX,EAAQO,YAAcP,EAAQ7B,MAAMwC,QAAQC,MAAMvD,QAEtDf,KAAKuE,WAAWb,IAIpB1D,KAAK6B,MAAMK,OAAOM,GAAG,SAAUxC,KAAK2C,OAAOxD,KAAKa,OAEzCA,KAzBX,iDA4BA8D,EAAUvE,UAAY,CAElBgF,WAAY,SAASb,GAejB,YAdqBF,IAAlBE,EAAQ7B,QACP7B,KAAK6B,MAAQ6B,EAAQ7B,MACrB7B,KAAKgE,SAAYhE,KAAK6B,MAAM2C,IAAIR,SAAS,CAAES,UAAW,CAAEC,MAAO,EAAGC,MAAO,OAAWC,UAAW,CAAED,MAAO,kBAG7EnB,IAA5BE,EAAQU,kBACPpE,KAAKoE,gBAAkBV,EAAQU,sBAEZZ,IAApBE,EAAQmB,SACP7E,KAAK8E,eAAepB,EAAQmB,cAELrB,IAAxBE,EAAQO,aACPjE,KAAK+E,eAAerB,EAAQO,YAAY3D,EAAGoD,EAAQO,YAAY1D,EAAGmD,EAAQO,YAAYS,MAAOhB,EAAQO,YAAYe,QAE9GhF,MAIX+E,eAAgB,SAASzE,EAAGC,EAAGmE,EAAOM,GAClChF,KAAKiE,YAAc,CACfgB,UAAW,IAAIpF,OAAOI,KAAKiF,UAAU5E,EAAGC,EAAGmE,EAAOM,GAClDG,OAAQ,GACRC,SAAU,IAGd,IAAID,EAAS,CACT,IAAItF,OAAOI,KAAKoF,MAAMrF,KAAKiE,YAAYgB,UAAUK,KAAMtF,KAAKiE,YAAYgB,UAAUM,KAClF,IAAI1F,OAAOI,KAAKoF,MAAMrF,KAAKiE,YAAYgB,UAAUO,MAAOxF,KAAKiE,YAAYgB,UAAUM,KACnF,IAAI1F,OAAOI,KAAKoF,MAAMrF,KAAKiE,YAAYgB,UAAUO,MAAOxF,KAAKiE,YAAYgB,UAAUQ,QACnF,IAAI5F,OAAOI,KAAKoF,MAAMrF,KAAKiE,YAAYgB,UAAUK,KAAMtF,KAAKiE,YAAYgB,UAAUQ,SAGtFzF,KAAKiE,YAAYkB,OAASA,EAG1B,IAAI,IAAIxH,EAAI,EAAG+H,EAAS1F,KAAKiE,YAAYkB,OAAOO,OAAQ/H,EAAI+H,EAAQ/H,IAC7DA,EAAE,EAAI+H,EACT1F,KAAKiE,YAAYmB,SAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAKiF,EAAOxH,GAAG2C,EAAG6E,EAAOxH,GAAG4C,EAAG4E,EAAOxH,EAAE,GAAG2C,EAAG6E,EAAOxH,EAAE,GAAG4C,IAEzGP,KAAKiE,YAAYmB,SAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAKiF,EAAOxH,GAAG2C,EAAG6E,EAAOxH,GAAG4C,EAAG4E,EAAO,GAAG7E,EAAG6E,EAAO,GAAG5E,KAK7GuE,eAAgB,SAASD,GAA+D,IAAtDe,EAAsD,wDAArCC,EAAqC,uDAAtB7F,KAAKoE,gBACnE,IAAI0B,MAAMC,QAAQlB,GAAU,CACxB,GAAG7E,KAAKkE,cAAc8B,SAASnB,GAC3B,OAAO7E,KAEP6E,EAAQoB,MACRpB,EAAQqB,iBAEZ,IAAIC,EAAM,IAAInG,KAAKoG,IAAI,CACnB/G,OAAQwF,EACRe,QAASA,EACTC,aAAcA,GACf7F,KAAK6B,OAKR,OAHAgD,EAAQoB,KAAKI,IAAI,eAAgBF,GACjCnG,KAAKkE,cAAcyB,KAAKd,GAEjB7E,KAjByE,2BAoBpF,YAAkB6E,EAAlB,+CAA2B,KAAnBxF,EAAmB,QACvB,IAAGW,KAAKkE,cAAc8B,SAAS3G,GAA/B,CAGIA,EAAO4G,MACP5G,EAAO6G,iBAEX,IAAIC,EAAM,IAAInG,KAAKoG,IAAI,CACnB/G,OAAQA,EACRuG,QAASA,EACTC,aAAcA,IAGlBxG,EAAO4G,KAAKI,IAAI,eAAgBF,GAChCnG,KAAKkE,cAAcyB,KAAKtG,KAlCwD,kFAoCpF,OAAOW,MAIXsG,oBAAqB,SAASzB,GAC1B,IAAIiB,MAAMC,QAAQlB,GAAU,CACxB,IAAI0B,EAAQvG,KAAKkE,cAAcsC,QAAQ3B,GAGvC,OAFG0B,GAAS,GACRvG,KAAKkE,cAAcuC,OAAOF,EAAO,GAC9BvG,KALwB,2BAQnC,YAAkB6E,EAAlB,+CAA2B,KAAnBxF,EAAmB,QACnBkH,EAAQvG,KAAKkE,cAAcsC,QAAQnH,GACpCkH,GAAS,GACRvG,KAAKkE,cAAcuC,OAAOF,EAAO,IAXN,kFAcnC,OAAOvG,MAIX2C,OAAQ,WAEJ,GAAG3C,KAAKkE,cAAcwB,OAAS,EAA/B,4BACI,YAAyB1F,KAAKkE,cAA9B,+CAA6C,KAArCwC,EAAqC,QACzC,QAA0BlD,IAAvBkD,EAAcT,KAAjB,CAGA,IAAIE,EAAMO,EAAcT,KAAKzH,IAAI,gBAC9B2H,EAAIP,SACHO,EAAIQ,cAPhB,qFAYJC,UAAW,WAAuB,IAAdlD,EAAc,uDAAJ,GAC1B,OAAO,IAAI1D,KAAK6G,IAAInD,EAAS1D,QAIrC8D,EAAUvE,UAAU6G,IAAMvC,EAAQ,GAAqBuC,IACvDtC,EAAUvE,UAAUsH,IAAMhD,EAAQ,IAAqBgD,K;;;;;;ACnJhD,SAAST,EAAI1C,EAAS7B,GAezB,OAdA7B,KAAK8G,KACL9G,KAAK+G,OACL/G,KAAK4F,QACL5F,KAAKgH,QACLhH,KAAKiH,QAAU,GACfjH,KAAKkH,UAAY,GACjBlH,KAAKmH,UACLnH,KAAKoH,YACLpH,KAAKqH,iBACLrH,KAAK6F,aAAe,EAEpB7F,KAAKsH,OAAO5D,GACZ1D,KAAK2G,YAEE3G,KArBX,2CAyBAoG,EAAI7G,UAAY,CACZ+H,OAAQ,SAAS5D,GAOb,OANA1D,KAAKX,OAASqE,EAAQrE,YAEFmE,IAAjBE,EAAQoD,OACPpD,EAAQoD,KAAOpD,EAAQrE,OAAOyH,MAClC9G,KAAK8G,KAAOpD,EAAQoD,KAEbpD,EAAQoD,MACX,IAAK,UACD9G,KAAKmH,UAAYnH,KAAKuH,kBACtBvH,KAAKoH,YAAcpH,KAAKwH,oBACxBxH,KAAK2G,UAAY3G,KAAKyH,kBACtB,MACJ,IAAK,MACDzH,KAAKmH,UAAYnH,KAAK0H,cACtB1H,KAAKoH,YAAcpH,KAAK2H,gBACxB3H,KAAK2G,UAAY3G,KAAK4H,cACtB,MACJ,IAAK,OACD5H,KAAKmH,UAAYnH,KAAK6H,eACtB7H,KAAKoH,YAAcpH,KAAK8H,iBACxB9H,KAAK2G,UAAY3G,KAAK+H,eACtB,MACJ,QACI/H,KAAKmH,UAAYnH,KAAKgI,oBACtBhI,KAAKoH,YAAcpH,KAAKiI,sBACxBjI,KAAK2G,UAAY3G,KAAKkI,oBAO9B,OAHAlI,KAAK4F,QAA8B,GAAnBlC,EAAQkC,QACxB5F,KAAK6F,aAAgBnC,EAAQmC,aAAgBnC,EAAQmC,aAAe,EAE7D7F,MAIXmI,gBAAiB,SAASC,GAGtB,OAFApI,KAAK6F,aAAeuC,EACpBpI,KAAK2G,YACE3G,OAIf,IAAIiF,EAAYpB,EAAQ,GACxBuC,EAAI7G,UAAUyI,oBAAsB/C,EAAUkC,UAC9Cf,EAAI7G,UAAU0I,sBAAwBhD,EAAUmC,YAChDhB,EAAI7G,UAAU2I,oBAAsBjD,EAAU0B,UAG9C,IAAI0B,EAAOxE,EAAQ,GACnBuC,EAAI7G,UAAUsI,eAAiBQ,EAAKlB,UACpCf,EAAI7G,UAAUuI,iBAAmBO,EAAKjB,YACtChB,EAAI7G,UAAUwI,eAAiBM,EAAK1B,UAGpC,IAAI2B,EAAUzE,EAAQ,GACtBuC,EAAI7G,UAAUgI,kBAAoBe,EAAQnB,UAC1Cf,EAAI7G,UAAUiI,oBAAsBc,EAAQlB,YAC5ChB,EAAI7G,UAAUkI,kBAAoBa,EAAQ3B,UAG1C,IAAI4B,EAAM1E,EAAQ,GAClBuC,EAAI7G,UAAUmI,cAAgBa,EAAIpB,UAClCf,EAAI7G,UAAUoI,gBAAkBY,EAAInB,YACpChB,EAAI7G,UAAUqI,cAAgBW,EAAI5B,W;;;;;;ACnF3B,SAASQ,IAAuB,wDACnC,OAAOnH,KAAKiH,QAIT,SAASG,IACZ,OAAOpH,KAAKkH,UAIT,SAASP,IAaZ,IAZA,IAAIxB,EACAC,EAAW,GAWPzH,EAAI,EAAG+H,GARfP,EAAS,CACLnF,KAAKX,OAAOmJ,aACZxI,KAAKX,OAAOoJ,cACZzI,KAAKX,OAAOqJ,iBACZ1I,KAAKX,OAAOsJ,kBAIejD,OAAQ/H,EAAI+H,EAAQ/H,IAC5CA,EAAE,EAAI+H,EACTN,EAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAKiF,EAAOxH,GAAG2C,EAAG6E,EAAOxH,GAAG4C,EAAG4E,EAAOxH,EAAE,GAAG2C,EAAG6E,EAAOxH,EAAE,GAAG4C,IAExF6E,EAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAKiF,EAAOxH,GAAG2C,EAAG6E,EAAOxH,GAAG4C,EAAG4E,EAAO,GAAG7E,EAAG6E,EAAO,GAAG5E,IAMxF,OAHAP,KAAKiH,QAAU9B,EACfnF,KAAKkH,UAAY9B,EAEVpF,KAzCX,wI;;;;;;ACQO,SAASmH,IAAuB,wDACnC,OAAOnH,KAAKiH,QAIT,SAASG,IACZ,OAAOpH,KAAKkH,UAIT,SAASP,IACZ,IAAIxB,EAAS,GACTC,EAAW,GAGXwD,EAAS,IAAI/I,OAAOI,KAAKoF,MAC7BuD,EAAOtI,EAAIN,KAAKX,OAAOiB,EAAIN,KAAKX,OAAOwJ,aAAe7I,KAAKX,OAAOyJ,QAClEF,EAAOrI,EAAIP,KAAKX,OAAOkB,EAAIP,KAAKX,OAAO0J,cAAgB/I,KAAKX,OAAO2J,QACnE,IAAIC,EAASjJ,KAAKX,OAAO6J,KAAKC,YAC1BC,EAASpJ,KAAKX,OAAO6J,KAAKG,YAG1BC,EAAWtJ,KAAKX,OAAOiK,SAC3B,GAAgB,IAAbA,EAAgB,CACf,IAAIC,EAAU,IAAI1J,OAAOI,KAAKC,KAAKF,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAG0I,EAAO3I,EAAIN,KAAKX,OAAOmK,OAASZ,EAAOtI,EAAG2I,EAAO1I,EAAIP,KAAKX,OAAOoK,OAASb,EAAOrI,GAClJV,OAAOI,KAAKC,KAAKC,WAAWoJ,EAASvJ,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAGV,OAAOI,KAAKC,KAAKmB,MAAMkI,GAAWD,EAAUzJ,OAAOI,KAAKC,KAAKwJ,OAAOH,IACvIN,EAASM,EAAQF,YAEjB,IAAIM,EAAU,IAAI9J,OAAOI,KAAKC,KAAKF,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAG6I,EAAO9I,EAAIN,KAAKX,OAAOmK,OAASZ,EAAOtI,EAAG8I,EAAO7I,EAAIP,KAAKX,OAAOoK,OAASb,EAAOrI,GAClJV,OAAOI,KAAKC,KAAKC,WAAWwJ,EAAS3J,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAGV,OAAOI,KAAKC,KAAKmB,MAAMsI,GAAWL,EAAUzJ,OAAOI,KAAKC,KAAKwJ,OAAOC,IACvIP,EAASO,EAAQN,YAGjBlE,EAAOQ,KAAK,IAAI9F,OAAOI,KAAKoF,MAAM4D,EAAO3I,EAAG2I,EAAO1I,IACnD4E,EAAOQ,KAAK,IAAI9F,OAAOI,KAAKoF,MAAM+D,EAAO9I,EAAG8I,EAAO7I,IAEnD6E,EAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAK+I,EAAO3I,EAAG2I,EAAO1I,EAAG6I,EAAO9I,EAAG8I,EAAO7I,SAKxE4E,EAAOQ,KAAK,IAAI9F,OAAOI,KAAKoF,MAAM4D,EAAO3I,EAAIN,KAAKX,OAAOmK,OAASZ,EAAOtI,EAAG2I,EAAO1I,EAAIP,KAAKX,OAAOoK,OAASb,EAAOrI,IACnH4E,EAAOQ,KAAK,IAAI9F,OAAOI,KAAKoF,MAAM+D,EAAO9I,EAAIN,KAAKX,OAAOmK,OAASZ,EAAOtI,EAAG8I,EAAO7I,EAAIP,KAAKX,OAAOoK,OAASb,EAAOrI,IAEnH6E,EAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAK+I,EAAO3I,EAAIsI,EAAOtI,EAAG2I,EAAO1I,EAAIqI,EAAOrI,EAAG6I,EAAO9I,EAAIsI,EAAOtI,EAAG8I,EAAO7I,EAAIqI,EAAOrI,IAMxH,OAFAP,KAAKiH,QAAU9B,EACfnF,KAAKkH,UAAY9B,EACVpF,KA1DX,wI;;;;;;ACQO,SAASmH,IAAuB,wDACnC,OAAOnH,KAAKiH,QAIT,SAASG,IACZ,OAAOpH,KAAKkH,UAIT,SAASP,IACZ,IAAIxB,EAAS,GACTC,EAAW,GAGXwD,EAAS,IAAI/I,OAAOI,KAAKoF,MAC7BuD,EAAOtI,EAAIN,KAAKX,OAAOiB,EAAIN,KAAKX,OAAOwJ,aAAe7I,KAAKX,OAAOyJ,QAClEF,EAAOrI,EAAIP,KAAKX,OAAOkB,EAAIP,KAAKX,OAAO0J,cAAgB/I,KAAKX,OAAO2J,QAGnE,IAAIM,EAAWtJ,KAAKX,OAAOiK,SAC3B,GAAgB,IAAbA,EAAgB,4BACf,YAAiBtJ,KAAKX,OAAO6J,KAAK/D,OAAlC,+CAA0C,KAAlCyE,EAAkC,QAClCC,EAAS,IAAIhK,OAAOI,KAAKC,KAAKF,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAGqJ,EAAMtJ,EAAIN,KAAKX,OAAOmK,OAASZ,EAAOtI,EAAGsJ,EAAMrJ,EAAIP,KAAKX,OAAOoK,OAASb,EAAOrI,GAC/IV,OAAOI,KAAKC,KAAKC,WAAW0J,EAAQ7J,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAGV,OAAOI,KAAKC,KAAKmB,MAAMwI,GAAUP,EAAUzJ,OAAOI,KAAKC,KAAKwJ,OAAOG,IACrI1E,EAAOQ,KAAKkE,EAAOR,cAJR,uFAQd,4BACD,YAAiBrJ,KAAKX,OAAO6J,KAAK/D,OAAlC,+CAA0C,KAAlCyE,EAAkC,QACtCzE,EAAOQ,KAAK,IAAI9F,OAAOI,KAAKoF,MAAMuE,EAAMtJ,EAAIN,KAAKX,OAAOmK,OAASZ,EAAOtI,EAAGsJ,EAAMrJ,EAAIP,KAAKX,OAAOoK,OAASb,EAAOrI,KAFpH,mFAOL,IAAI,IAAI5C,EAAI,EAAG+H,EAASP,EAAOO,OAAQ/H,EAAI+H,EAAQ/H,IAC5CA,EAAE,EAAI+H,GACLN,EAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAKiF,EAAOxH,GAAG2C,EAAG6E,EAAOxH,GAAG4C,EAAG4E,EAAOxH,EAAE,GAAG2C,EAAG6E,EAAOxH,EAAE,GAAG4C,IAGhG,GAAGP,KAAKX,OAAOyK,UAAW,CACtB,IAAIC,EAAO5E,EAAOO,OAAS,EAC3BN,EAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAKiF,EAAO4E,GAAMzJ,EAAG6E,EAAO4E,GAAMxJ,EAAG4E,EAAO,GAAG7E,EAAG6E,EAAO,GAAG5E,IAM9F,OAHAP,KAAKiH,QAAU9B,EACfnF,KAAKkH,UAAY9B,EAEVpF,KAzDX,wI;;;;;;ACQO,SAASmH,IAAuB,IAAb6C,EAAa,wDACnC,GAAGhK,KAAKiH,QAAQvB,OAAS,EACrB,OAAO1F,KAAKiH,QAEhB,IAAI9B,EAAS,GACTyD,EAAS,IAAI/I,OAAOI,KAAKoF,MAK7B,GAJAuD,EAAOtI,EAAIN,KAAKX,OAAOiB,EAAIN,KAAKX,OAAOwJ,cAAgB7I,KAAKX,OAAOyJ,QAAU,IAC7EF,EAAOrI,EAAIP,KAAKX,OAAOkB,EAAIP,KAAKX,OAAO0J,eAAiB/I,KAAKX,OAAO2J,QAAU,IAG3EgB,EAAK,CACJ,IAEIhM,EAFAiM,EAAO,IAAIpK,OAAOI,KAAKC,KACvBgK,EAAO,IAAIrK,OAAOI,KAAKC,KAGvBoJ,EAAWtJ,KAAKX,OAAOiK,SAE3B,GAAgB,IAAbA,EAAgB,CACf,IAAIO,EAAS,IAAIhK,OAAOI,KAAKC,KAAKF,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAGqI,EAAOtI,EAAGsI,EAAOrI,GACjFV,OAAOI,KAAKC,KAAKC,WAAW0J,EAAQ7J,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAGV,OAAOI,KAAKC,KAAKmB,MAAMwI,GAAUP,EAAUzJ,OAAOI,KAAKC,KAAKwJ,OAAOG,IACrI,IAAIM,EAAKN,EAAOR,YAChBrL,EAAI,IAAI6B,OAAOI,KAAKC,KAAK8J,EAAI3J,OAAOC,EAAG0J,EAAI3J,OAAOE,EAAG4J,EAAG7J,EAAG6J,EAAG5J,QAG9DvC,EAAI,IAAI6B,OAAOI,KAAKC,KAAK8J,EAAI3J,OAAOC,EAAG0J,EAAI3J,OAAOE,EAAGqI,EAAOtI,EAAGsI,EAAOrI,GAG1E,IAAI6J,EAAYtK,KAAKuK,KAAKvK,KAAKwK,IAAIzK,OAAOI,KAAKC,KAAKwJ,OAAO1L,GAAI,GAAK8B,KAAKwK,IAAItK,KAAKX,OAAOkL,OAASvK,KAAKX,OAAOmK,OAAQ,IAGlHhJ,EAAQX,OAAOI,KAAKC,KAAKmB,MAAMrD,GAC/BwM,EAAS1K,KAAK2K,KAAMzK,KAAKX,OAAOkL,OAASvK,KAAKX,OAAOmK,OAAU3J,OAAOI,KAAKC,KAAKwJ,OAAO1L,IAC3F6B,OAAOI,KAAKC,KAAKC,WAAW8J,EAAMD,EAAI3J,OAAOC,EAAG0J,EAAI3J,OAAOE,EAAGC,EAAQgK,EAAQJ,GAC9EvK,OAAOI,KAAKC,KAAKC,WAAW+J,EAAMF,EAAI3J,OAAOC,EAAG0J,EAAI3J,OAAOE,EAAGC,EAAQgK,EAAQJ,GAG9EjF,EAAOQ,KAAKsE,EAAKZ,aACjBlE,EAAOQ,KAAKuE,EAAKb,aAGrB,OAAOlE,EAIJ,SAASiC,IACZ,OAAOpH,KAAKkH,UAIT,SAASP,IACZ,IAAI3G,KAAK6F,aAGL,OAFA7F,KAAKiH,QAAU,GACfjH,KAAKkH,UAAY,GACVlH,KAIX,IAAI4I,EAAS,IAAI/I,OAAOI,KAAKoF,MAC7BuD,EAAOtI,EAAIN,KAAKX,OAAOiB,EAAIN,KAAKX,OAAOwJ,aAAe7I,KAAKX,OAAOyJ,QAAU9I,KAAKX,OAAOkL,OAASvK,KAAKX,OAAOmK,OAC7GZ,EAAOrI,EAAIP,KAAKX,OAAOkB,EAAIP,KAAKX,OAAO0J,cAAgB/I,KAAKX,OAAO2J,QAAUhJ,KAAKX,OAAOkL,OAASvK,KAAKX,OAAOoK,OAG9G,IAAItE,EAASnF,KAAKX,OAAO6J,KAAK/B,UAAUnH,KAAK6F,cACzCT,EAAW,GAIXkE,EAAWtJ,KAAKX,OAAOiK,SAC3B,GAAgB,IAAbA,EAAgB,CACf,IAAIoB,EAAY,GADD,uBAEf,YAAiBvF,EAAjB,+CAAyB,KAAjByE,EAAiB,QACjBC,EAAS,IAAIhK,OAAOI,KAAKC,KAAKF,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAGP,KAAKX,OAAOiB,GAAKsJ,EAAMtJ,EAAIN,KAAKX,OAAOkL,QAAUvK,KAAKX,OAAOmK,OAAQxJ,KAAKX,OAAOkB,GAAKqJ,EAAMrJ,EAAIP,KAAKX,OAAOkL,QAAUvK,KAAKX,OAAOoK,QAClM5J,OAAOI,KAAKC,KAAKC,WAAW0J,EAAQ7J,KAAKX,OAAOiB,EAAGN,KAAKX,OAAOkB,EAAGV,OAAOI,KAAKC,KAAKmB,MAAMwI,GAAUP,EAAUzJ,OAAOI,KAAKC,KAAKwJ,OAAOG,IACrIa,EAAU/E,KAAKkE,EAAOR,cALX,kFAOflE,EAASuF,MAGR,4BACD,YAAiBvF,EAAjB,+CAAyB,KAAjByE,EAAiB,QACrBA,EAAMtJ,EAAIsJ,EAAMtJ,EAAIN,KAAKX,OAAOmK,OAASZ,EAAOtI,EAChDsJ,EAAMrJ,EAAIqJ,EAAMrJ,EAAIP,KAAKX,OAAOoK,OAASb,EAAOrI,GAHnD,mFAQL,IAAI,IAAI5C,EAAI,EAAG+H,EAASP,EAAOO,OAAQ/H,EAAI+H,EAAQ/H,IAC5CA,EAAE,EAAI+H,EACTN,EAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAKiF,EAAOxH,GAAG2C,EAAG6E,EAAOxH,GAAG4C,EAAG4E,EAAOxH,EAAE,GAAG2C,EAAG6E,EAAOxH,EAAE,GAAG4C,IAExF6E,EAASO,KAAK,IAAI9F,OAAOI,KAAKC,KAAKiF,EAAOxH,GAAG2C,EAAG6E,EAAOxH,GAAG4C,EAAG4E,EAAO,GAAG7E,EAAG6E,EAAO,GAAG5E,IAKxF,OAFAP,KAAKiH,QAAU9B,EACfnF,KAAKkH,UAAY9B,EACVpF,KAvGX,wI;;;;;;ACMO,SAAS6G,EAAInD,EAASiH,GACzB3K,KAAKK,OAAS,IAAIR,OAAOI,KAAKoF,MAC9BrF,KAAKI,KAAO,IAAIP,OAAOI,KAAKC,KAC5BF,KAAKQ,MAAQ,EACbR,KAAK0B,KAAO,EACZ1B,KAAKJ,MAAQC,OAAOC,KAAKC,iBACzBC,KAAKU,eAAiB,EACtBV,KAAKmB,qBAAuB,IAAItB,OAAOI,KAAK2K,OAC5C5K,KAAK6K,0BAA2B,EAChC7K,KAAK8K,cAAgB,GACrB9K,KAAK+K,WAAaJ,IAAwB,EAE1C3K,KAAKsH,OAAO5D,GAlBhB,2CAqBAmD,EAAItH,UAAY,CACZ+H,OAAQzD,EAAQ,IAAeyD,OAC/B0D,OAAQnH,EAAQ,IAAYmH,OAC5BC,UAAWpH,EAAQ,IAAeoH,UAClCtL,SAAUkE,EAAQ,GAAclE,SAChCyB,SAAUyC,EAAQ,GAAczC,SAChCG,YAAasC,EAAQ,GAActC,YACnCE,QAASoC,EAAQ,GAAapC,QAC9BE,WAAYkC,EAAQ,GAAalC,WACjClB,kBAAmBoD,EAAQ,GAAcpD,kBACzCI,cAAegD,EAAQ,GAAchD,cACrCqK,KAAMrH,EAAQ,IAAaqH,KAC3BC,WAAYtH,EAAQ,IAAmBsH,WACvCC,SAAUvH,EAAQ,IAAiBuH,W,6BChBhC,SAAS9D,EAAO5D,GAoCnB,OAnCA1D,KAAKX,OAASqE,EAAQrE,OAEnBqE,EAAQrD,QACPL,KAAKK,OAAOO,MAAM8C,EAAQrD,OAAOC,EAAGoD,EAAQrD,OAAOE,GAGpDmD,EAAQlD,QACPR,KAAKQ,MAAQX,OAAOC,KAAKuB,MAAMC,UAAUoC,EAAQlD,QAGlDkD,EAAQ2H,WACPrL,KAAKQ,MAAQX,OAAOC,KAAKuB,MAAMC,UAAUzB,OAAOC,KAAK0B,SAASkC,EAAQ2H,YAGvE3H,EAAQhC,OACP1B,KAAK0B,KAAOgC,EAAQhC,MAGrBgC,EAAQ4H,UACPtL,KAAK0B,KAAO7B,OAAOC,KAAK0B,SAASkC,EAAQ4H,UAG1C5H,EAAQ9D,QACPI,KAAKJ,MAAQ8D,EAAQ9D,OAGtB8D,EAAQhD,iBACPV,KAAKU,eAAiBgD,EAAQhD,qBAEM8C,IAArCE,EAAQmH,2BACP7K,KAAK6K,yBAAgE,GAApCnH,EAAQmH,0BAE7ChL,OAAOI,KAAKC,KAAKC,WAAWH,KAAKI,KAAMJ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGP,KAAKQ,MAAOR,KAAKJ,OACtFI,KAAKmB,qBAAqBP,MAAMZ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAEP,KAAKU,gBAE3DV,KAtDX,+C;;;;;;ACOO,SAASgL,EAAO1K,EAAGC,EAAGC,GAA6C,IAAtCZ,EAAsC,uDAA9BC,OAAOC,KAAKC,iBAOpD,OANAC,KAAKK,OAAOO,MAAMN,EAAGC,GACrBP,KAAKQ,MAAQX,OAAOC,KAAKuB,MAAMC,UAAUd,GACzCR,KAAKJ,MAAQA,EAEbC,OAAOI,KAAKC,KAAKC,WAAWH,KAAKI,KAAMJ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGP,KAAKQ,MAAOR,KAAKJ,OACtFI,KAAKmB,qBAAqBP,MAAMZ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAEP,KAAKU,gBAC3DV,KAdX,+C,6BCWO,SAASiL,EAAU3K,EAAGC,GAIzB,OAHAP,KAAKK,OAAOO,MAAMN,EAAGC,GACrBV,OAAOI,KAAKC,KAAKC,WAAWH,KAAKI,KAAMJ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGP,KAAKQ,MAAOR,KAAKJ,OACtFI,KAAKmB,qBAAqBP,MAAMZ,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAEP,KAAKU,gBAC3DV,KAfX,kD,6BCYO,SAASkL,IAAmB,IAC3BK,EADa7H,EAAc,uDAAJ,GAEvB8H,EAAkB3L,OAAOC,KAAKC,iBAElC,GAAGC,KAAK+K,YAAc/K,KAAK+K,WAAW9G,YAAa,CAC/C,IAAI6G,EAAgB,GAEpB,GADAjL,OAAOI,KAAKgB,WAAWwK,mBAAmBzL,KAAKI,KAAMJ,KAAK+K,WAAW9G,YAAYgB,UAAW6F,GAChE,IAAzBA,EAAcpF,OACb6F,EAAsBT,EAAc,QACnC,GAAGA,EAAcpF,OAAS,EAAG,4BAC9B,YAAwBoF,EAAxB,+CAAuC,KAA/BY,EAA+B,QAC/BC,EAAW9L,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGmL,EAAapL,EAAGoL,EAAanL,GACpGoL,EAAWH,IACVA,EAAkBG,EAClBJ,EAAsBG,IALA,wFAU9BF,EAAkB3L,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGmD,EAAQoI,OAAOxL,EAAGoD,EAAQoI,OAAOvL,GAC9GgL,EAAsB7H,EAAQoI,OAKtC,IAAIpI,EAAQmB,QAAS,CACjB,IAAG7E,KAAK+K,WAGJ,OAAOD,cAFPpH,EAAQmB,QAAU7E,KAAK+K,WAAW7G,cA3BX,2BAgC/B,YAAkBR,EAAQmB,QAA1B,+CAAmC,KAA3BxF,EAA2B,QAE/B,GAAIQ,OAAOI,KAAKgB,WAAWwK,mBAAmBzL,KAAKI,KAAMf,EAAO2B,aAAhE,CAGA,IAAImF,EAAM9G,EAAO4G,KAAKzH,IAAI,gBALK,uBAQ/B,YAAmB2H,EAAIiB,cAAvB,+CAAsC,KAA9B2E,EAA8B,QAC9BL,EAAe,GAEnB,GAAGhI,EAAQoI,QACP,GACIjM,OAAOI,KAAKoF,MAAM2G,OAAOtI,EAAQoI,OAAQC,EAAQ5C,cAC9CtJ,OAAOI,KAAKoF,MAAM2G,OAAOtI,EAAQoI,OAAQC,EAAQ1C,aAEpDqC,EAAehI,EAAQoI,YAEtB,IAAIjM,OAAOI,KAAKgB,WAAWgL,WAAWjM,KAAKI,KAAM2L,EAASL,GAC3D,cAGH,IAAI7L,OAAOI,KAAKgB,WAAWgL,WAAWjM,KAAKI,KAAM2L,EAASL,GAC7D,SAGF,IAAIC,EAAW9L,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGmL,EAAapL,EAAGoL,EAAanL,GACpGoL,EAAWH,IACVA,EAAkBG,EAClBJ,EAAsBG,IA7BC,kFAkC/B,GAAgB,QAAbvF,EAAIW,KAAgB,CAEnB,GAAGX,EAAIc,QAAQvB,OAAS,EACpB,SAIJ,GAAGhC,EAAQoI,OAAQ,CACf,IAAI3G,EAASgB,EAAIgB,UAAUnH,MACvBkM,GAAY,EAFD,uBAGf,YAAiB/G,EAAjB,+CAAyB,KAAjByE,EAAiB,QAErB,GAAG/J,OAAOI,KAAKoF,MAAM2G,OAAOtI,EAAQoI,OAAQlC,GAAQ,CAEhD,IAAI+B,EAAW9L,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGqJ,EAAMtJ,EAAGsJ,EAAMrJ,GAEzF,GAAGoL,EAAWH,EAAiB,CAC3BA,EAAkBG,EAClBJ,EAAsB3B,EACtBsC,GAAY,EACZ,SAbG,kFAkBf,GAAGA,EACC,SAGR,IAAIC,EAAsB,GACtBvD,EAAS,IAAI/I,OAAOI,KAAKoF,MAC7BuD,EAAOtI,EAAI6F,EAAI9G,OAAOiB,EAAI6F,EAAI9G,OAAOwJ,cAAgB1C,EAAI9G,OAAOyJ,QAAU,IAC1EF,EAAOrI,EAAI4F,EAAI9G,OAAOkB,EAAI4F,EAAI9G,OAAO0J,eAAiB5C,EAAI9G,OAAO2J,QAAU,IAG3E,IAAIM,EAAWnD,EAAI9G,OAAOiK,SAC1B,GAAgB,IAAbA,EAAgB,CACf,IAAIO,EAAS,IAAIhK,OAAOI,KAAKC,KAAKiG,EAAI9G,OAAOiB,EAAG6F,EAAI9G,OAAOkB,EAAGqI,EAAOtI,EAAGsI,EAAOrI,GAC/EV,OAAOI,KAAKC,KAAKC,WAAW0J,EAAQ1D,EAAI9G,OAAOiB,EAAG6F,EAAI9G,OAAOkB,EAAGV,OAAOI,KAAKC,KAAKmB,MAAMwI,GAAUP,EAAUzJ,OAAOI,KAAKC,KAAKwJ,OAAOG,IACnI,IAAIM,EAAKN,EAAOR,YAChBT,EAAOtI,EAAI6J,EAAG7J,EACdsI,EAAOrI,EAAI4J,EAAG5J,EAIlB,IAAI6L,EAAS,IAAIvM,OAAOI,KAAK2K,OAAOhC,EAAOtI,EAAGsI,EAAOrI,EAAG4F,EAAI9G,OAAOkL,OAASpE,EAAI9G,OAAOmK,QAEvF,GAAG3J,OAAOI,KAAKgB,WAAWoL,gBAAgBrM,KAAKI,KAAMgM,EAAQD,GAAsB,4BAC/E,YAAwBA,EAAxB,+CAA6C,KAArCT,EAAqC,QAErCC,EAAW9L,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKI,KAAKkM,GAAItM,KAAKI,KAAKmM,GAAIb,EAAapL,EAAGoL,EAAanL,GAElGoL,EAAWH,IAEVA,EAAkBG,EAClBJ,EAAsBG,IARiD,uFAjH5D,kFAgI/B,OAAIH,EAEG,IAAI1L,OAAOI,KAAKoF,MAAMkG,EAAoBjL,EAAGiL,EAAoBhL,IAD5DP,KAAK6K,0BAAoC7K,KAAKI,KAAKiJ,YA7InE,6C,6BCWO,SAAS8B,IAAyB,IAAdzH,EAAc,uDAAJ,GAC7B8I,EAAgBxM,KAAKQ,MACrBsK,EAAgB,GAChB2B,EAAO,GACPC,EAAa,GACbC,EAAgB,GAGpB,IAAIjJ,EAAQmB,QAAS,CACjB,IAAG7E,KAAK+K,WAGJ,OAAOD,EAGX,GALIpH,EAAQmB,QAAU7E,KAAK+K,WAAW7G,cAKnClE,KAAK+K,YAAc/K,KAAK+K,WAAW9G,YAAa,4BAC/C,YAAiBjE,KAAK+K,WAAW9G,YAAYkB,OAA7C,+CAAqD,KAA7CyE,EAA6C,QACjD8C,EAAW/G,KAAK,CACZiE,MAAOA,EACPpJ,MAAOX,OAAOC,KAAKuB,MAAMwK,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGqJ,EAAMtJ,EAAGsJ,EAAMrJ,MAJvC,mFASnD,IAAI,IAAI5C,EAAE,EAAGiP,EAAUlJ,EAAQmB,QAAQa,OAAQ/H,EAAIiP,EAASjP,IAAK,CAC7D,IAAI0B,EAASqE,EAAQmB,QAAQlH,GAE7B,GAAIqC,KAAKa,cAAcxB,GAAvB,CAGAsN,EAAchH,KAAKtG,GAEnB,IAAI8G,EAAM9G,EAAO4G,KAAKzH,IAAI,gBAC1BiO,EAAK9G,KAAKQ,GATmD,2BAW7D,YAAiBA,EAAIgB,UAAUnH,MAA/B,+CAAsC,KAA9B4J,EAA8B,QAClC8C,EAAW/G,KAAK,CACZiE,MAAOA,EACPpJ,MAAOX,OAAOC,KAAKuB,MAAMwK,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGqJ,EAAMtJ,EAAGsJ,EAAMrJ,MAdzB,kFAmB7D,IAAI,IAAIsM,EAAIlP,EAAE,EAAGmP,EAAUpJ,EAAQmB,QAAQa,OAAQmH,EAAIC,EAASD,IAAI,CAChE,IAAIE,EAAUrJ,EAAQmB,QAAQgI,GAC1BG,EAAOD,EAAQ9G,KAAKzH,IAAI,gBAE5B,GAAIqB,OAAOI,KAAKgB,WAAWgM,qBAAqB5N,EAAO2B,YAAa+L,EAAQ/L,aAA5E,CAJgE,2BAQhE,YAAoBmF,EAAIiB,cAAxB,+CAAuC,KAA/B8F,EAA+B,+BACnC,YAAoBF,EAAK5F,cAAzB,+CAAwC,KAAhC+F,EAAgC,QAChCzB,EAAe,GACf7L,OAAOI,KAAKgB,WAAWgL,WAAWiB,EAAUC,EAAUzB,IAG1DgB,EAAW/G,KAAK,CACZiE,MAAO,IAAI/J,OAAOI,KAAKoF,MAAMqG,EAAapL,EAAGoL,EAAanL,GAC1DC,MAAOX,OAAOC,KAAKuB,MAAMwK,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGmL,EAAapL,EAAGoL,EAAanL,MARjE,oFARyB,sFAwBxEmM,EAAWU,KAAK,SAASC,EAAGC,GAExB,OAAGD,EAAE7M,OAAS8M,EAAE9M,MACTX,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAG8M,EAAEzD,MAAMtJ,EAAG+M,EAAEzD,MAAMrJ,GAAKV,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAG+M,EAAE1D,MAAMtJ,EAAGgN,EAAE1D,MAAMrJ,GACzJ,GAEC,EAGT8M,EAAE7M,MAAQ8M,EAAE9M,OACrBrB,KAAKa,OArEU,2BAwEjB,YAAkB0M,EAAlB,+CAA6B,KAArBZ,EAAqB,QACzB9L,KAAKoB,SAAS0K,EAAOtL,OACrB,IAAIkL,EAAe1L,KAAKkL,KAAK,CACzBrG,QAAS8H,EACTb,OAAQA,EAAOlC,QAEnB,GAAG8B,EAAa,CAEZ,GAAG7L,OAAOI,KAAKoF,MAAM2G,OAAOF,EAAOlC,MAAO8B,GAAe,CACrD1L,KAAKoB,SAAS0K,EAAOtL,MAAQ,MAC7B,IAAI+M,EAAgBvN,KAAKkL,KAAK,CAC1BrG,QAAS8H,IAEVY,GACCzC,EAAcnF,KAAK4H,GAEvBzC,EAAcnF,KAAK+F,GAEnB1L,KAAKoB,SAAS0K,EAAOtL,MAAQ,MAC7B,IAAIgN,EAAgBxN,KAAKkL,KAAK,CAC1BrG,QAAS8H,IAEVa,GACC1C,EAAcnF,KAAK6H,GAEvB,SAEJ1C,EAAcnF,KAAK+F,KAnGV,mFAyGrB,OADA1L,KAAKoB,SAASoL,GACP1B,EA5HX,mD,6BCWO,SAASM,IAAuB,IAAd1H,EAAc,uDAAJ,GAC3B8I,EAAgBxM,KAAKQ,MACrBsK,EAAgB,GAChB2B,EAAO,GACPC,EAAa,GACbC,EAAgB,GAChBjL,EAAO1B,KAAK0B,KACZ+L,EAAW,EACXC,EAAW,EA6Bf,QAzBoBlK,IAAjBE,EAAQhC,OACPA,EAAOgC,EAAQhC,WACI8B,IAApBE,EAAQ4H,UACP5J,EAAO7B,OAAOC,KAAK0B,SAASkC,EAAQ4H,UAGxCmC,EAAWzN,KAAKQ,MAAQkB,EAAO,EAC/BgM,EAAW1N,KAAKQ,MAAQkB,EAAO,EAG/B1B,KAAKoB,SAASqM,GACdf,EAAW/G,KAAK,CACZiE,MAAO5J,KAAKI,KAAKiJ,YACjB7I,MAAOiN,EACPE,eAAgB9N,OAAOC,KAAK8N,UAAUlM,EAAO,KAGjD1B,KAAKoB,SAASsM,GACdhB,EAAW/G,KAAK,CACZiE,MAAO5J,KAAKI,KAAKiJ,YACjB7I,MAAOkN,EACPC,eAAgB9N,OAAOC,KAAK8N,SAASlM,EAAO,MAI5CgC,EAAQmB,QAAS,CACjB,IAAG7E,KAAK+K,WAGJ,OAAOD,EAGX,GALIpH,EAAQmB,QAAU7E,KAAK+K,WAAW7G,cAKnClE,KAAK+K,YAAc/K,KAAK+K,WAAW9G,YAAa,4BAC/C,YAAiBjE,KAAK+K,WAAW9G,YAAYkB,OAA7C,+CAAqD,KAA7CyE,EAA6C,QAE7CpJ,EAAQX,OAAOC,KAAKuB,MAAMwK,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGqJ,EAAMtJ,EAAGsJ,EAAMrJ,GAC/EoN,EAAiB9N,OAAOC,KAAKuB,MAAMwM,gBAAgBhO,OAAOC,KAAK8N,SAASpN,GAAQX,OAAOC,KAAK8N,SAASpB,IAEtG1M,KAAKgO,IAAIH,GAAkB9N,OAAOC,KAAK8N,SAASlM,EAAO,IACtDgL,EAAW/G,KAAK,CACZiE,MAAOA,EACPpJ,MAAOA,EACPmN,gBAAiBA,KAVkB,oFAiBvD,IAAI,IAAIhQ,EAAE,EAAGiP,EAAUlJ,EAAQmB,QAAQa,OAAQ/H,EAAIiP,EAASjP,IAAK,CAC7D,IAAI0B,EAASqE,EAAQmB,QAAQlH,GAE7B,GAAIqC,KAAKa,cAAcxB,GAAvB,CAGAsN,EAAchH,KAAKtG,GAEnB,IAAI8G,EAAM9G,EAAO4G,KAAKzH,IAAI,gBAC1BiO,EAAK9G,KAAKQ,GATmD,2BAW7D,YAAiBA,EAAIgB,UAAUnH,MAA/B,+CAAsC,KAA9B4J,EAA8B,QAE9BpJ,EAAQX,OAAOC,KAAKuB,MAAMwK,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGqJ,EAAMtJ,EAAGsJ,EAAMrJ,GAC/EoN,EAAiB9N,OAAOC,KAAKuB,MAAMwM,gBAAgBhO,OAAOC,KAAK8N,SAASpN,GAAQX,OAAOC,KAAK8N,SAASpB,IAEtG1M,KAAKgO,IAAIH,GAAkB9N,OAAOC,KAAK8N,SAASlM,EAAO,IACtDgL,EAAW/G,KAAK,CACZiE,MAAOA,EACPpJ,MAAOX,OAAOC,KAAKuB,MAAMwK,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGqJ,EAAMtJ,EAAGsJ,EAAMrJ,GAC9EoN,gBAAiBA,KApBgC,kFA0B7D,IAAI,IAAId,EAAIlP,EAAE,EAAGmP,EAAUpJ,EAAQmB,QAAQa,OAAQmH,EAAIC,EAASD,IAAI,CAChE,IAAIE,EAAUrJ,EAAQmB,QAAQgI,GAC1BG,EAAOD,EAAQ9G,KAAKzH,IAAI,gBAE5B,GAAIqB,OAAOI,KAAKgB,WAAWgM,qBAAqB5N,EAAO2B,YAAa+L,EAAQ/L,aAA5E,CAJgE,2BAQhE,YAAoBmF,EAAIiB,cAAxB,+CAAuC,KAA/B8F,EAA+B,+BACnC,YAAoBF,EAAK5F,cAAzB,+CAAwC,KAAhC+F,EAAgC,QAChCzB,EAAe,GACnB,GAAI7L,OAAOI,KAAKgB,WAAWgL,WAAWiB,EAAUC,EAAUzB,GAA1D,CAEA,IAAIlL,EAAQX,OAAOC,KAAKuB,MAAMwK,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGmL,EAAapL,EAAGoL,EAAanL,GAC7FoN,EAAiB9N,OAAOC,KAAKuB,MAAMwM,gBAAgBhO,OAAOC,KAAK8N,SAASpN,GAAQX,OAAOC,KAAK8N,SAASpB,IAEtG1M,KAAKgO,IAAIH,GAAkB9N,OAAOC,KAAK8N,SAASlM,EAAO,IACtDgL,EAAW/G,KAAK,CACZiE,MAAO,IAAI/J,OAAOI,KAAKoF,MAAMqG,EAAapL,EAAGoL,EAAanL,GAC1DC,MAAOX,OAAOC,KAAKuB,MAAMwK,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAGmL,EAAapL,EAAGoL,EAAanL,GAC5FoN,gBAAiBA,MAZM,oFARyB,sFA6BxEjB,EAAWU,KAAK,SAASC,EAAGC,GAExB,OAAGD,EAAE7M,OAAS8M,EAAE9M,MACTX,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAG8M,EAAEzD,MAAMtJ,EAAG+M,EAAEzD,MAAMrJ,GAAKV,OAAOC,KAAK8L,SAASC,QAAQ7L,KAAKK,OAAOC,EAAGN,KAAKK,OAAOE,EAAG+M,EAAE1D,MAAMtJ,EAAGgN,EAAE1D,MAAMrJ,GACzJ,GAEC,EAGT8M,EAAEM,eAAiBL,EAAEK,gBAC9BxO,KAAKa,OAGP,cAAkB0M,EAAlB,eAA6B,CAAzB,IAAIZ,EAAM,KACV9L,KAAKoB,SAAS0K,EAAOtL,OACrB,IAAIkL,EAAe1L,KAAKkL,KAAK,CACzBrG,QAAS8H,EACTb,OAAQA,EAAOlC,QAEnB,GAAG8B,EAAa,CAEZ,GAAG7L,OAAOI,KAAKoF,MAAM2G,OAAOF,EAAOlC,MAAO8B,GAAe,CACrD1L,KAAKoB,SAAS0K,EAAOtL,MAAQ,MAC7B,IAAI+M,EAAgBvN,KAAKkL,KAAK,CAC1BrG,QAAS8H,IAEVY,GACCzC,EAAcnF,KAAK4H,GAEvBzC,EAAcnF,KAAK+F,GAEnB1L,KAAKoB,SAAS0K,EAAOtL,MAAQ,MAC7B,IAAIgN,EAAgBxN,KAAKkL,KAAK,CAC1BrG,QAAS8H,IAEVa,GACC1C,EAAcnF,KAAK6H,GAEvB,SAEJ1C,EAAcnF,KAAK+F,IAK3B,OADA1L,KAAKoB,SAASoL,GACP1B,EA5KX","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/**\n * Set ray's range.\n *\n * @function Ray.setRange\n * @since 0.6.0\n *\n * @param {integer} [range] = Phaser.Math.MAX_SAFE_INTEGER - Ray's range.\n *\n * @return {object} Ray object.\n */\nexport function setRange(range = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.range = range;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n\n/**\n * Set ray's range.\n *\n * @function Ray.setRange\n * @since 0.6.0\n *\n * @param {integer} [detectionRange] = Phaser.Math.MAX_SAFE_INTEGER - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {object} Ray object.\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.rangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @function Ray.boundsInRange\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {Phaser.Geom. Rectangle} / {boolean} [bounds] = false - Tested object's bounds. If not passed bounds will be generated.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else\n        objectBounds = object.getBounds();\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * Set ray angle in radians.\n *\n * @function Ray.setAngle\n * @since 0.6.0\n *\n * @param {float} [angle] - Ray's angle in radians.\n *\n * @return {object} Ray object.\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n\n/**\n * Set ray angle in degrees.\n *\n * @function Ray.setAngleDeg\n * @since 0.6.1\n *\n * @param {float} [angle] - Ray's angle in degrees.\n *\n * @return {object} Ray object.\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n","/**\n * Set ray's cone angle in radians.\n *\n * @function Ray.setAngle\n * @since 0.7.0\n *\n * @param {float} [cone] - Ray's cone angle in radians.\n *\n * @return {object} Ray object.\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle in degrees.\n *\n * @function Ray.setAngleDeg\n * @since 0.7.0\n *\n * @param {float} [cone] - Ray's cone angle in degrees.\n *\n * @return {object} Ray object.\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar PhaserRaycaster = function (scene)\r\n{\r\n    //The Scene that owns this plugin\r\n    this.scene = scene;\r\n\r\n    this.systems = scene.sys;\r\n\r\n    if (!scene.sys.settings.isBooted)\r\n    {\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    }\r\n};\r\n\r\n//Static function called by the PluginFile Loader.\r\nPhaserRaycaster.register = function (PluginManager)\r\n{\r\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\r\n\r\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\r\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\r\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\r\n    //  it has an entry in the InjectionMap.\r\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\r\n};\r\n\r\nPhaserRaycaster.prototype = {\r\n\r\n    //  Called when the Plugin is booted by the PluginManager.\r\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\r\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\r\n\r\n        eventEmitter.on('start', this.start, this);\r\n\r\n        eventEmitter.on('preupdate', this.preUpdate, this);\r\n        eventEmitter.on('update', this.update, this);\r\n        eventEmitter.on('postupdate', this.postUpdate, this);\r\n\r\n        eventEmitter.on('pause', this.pause, this);\r\n        eventEmitter.on('resume', this.resume, this);\r\n\r\n        eventEmitter.on('sleep', this.sleep, this);\r\n        eventEmitter.on('wake', this.wake, this);\r\n\r\n        eventEmitter.on('shutdown', this.shutdown, this);\r\n        eventEmitter.on('destroy', this.destroy, this);\r\n    },\r\n\r\n    //A test method.\r\n    test: function (name)\r\n    {\r\n        console.log('RaycasterPlugin says hello ' + name + '!');\r\n    },\r\n\r\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\r\n    start: function ()\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 1\r\n    preUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 2\r\n    update: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 3\r\n    postUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\r\n    pause: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is resumed from a paused state.\r\n    resume: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\r\n    sleep: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is woken from a sleeping state.\r\n    wake: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\r\n    shutdown: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n    },\r\n\r\n    //Create Raycaster object\r\n    createRaycaster: function(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n\r\n};\r\n\r\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\r\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\r\n\r\n//Make sure you export the plugin for webpack to expose\r\n\r\nmodule.exports = PhaserRaycaster;\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nexport function Raycaster(options) {\r\n    this.version = '0.7.0';\r\n    this.scene;\r\n    this.graphics;\r\n    this.boundingBox = false;\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    this.mapSegmentCount = 0;   //quantity of segments of map of circle\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined && options.scene.physics !== undefined)\r\n            options.boundingBox = options.scene.physics.world.bounds;\r\n\r\n        this.setOptions(options);\r\n    }\r\n\r\n    //update event\r\n    this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    //set options\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    //set bounding box\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    //map object\r\n    mapGameObjects: function(objects, dynamic = false, segmentCount = this.mapSegmentCount) {\r\n        if(!Array.isArray(objects)) {\r\n            if(this.mappedObjects.includes(objects))\r\n                return this;\r\n\r\n            if(!objects.data)\r\n                objects.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: objects,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            }, this.scene);\r\n\r\n            objects.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(objects);\r\n\r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            if(!object.data)\r\n                object.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: object,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            });\r\n\r\n            object.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    //remove mapped Objects\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            let index = this.mappedObjects.indexOf(objects);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n            return this;\r\n        }\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    //scene update event listener\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                if(mapppedObject.data === undefined)\r\n                    continue;\r\n\r\n                let map = mapppedObject.data.get('raycasterMap')\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    //ray factory\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nexport function Map(options, scene) {\r\n    this.type;\r\n    this.active;\r\n    this.dynamic;\r\n    this._object;\r\n    this._points = [];\r\n    this._segments = [];\r\n    this.getPoints;\r\n    this.getSegments;\r\n    this.getIntersections;\r\n    this.segmentCount = 0;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\n//config\r\nMap.prototype = {\r\n    config: function(options) {\r\n        this.object = options.object;\r\n        //object type\r\n        if(options.type === undefined)\r\n            options.type = options.object.type;\r\n        this.type = options.type;\r\n\r\n        switch(options.type) {\r\n            case 'Polygon':\r\n                this.getPoints = this._getPolygonPoints;\r\n                this.getSegments = this._getPolygonSegments;\r\n                this.updateMap = this._updatePolygonMap;\r\n                break;\r\n            case 'Arc':\r\n                this.getPoints = this._getArcPoints;\r\n                this.getSegments = this._getArcSegments;\r\n                this.updateMap = this._updateArcMap;\r\n                break;\r\n            case 'Line':\r\n                this.getPoints = this._getLinePoints;\r\n                this.getSegments = this._getLineSegments;\r\n                this.updateMap = this._updateLineMap;\r\n                break;\r\n            default:\r\n                this.getPoints = this._getRectanglePoints;\r\n                this.getSegments = this._getRectangleSegments;\r\n                this.updateMap = this._updateRectangleMap;\r\n        }\r\n\r\n        //dynamic map\r\n        this.dynamic = (options.dynamic == true) ? true : false;\r\n        this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    //set segments count for circle map\r\n    setSegmentCount: function(count) {\r\n        this.segmentCount = count;\r\n        this.updateMap();\r\n        return this;\r\n    }\r\n};\r\n//add methods for rectangle maps\r\nlet rectangle = require('./map-rectangle-methods.js');\r\nMap.prototype._getRectanglePoints = rectangle.getPoints;\r\nMap.prototype._getRectangleSegments = rectangle.getSegments;\r\nMap.prototype._updateRectangleMap = rectangle.updateMap;\r\n\r\n//add methods for line maps\r\nlet line = require('./map-line-methods.js');\r\nMap.prototype._getLinePoints = line.getPoints;\r\nMap.prototype._getLineSegments = line.getSegments;\r\nMap.prototype._updateLineMap = line.updateMap;\r\n\r\n//add methods for polygon maps\r\nlet polygon = require('./map-polygon-methods.js');\r\nMap.prototype._getPolygonPoints = polygon.getPoints;\r\nMap.prototype._getPolygonSegments = polygon.getSegments;\r\nMap.prototype._updatePolygonMap = polygon.updateMap;\r\n\r\n//add methods for circle maps\r\nlet arc = require('./map-circle-methods.js');\r\nMap.prototype._getArcPoints = arc.getPoints;\r\nMap.prototype._getArcSegments = arc.getSegments;\r\nMap.prototype._updateArcMap = arc.updateMap;\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/*Map methods for rectangles*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/*Map methods for lines*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x + offset.x, pointA.y + offset.y, pointB.x + offset.x, pointB.y + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/*Map methods for polygons*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/*Map methods for circles*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nexport function Ray(options, raycaster) {\r\n    this.origin = new Phaser.Geom.Point();\r\n    this._ray = new Phaser.Geom.Line();\r\n    this.angle = 0;\r\n    this.cone = 0;\r\n    this.range = Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.detectionRange = 0;\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    this.ignoreNotIntersectedRays = true;\r\n    this.intersections = [];\r\n    this._raycaster = raycaster ? raycaster : false;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRange: require('./range.js').setRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone\r\n};\r\n","/**\n * Configure ray on creation.\n *\n * @function Ray.config\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * - {Phaser.Types.Math.Vector2Like} [origin] = {x:0, y:0} - Ray's position.\n * - {float} [angle] = 0 - Ray's angle in radians.\n * - {float} [angleDeg] = 0 - Ray's angle in degrees.\n * - {float} [cone] = 0 - Ray's cone angle in radians.\n * - {float} [coneDeg] = 0 - Ray's cone angle in degrees.\n * - {integer} [range] = Phaser.Math.MAX_SAFE_INTEGER - Ray's range.\n * - {integer} [detectionRange] = Phaser.Math.MAX_SAFE_INTEGER - Maximum distance between ray's position and tested objects bounding boxes.\n * - {boolean} [ignoreNotIntersectedRays] = true - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target.\n *\n * @return {object} Ray object.\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //range (0 = max)\n    if(options.range)\n        this.range = options.range;\n\n    //detection range (0 = max)\n    if(options.detectionRange)\n        this.detectionRange = options.detectionRange;\n\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n","/**\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\n* @copyright    2020 Marcin Walczak\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\n*/\n\n//set ray\nexport function setRay(x, y, angle, range = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.range = range;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n","/**\n * Set ray's position.\n *\n * @function Ray.setOrigin\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {object} Ray object.\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @function Ray.cast\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n * - {Phaser.Types.Math.Vector2Like} [target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n *\n * @return {Phaser.Types.Math.Vector2Like} / {boolean} - Point object of ray's closest intersection with tested objects. Returns false if no intersection has been found.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestDistance = Phaser.Math.MAX_SAFE_INTEGER;\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        else {\n            closestDistance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            closestIntersection = options.target;\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        //check if object is intersected by ray\n        if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\n            continue;\n\n        let map = object.data.get('raycasterMap');\n        \n        //check intersections\n        for(let segment of map.getSegments()) {\n            let intersection = [];\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n            }\n        }\n\n        //check arc intersections if its not\n        if(map.type === 'Arc') {\n           //if arc has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                    }\n                }\n            }\n        }\n    }\n\n    if(!closestIntersection)\n        return (this.ignoreNotIntersectedRays) ? false : this._ray.getPointB();\n    return new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n}\n","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @function Ray.castCircle\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n *\n * @return {array} - Array of Point objects of ray's closest intersections with tested objects.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n        }\n\n        for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n            let object = options.objects[i];\n            //if bound in range\n            if(!this.boundsInRange(object))\n                continue;\n            \n            testedObjects.push(object);\n\n            let map = object.data.get('raycasterMap');\n            maps.push(map);\n            //get points and angles\n            for(let point of map.getPoints(this)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n\n            //get objects intersections\n            for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n                let objectB = options.objects[j];\n                let mapB = objectB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\n                    continue;\n                \n                //find objects intersections\n                for(let segmentA of map.getSegments()) {\n                    for(let segmentB of mapB.getSegments()) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                        });\n                    }\n                }\n            }\n        }\n\n        //sort target points by angle\n        rayTargets.sort(function(a, b){\n            //if rays towards points have the same angles promote closer one\n            if(a.angle == b.angle) {\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                    return 1;\n                else\n                    return -1;\n            }\n\n            return a.angle - b.angle;\n        }.bind(this));\n\n        //cast rays\n        for(let target of rayTargets){\n            this.setAngle(target.angle);\n            let intersection = this.cast({\n                objects: testedObjects,\n                target: target.point\n            });\n            if(intersection){\n                //if intersection hits target point cast two additional rays\n                if(Phaser.Geom.Point.Equals(target.point, intersection)) {\n                    this.setAngle(target.angle - 0.0001);\n                    let intersectionA = this.cast({\n                        objects: testedObjects\n                    });\n                    if(intersectionA)\n                        intersections.push(intersectionA);\n                    \n                    intersections.push(intersection);\n\n                    this.setAngle(target.angle + 0.0001);\n                    let intersectionB = this.cast({\n                        objects: testedObjects\n                    });\n                    if(intersectionB)\n                        intersections.push(intersectionB);\n\n                    continue;\n                }\n                intersections.push(intersection);\n            }\n        }\n    }\n\n    this.setAngle(originalAngle);\n    return intersections;\n}\n","/**\n * Cast ray in cone to find closest intersections with tested mapped objects.\n *\n * @function Ray.castCone\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n *\n * @return {array} - Array of Point objects of ray's closest intersections with tested objects.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n\n                let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n                let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                    rayTargets.push({\n                        point: point,\n                        angle: angle,\n                        angleOffsetDeg: -angleOffsetDeg\n                    });\n                }\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map = object.data.get('raycasterMap');\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments()) {\n                for(let segmentB of mapB.getSegments()) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    //cast rays\n    for(let target of rayTargets){\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            if(Phaser.Geom.Point.Equals(target.point, intersection)) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects\n                });\n                if(intersectionA)\n                    intersections.push(intersectionA);\n                \n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects\n                });\n                if(intersectionB)\n                    intersections.push(intersectionB);\n\n                continue;\n            }\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    return intersections;\n}\n"],"sourceRoot":""}