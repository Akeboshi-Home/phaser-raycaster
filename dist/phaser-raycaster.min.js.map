{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/ray/ray-core.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","PhaserRaycaster","scene","this","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","graphics","boundingBox","mappedObjects","sortedPoints","mapSegmentCount","setOptions","add","lineStyle","width","color","fillStyle","objects","mapGameObjects","setBoundingBox","x","y","height","rectangle","Phaser","Geom","Rectangle","points","segments","Point","left","top","right","bottom","length","push","Line","dynamic","segmentCount","Array","isArray","includes","data","setDataEnabled","map","Map","set","removeMappedObjects","index","indexOf","splice","updateMap","createRay","Ray","type","active","_object","_points","_segments","getPoints","getSegments","getIntersections","config","_getPolygonPoints","_getPolygonSegments","_updatePolygonMap","_getArcPoints","_getArcSegments","_updateArcMap","_getLinePoints","_getLineSegments","_updateLineMap","_getRectanglePoints","_getRectangleSegments","_updateRectangleMap","setSegmentCount","count","line","polygon","arc","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","pointA","geom","getPointA","pointB","getPointB","rotation","vectorA","scaleX","scaleY","SetToAngle","Angle","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","origin","rayLength","Math","sqrt","pow","radius","angle","dAngle","asin","newPoints","raycaster","_ray","range","MAX_SAFE_INTEGER","detectionRange","detectionRangeCircle","Circle","ignoreNotIntersectedRays","intersections","_raycaster","setTo","setRay","setOrigin","setRange","setAngle","setDetectionRange","rangeCircle","boundsInRange","objectBounds","bounds","getBounds","Intersects","CircleToRectangle","cast","closestIntersection","closestDistance","GetLineToRectangle","intersection","distance","Distance","Between","target","segment","Equals","LineToLine","isTangent","circleIntersections","circle","GetLineToCircle","x1","y1","castAll","maps","rayTargets","testedObjects","iLength","j","jLength","objectB","mapB","RectangleToRectangle","segmentA","segmentB","sort","a","b","intersectionA","intersectionB"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2018 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n*/\n\nvar PhaserRaycaster = function (scene)\n{\n    //  The Scene that owns this plugin\n    this.scene = scene;\n\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted)\n    {\n        scene.sys.events.once('boot', this.boot, this);\n    }\n};\n\n//  Static function called by the PluginFile Loader.\nPhaserRaycaster.register = function (PluginManager)\n{\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\n    //  it has an entry in the InjectionMap.\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\n};\n\nPhaserRaycaster.prototype = {\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot: function ()\n    {\n        var eventEmitter = this.systems.events;\n\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n        eventEmitter.on('start', this.start, this);\n\n        eventEmitter.on('preupdate', this.preUpdate, this);\n        eventEmitter.on('update', this.update, this);\n        eventEmitter.on('postupdate', this.postUpdate, this);\n\n        eventEmitter.on('pause', this.pause, this);\n        eventEmitter.on('resume', this.resume, this);\n\n        eventEmitter.on('sleep', this.sleep, this);\n        eventEmitter.on('wake', this.wake, this);\n\n        eventEmitter.on('shutdown', this.shutdown, this);\n        eventEmitter.on('destroy', this.destroy, this);\n    },\n\n    //  A test method.\n    test: function (name)\n    {\n        console.log('BasePlugin says hello ' + name + '!');\n    },\n\n    //  Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start: function ()\n    {\n    },\n\n    //  Called every Scene step - phase 1\n    preUpdate: function (time, delta)\n    {\n    },\n\n    //  Called every Scene step - phase 2\n    update: function (time, delta)\n    {\n    },\n\n    //  Called every Scene step - phase 3\n    postUpdate: function (time, delta)\n    {\n    },\n\n    //  Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause: function ()\n    {\n    },\n\n    //  Called when a Scene is resumed from a paused state.\n    resume: function ()\n    {\n    },\n\n    //  Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep: function ()\n    {\n    },\n\n    //  Called when a Scene is woken from a sleeping state.\n    wake: function ()\n    {\n    },\n\n    //  Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown: function ()\n    {\n    },\n\n    //  Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.scene = undefined;\n    },\n\n    // Create Raycaster object\n    createRaycaster: function(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n\n};\n\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\n\n//  Make sure you export the plugin for webpack to expose\n\nmodule.exports = PhaserRaycaster;\n","export function Raycaster(options) {\r\n    this.scene;\r\n    this.graphics;\r\n    this.boundingBox = false;\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    this.mapSegmentCount = 0;   //quantity of segments of map of circle\r\n\r\n    if(options !== undefined)\r\n        this.setOptions(options);\r\n\r\n    //update event\r\n        this.scene.events.on('update', function() {\r\n            this.update();\r\n        }.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    //set options\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    //set bounding box\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    //map object\r\n    mapGameObjects: function(objects, dynamic = false, segmentCount = this.mapSegmentCount) {\r\n        if(!Array.isArray(objects)) {\r\n            if(this.mappedObjects.includes(objects))\r\n                return this;\r\n\r\n            if(!objects.data)\r\n                objects.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: objects,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            }, this.scene);\r\n\r\n            objects.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(objects);\r\n\r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            if(!object.data)\r\n                object.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: object,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            });\r\n\r\n            object.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    //remove mapped Objects\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            let index = this.mappedObjects.indexOf(objects);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n            return this;\r\n        }\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    //scene update event listener\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map = mapppedObject.data.get('raycasterMap')\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    //ray factory\r\n    createRay: function(options) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","export function Map(options, scene) {\r\n    this.type;\r\n    this.active;\r\n    this.dynamic;\r\n    this._object;\r\n    this._points = [];\r\n    this._segments = [];\r\n    this.getPoints;\r\n    this.getSegments;\r\n    this.getIntersections;\r\n    this.segmentCount = 0;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\n//config\r\nMap.prototype = {\r\n    config: function(options) {\r\n        this.object = options.object;\r\n        //object type\r\n        if(options.type === undefined)\r\n            options.type = options.object.type;\r\n        this.type = options.type;\r\n\r\n        switch(options.type) {\r\n            case 'Polygon':\r\n                this.getPoints = this._getPolygonPoints;\r\n                this.getSegments = this._getPolygonSegments;\r\n                this.updateMap = this._updatePolygonMap;\r\n                break;\r\n            case 'Arc':\r\n                this.getPoints = this._getArcPoints;\r\n                this.getSegments = this._getArcSegments;\r\n                this.updateMap = this._updateArcMap;\r\n                break;\r\n            case 'Line':\r\n                this.getPoints = this._getLinePoints;\r\n                this.getSegments = this._getLineSegments;\r\n                this.updateMap = this._updateLineMap;\r\n                break;\r\n            default:\r\n                this.getPoints = this._getRectanglePoints;\r\n                this.getSegments = this._getRectangleSegments;\r\n                this.updateMap = this._updateRectangleMap;\r\n        }\r\n\r\n        //dynamic map\r\n        this.dynamic = (options.dynamic == true) ? true : false;\r\n        this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    //set segments count for circle map\r\n    setSegmentCount: function(count) {\r\n        this.segmentCount = count;\r\n        this.updateMap();\r\n        return this;\r\n    }\r\n};\r\n//add methods for rectangle maps\r\nlet rectangle = require('./map-rectangle-methods.js');\r\nMap.prototype._getRectanglePoints = rectangle.getPoints;\r\nMap.prototype._getRectangleSegments = rectangle.getSegments;\r\nMap.prototype._updateRectangleMap = rectangle.updateMap;\r\n\r\n//add methods for line maps\r\nlet line = require('./map-line-methods.js');\r\nMap.prototype._getLinePoints = line.getPoints;\r\nMap.prototype._getLineSegments = line.getSegments;\r\nMap.prototype._updateLineMap = line.updateMap;\r\n\r\n//add methods for polygon maps\r\nlet polygon = require('./map-polygon-methods.js');\r\nMap.prototype._getPolygonPoints = polygon.getPoints;\r\nMap.prototype._getPolygonSegments = polygon.getSegments;\r\nMap.prototype._updatePolygonMap = polygon.updateMap;\r\n\r\n//add methods for circle maps\r\nlet arc = require('./map-circle-methods.js');\r\nMap.prototype._getArcPoints = arc.getPoints;\r\nMap.prototype._getArcSegments = arc.getSegments;\r\nMap.prototype._updateArcMap = arc.updateMap;\r\n","/*Map methods for rectangles*/\n//get points\nexport function getPoints(ray = false) {\n    return this._points;\n};\n\n//get segments\nexport function getSegments() {\n    return this._segments;\n};\n\n//map update\nexport function updateMap() {\n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for lines*/\n//get points\nexport function getPoints(ray = false) {\n    return this._points;\n};\n\n//get segments\nexport function getSegments() {\n    return this._segments;\n};\n\n//map update\nexport function updateMap() {\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x + offset.x, pointA.y + offset.y, pointB.x + offset.x, pointB.y + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for polygons*/\n//get points\nexport function getPoints(ray = false) {\n    return this._points;\n};\n\n//get segments\nexport function getSegments() {\n    return this._segments;\n};\n\n//map update\nexport function updateMap() {\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for circles*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","export function Ray(options, raycaster) {\r\n    this.origin = new Phaser.Geom.Point();\r\n    this._ray = new Phaser.Geom.Line();\r\n    this.angle = 0;\r\n    this.range = Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.detectionRange = 0;\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    this.ignoreNotIntersectedRays = true;\r\n    this.intersections = [];\r\n    this._raycaster = raycaster ? raycaster : false;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    //config\r\n    config: function(options) {\r\n        this.object = options.object;\r\n        //origin\r\n        if(options.origin)\r\n            this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n        //range (0 = max)\r\n        if(options.range)\r\n            this.range = options.range;\r\n\r\n        //detection range (0 = max)\r\n        if(options.detectionRange)\r\n            this.detectionRange = options.detectionRange;\r\n\r\n        if(options.ignoreNotIntersectedRays !== undefined)\r\n            this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n        \r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n        return this;\r\n    },\r\n\r\n    //set ray\r\n    setRay: function(x, y, angle, range = Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.origin.setTo(x, y);\r\n        this.angle = angle;\r\n        this.range = range;\r\n\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //set ray's origin point\r\n    setOrigin: function(x, y) {\r\n        this.origin.setTo(x, y);\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //set ray's range\r\n    setRange: function(range = Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.range = range;\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        return this;\r\n    },\r\n\r\n    //set angle\r\n    setAngle: function(angle = 0) {\r\n        this.angle = angle;\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        return this;\r\n    },\r\n\r\n    //set detection range\r\n    setDetectionRange: function(detectionRange = 0) {\r\n        this.detectionRange = detectionRange;\r\n        this.rangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //is object (possibly) in range\r\n    boundsInRange(object, bounds = false) {\r\n        if(!this.detectionRange)\r\n            return true;\r\n\r\n        let objectBounds;\r\n        if(bounds)\r\n            objectBounds = bounds;\r\n        else\r\n            objectBounds = object.getBounds();\r\n\r\n        if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n            return true;\r\n\r\n        return false;\r\n    },\r\n\r\n    //cast ray to find closest intersection\r\n    cast(options = {}) {\r\n        let closestIntersection;\r\n        let closestDistance = Phaser.Math.MAX_SAFE_INTEGER;\r\n        //if bounding box is defined check bounding box intersection\r\n        if(this._raycaster && this._raycaster.boundingBox) {\r\n            let intersections = [];\r\n            Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n            if(intersections.length === 1)\r\n                closestIntersection = intersections[0];\r\n            else if(intersections.length > 1) {\r\n                for(let intersection of intersections) {\r\n                    let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    if(distance < closestDistance) {\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                closestDistance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n\r\n        //if no objects to cast ray were passed, use raycasters mapped objects\r\n        if(!options.objects) {\r\n            if(this._raycaster)\r\n                options.objects = this._raycaster.mappedObjects;\r\n            else\r\n                return intersections;\r\n        }\r\n        \r\n        for(let object of options.objects) {\r\n            //check if object is intersected by ray\r\n            if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\r\n                continue;\r\n\r\n            let map = object.data.get('raycasterMap');\r\n            \r\n            //check intersections\r\n            for(let segment of map.getSegments()) {\r\n                let intersection = [];\r\n                //if target point is segmemt point\r\n                if(options.target) {\r\n                    if(\r\n                        Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                        || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                    ) {\r\n                        intersection = options.target;\r\n                    }\r\n                    else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                        continue;\r\n                }\r\n                //if no intersection continue\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                  continue;\r\n                \r\n                //get closest intersection\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n\r\n            //check arc intersections if its not\r\n            if(map.type === 'Arc') {\r\n               //if arc has generated points (besides tangent points to ray)\r\n                if(map._points.length > 0) {\r\n                    continue;\r\n                }\r\n                \r\n                //check if target point is a circle tangent point to ray\r\n                if(options.target) {\r\n                    let points = map.getPoints(this);\r\n                    let isTangent = false;\r\n                    for(let point of points) {\r\n\r\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                            //get closest intersection\r\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                            if(distance < closestDistance) {\r\n                                closestDistance = distance;\r\n                                closestIntersection = point;\r\n                                isTangent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(isTangent)\r\n                        continue;\r\n                }\r\n\r\n                let circleIntersections = [];\r\n                let offset = new Phaser.Geom.Point();\r\n                offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n                offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n                //calculate circle's center after rotation\r\n                let rotation = map.object.rotation;\r\n                if(rotation !== 0) {\r\n                    let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                    Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                    let cB = vector.getPointB();\r\n                    offset.x = cB.x;\r\n                    offset.y = cB.y;\r\n                }\r\n\r\n                //create transformed circle\r\n                let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                    for(let intersection of circleIntersections) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                        if(distance < closestDistance) {\r\n\r\n                            closestDistance = distance;\r\n                            closestIntersection = intersection;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!closestIntersection)\r\n            return (this.ignoreNotIntersectedRays) ? false : this._ray.getPointB();\r\n        return new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n    },\r\n\r\n    //cast ray in all directions\r\n    castAll: function(options = {}) {\r\n        let intersections = [];\r\n        let maps = [];\r\n        let rayTargets = [];\r\n        let testedObjects = [];\r\n\r\n        //if no objects to cast ray were passed, use raycasters mapped objects\r\n        if(!options.objects) {\r\n            if(this._raycaster)\r\n                options.objects = this._raycaster.mappedObjects;\r\n            else\r\n                return intersections;\r\n\r\n            //if bounding box is defined add bounding box points to \r\n            if(this._raycaster && this._raycaster.boundingBox) {\r\n                for(let point of this._raycaster.boundingBox.points) {\r\n                    rayTargets.push({\r\n                        point: point,\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                    });\r\n                }\r\n            }\r\n\r\n            for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n                let object = options.objects[i];\r\n                //if bound in range\r\n                if(!this.boundsInRange(object))\r\n                    continue;\r\n                \r\n                testedObjects.push(object);\r\n\r\n                let map = object.data.get('raycasterMap');\r\n                maps.push(map);\r\n                //get points and angles\r\n                for(let point of map.getPoints(this)) {\r\n                    rayTargets.push({\r\n                        point: point,\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                    });\r\n                }\r\n\r\n                //get objects intersections\r\n                for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n                    let objectB = options.objects[j];\r\n                    let mapB = objectB.data.get('raycasterMap');\r\n                    //check if bounding boxes overlap\r\n                    if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\r\n                        continue;\r\n                    \r\n                    //find objects intersections\r\n                    for(let segmentA of map.getSegments()) {\r\n                        for(let segmentB of mapB.getSegments()) {\r\n                            let intersection = [];\r\n                            if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                                continue;\r\n                            \r\n                            rayTargets.push({\r\n                                point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            //sort target points by angle\r\n            rayTargets.sort(function(a, b){\r\n                return a.angle - b.angle;\r\n            });\r\n\r\n            //cast rays\r\n            for(let target of rayTargets){\r\n                this.setAngle(target.angle);\r\n                let intersection = this.cast({\r\n                    objects: testedObjects,\r\n                    target: target.point\r\n                });\r\n                if(intersection){\r\n                    //if intersection hits target point cast two additional rays\r\n                    if(Phaser.Geom.Point.Equals(target.point, intersection)) {\r\n                        this.setAngle(target.angle - 0.0001);\r\n                        let intersectionA = this.cast({\r\n                            objects: testedObjects\r\n                        });\r\n                        if(intersectionA)\r\n                            intersections.push(intersectionA);\r\n                        \r\n                        intersections.push(intersection);\r\n\r\n                        this.setAngle(target.angle + 0.0001);\r\n                        let intersectionB = this.cast({\r\n                            objects: testedObjects\r\n                        });\r\n                        if(intersectionB)\r\n                            intersections.push(intersectionB);\r\n\r\n                        continue;\r\n                    }\r\n                    intersections.push(intersection);\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersections;\r\n    }\r\n};\r\n"],"sourceRoot":""}