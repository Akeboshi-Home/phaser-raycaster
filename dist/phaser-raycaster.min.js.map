{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/enableArcadePhysics.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setRayRange","rayRange","Phaser","Math","MAX_SAFE_INTEGER","this","Geom","Line","SetToAngle","_ray","origin","x","y","angle","setDetectionRange","detectionRange","detectionRangeCircle","setTo","boundsInRange","objectBounds","bounds","getBounds","Intersects","CircleToRectangle","setAngle","Angle","Normalize","setAngleDeg","DegToRad","setCone","cone","setConeDeg","overlap","objects","targets","bodies","overlapCircle","Circle","collisionRange","undefined","_raycaster","scene","physics","overlapCirc","Array","isArray","body","hitbox","isCircle","position","halfWidth","Rectangle","width","height","testOverlap","push","gameObject","CircleToCircle","slicedIntersections","slice","type","TriangleToCircle","RectangleToTriangle","PhaserRaycaster","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","createRaycaster","options","_Raycaster","constructor","require","Raycaster","version","graphics","boundingBox","mappedObjects","sortedPoints","mapSegmentCount","world","setOptions","autoUpdate","add","lineStyle","color","fillStyle","mapGameObjects","setBoundingBox","rectangle","points","segments","Point","left","top","right","bottom","length","dynamic","segmentCount","includes","data","setDataEnabled","map","Map","set","config","option","removeMappedObjects","index","indexOf","splice","enableMaps","active","disableMaps","mapppedObject","updateMap","createRay","Ray","_points","_segments","getPoints","getSegments","getIntersections","line","polygon","arc","container","tilemap","setSegmentCount","collisionTiles","setCollisionTiles","setOrigin","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","pointA","geom","getPointA","pointB","getPointB","rotation","vectorA","scaleX","scaleY","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","rayLength","sqrt","pow","radius","dAngle","asin","newPoints","count","getCircles","tempRay","list","child","iterate","childPoints","segment","iLength","childA","mapA","j","jLength","childB","mapB","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","Distance","Between","x1","y1","x2","y2","LineToCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","leftEdge","vertical","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","raycaster","ignoreNotIntersectedRays","autoSlice","intersections","setRay","cast","castCircle","castCone","enableArcadePhysics","angleDeg","coneDeg","arcadePhysicsCircle","closestIntersection","closestDistance","GetLineToRectangle","distance","target","Equals","isTangent","circleIntersections","circle","GetLineToCircle","originalAngle","maps","rayTargets","testedObjects","objectB","sort","a","b","intersectionA","intersectionB","minAngle","maxAngle","angleOffsetDeg","RadToDeg","ShortestBetween","abs","closed","slices","Triangle","existing","setCircle"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else\n        objectBounds = object.getBounds();\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {float} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {float} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|objects[]} [objects] - Game object / array off game objects to test.\n *\n * @return {objects[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let bodies = false;\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //get bodies in range\n    if(objects === undefined) {\n        objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n        bodies = true;\n    }\n    //get object's body\n    else if(!Array.isArray(objects)) {\n        objects = [objects];\n    }\n    //if objects are bodies\n    if(bodies) {\n        for(let body of objects) {\n            if(body === this.body)\n                continue;\n            \n            let hitbox;\n            //get physics body hitbox\n            if(body.isCircle) {\n                hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n            }\n            else {\n                hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n            }\n\n            if(this.testOverlap(hitbox))\n                targets.push(body.gameObject);\n        }\n    }\n    //if objects are game objects\n    else {\n        for(let object of objects) {\n            let hitbox;\n            //get physics body hitbox\n            if(object.body.isCircle) {\n                hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                    continue;\n            }\n            else {\n                hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                    continue;\n            }\n\n            if(this.testOverlap(hitbox))\n                targets.push(object);\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Raycaster.Ray#overlap}.\n *\n * @method Raycaster.Ray#testOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Raycaster.Ray#overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if target object is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if target is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","var PhaserRaycaster = function (scene)\n{\n    //The Scene that owns this plugin\n    this.scene = scene;\n\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted)\n    {\n        scene.sys.events.once('boot', this.boot, this);\n    }\n};\n\n//Static function called by the PluginFile Loader.\nPhaserRaycaster.register = function (PluginManager)\n{\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\n    //  it has an entry in the InjectionMap.\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\n};\n\nPhaserRaycaster.prototype = {\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot: function ()\n    {\n        var eventEmitter = this.systems.events;\n\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n        eventEmitter.on('start', this.start, this);\n\n        eventEmitter.on('preupdate', this.preUpdate, this);\n        eventEmitter.on('update', this.update, this);\n        eventEmitter.on('postupdate', this.postUpdate, this);\n\n        eventEmitter.on('pause', this.pause, this);\n        eventEmitter.on('resume', this.resume, this);\n\n        eventEmitter.on('sleep', this.sleep, this);\n        eventEmitter.on('wake', this.wake, this);\n\n        eventEmitter.on('shutdown', this.shutdown, this);\n        eventEmitter.on('destroy', this.destroy, this);\n    },\n\n    //A test method.\n    test: function (name)\n    {\n        console.log('RaycasterPlugin says hello ' + name + '!');\n    },\n\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start: function ()\n    {\n    },\n\n    //Called every Scene step - phase 1\n    preUpdate: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 2\n    update: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 3\n    postUpdate: function (time, delta)\n    {\n    },\n\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause: function ()\n    {\n    },\n\n    //Called when a Scene is resumed from a paused state.\n    resume: function ()\n    {\n    },\n\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep: function ()\n    {\n    },\n\n    //Called when a Scene is woken from a sleeping state.\n    wake: function ()\n    {\n    },\n\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown: function ()\n    {\n    },\n\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.scene = undefined;\n    },\n\n    //Create Raycaster object\n    createRaycaster: function(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n\n};\n\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\n\n//Make sure you export the plugin for webpack to expose\n\nmodule.exports = PhaserRaycaster;\n","/**\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\n* @copyright    2020 Marcin Walczak\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\n*/\n\n/**\n * @classdesc\n *\n * Raycaster class responsible for creating ray objects and managing mapped objects.\n * \n * @namespace Raycaster\n * @class Raycaster\n * @constructor\n * @since 6.0.0\n *\n * @param {object} [options] - Raycaster's configuration options. May include:\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\n * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\n */\nexport function Raycaster(options) {\n    /**\n    * Plugin version.\n    *\n    * @name Raycaster#version\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.version = '0.8.0-dev';\n    /**\n    * Raycaster's scene\n    *\n    * @name Raycaster#version\n    * @type {string}\n    * @private\n    * @since 0.6.0\n    */\n    this.scene;\n    this.graphics;\n\n    /**\n    * Raycaster's bounding box.\n    *\n    * @name Raycaster#boundingBox\n    * @type {Phaser.Geom.Rectangle}\n    * @default false\n    * @private\n    * @since 0.6.0\n    */\n    this.boundingBox = false;\n    /**\n    * Array of mapped game objects.\n    *\n    * @name Raycaster#mappedObjects\n    * @type {object[]}\n    * @since 0.6.0\n    */\n    this.mappedObjects = [];\n    this.sortedPoints = [];\n    /**\n    * Number of segments of circle maps.\n    *\n    * @name Raycaster#mapSegmentCount\n    * @type {integer}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.mapSegmentCount = 0;\n\n    if(options !== undefined) {\n        if(options.boundingBox === undefined && options.scene !== undefined && options.scene.physics !== undefined)\n            options.boundingBox = options.scene.physics.world.bounds;\n\n        this.setOptions(options);\n\n        if(options.autoUpdate === undefined || options.autoUpdate)\n            //automatically update event\n            this.scene.events.on('update', this.update.bind(this));\n    }\n    else\n        //automatically update event\n        this.scene.events.on('update', this.update.bind(this));\n\n    return this;\n}\n\nRaycaster.prototype = {\n    /**\n    * Configure raycaster.\n    *\n    * @method Raycaster#setOptions\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\n    * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps.\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    setOptions: function(options) {\n        if(options.scene !== undefined) {\n            this.scene = options.scene;\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        }\n\n        if(options.mapSegmentCount !== undefined)\n            this.mapSegmentCount = options.mapSegmentCount;\n\n        if(options.objects !== undefined)\n            this.mapGameObjects(options.objects);\n\n        if(options.boundingBox !== undefined)\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\n\n        return this;\n    },\n\n    /**\n    * Set Raycatser's bounding box.\n    *\n    * @method Raycaster#setBoundingBox\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {integer} x - The X coordinate of the top left corner of bounding box.\n    * @param {integer} y - The Y coordinate of the top left corner of bounding box.\n    * @param {integer} width - The width of bounding box.\n    * @param {integer} height - The height of bounding box.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    setBoundingBox: function(x, y, width, height) {\n        this.boundingBox = {\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\n            points: [],\n            segments: []\n        }\n        //set points\n        let points = [\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\n        ];\n\n        this.boundingBox.points = points;\n\n        //set segments\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\n            if(i+1 < length)\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n            else\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n        }\n    },\n\n    /**\n    * Map game objects\n    *\n    * @method Raycaster#mapGameObjects\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object|object[]} objects - Game object or array of game objects to map.\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\n        options.dynamic = dynamic;\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\n\n        if(!Array.isArray(objects)) {\n            if(this.mappedObjects.includes(objects))\n                return this;\n\n            if(!objects.data)\n                objects.setDataEnabled();\n\n            options.object = objects;\n\n            let map = new this.Map(options);\n\n            objects.data.set('raycasterMap', map);\n            this.mappedObjects.push(objects);\n\n            return this;\n        }\n        \n        for(let object of objects) {\n            if(this.mappedObjects.includes(object))\n                continue;\n\n            if(!object.data)\n                object.setDataEnabled();\n\n            let config = {};\n            for(let option in options) {\n                config[option] = options[option];\n            }\n            config.object = object;\n            \n            let map = new this.Map(config);\n\n            object.data.set('raycasterMap', map);\n            this.mappedObjects.push(object);\n        }\n        return this;\n    },\n\n    /**\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\n    *\n    * @method Raycaster#removeMappedObjects\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    removeMappedObjects: function(objects) {\n        if(!Array.isArray(objects)) {\n            let index = this.mappedObjects.indexOf(objects);\n            if(index >= 0)\n                this.mappedObjects.splice(index, 1)\n            return this;\n        }\n\n        for(let object of objects) {\n            let index = this.mappedObjects.indexOf(object);\n            if(index >= 0)\n                this.mappedObjects.splice(index, 1)\n        }\n\n        return this;\n    },\n\n    /**\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\n    *\n    * @method Raycaster#enableMaps\n    * @memberof Raycaster\n    * @instance\n    * @since 0.7.2\n    *\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    enableMaps: function(objects) {\n        if(!Array.isArray(objects)) {\n            if(objects.data) {\n                let map = objects.data.get('raycasterMap');\n                if(map)\n                    map.active = true;\n            }\n                \n            return this;\n        }\n        \n        for(let object of objects) {\n            if(object.data) {\n                let map = object.data.get('raycasterMap');\n                if(map)\n                    map.active = true;\n            }\n        }\n\n        return this;\n    },\n\n    /**\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\n    *\n    * @method Raycaster#disableMaps\n    * @memberof Raycaster\n    * @instance\n    * @since 0.7.2\n    *\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    disableMaps: function(objects) {\n        if(!Array.isArray(objects)) {\n            if(objects.data) {\n                let map = objects.data.get('raycasterMap');\n                if(map)\n                    map.active = false;\n            }\n                \n            return this;\n        }\n        \n        for(let object of objects) {\n            if(object.data) {\n                let map = object.data.get('raycasterMap');\n                if(map)\n                    map.active = false;\n            }\n        }\n\n        return this;\n    },\n\n    /**\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\n    *\n    * @method Raycaster#update\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    */\n    update: function() {\n        //update dynamic maps\n        if(this.mappedObjects.length > 0)\n            for(let mapppedObject of this.mappedObjects) {\n                if(mapppedObject.data === undefined)\n                    continue;\n\n                let map = mapppedObject.data.get('raycasterMap')\n                if(map.dynamic)\n                    map.updateMap();\n            }\n    },\n\n    /**\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\n    *\n    * @method Raycaster#createRay\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object} [options] - Ray options:\n    *\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n    */\n    createRay: function(options = {}) {\n        return new this.Ray(options, this);\n    }\n}\n\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options) {\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map#dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this.dynamic;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n    this.getIntersections;\n\n    this.config(options);\n    this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config\n};\n\nMap.prototype.constructor = Map;\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.updateMap = container.updateMap;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {integer} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n        this.updateMap();\n        return this;\n}\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, getCircles = false) {\n    if(!this.active)\n        return [];\n\n    let points = [];\n    if(!getCircles)\n        points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(ray){\n        //create temporary ray\n        let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n        let tempRay = ray._raycaster.createRay({\n            origin: {\n                x: vector.getPointB().x,\n                y: vector.getPointB().y\n            }\n        });\n\n        for(let child of this.object.list){\n            if(child.type === 'Arc'){\n\n                let map = child.data.get('raycasterMap');\n                if(map._points.length == 0){\n                    for(let point of map.getPoints(tempRay, true)){\n                        let vector = new Phaser.Geom.Line(0, 0, point.x, point.y);\n                        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n                        points.push(new Phaser.Geom.Point(vector.getPointB().x + offset.x, vector.getPointB().y + offset.y));\n                    }\n                }\n            }\n            else if(child.type === 'Container') {\n                for(let point of child.data.get('raycasterMap').getPoints(tempRay, true)){\n                    if(this.object.rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n                }\n            }\n\n        }\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    //iterate through container's children\n    container.iterate(function(child){\n        if(!child.data)\n            child.setDataEnabled();\n\n        //get child map\n        let map = child.data.get('raycasterMap');\n        if(!map) {\n            map = new this.constructor({\n                object: child,\n                segmentCount: this.segmentCount\n            });\n            child.data.set('raycasterMap', map);\n        }\n        else\n            map.updateMap();\n\n        //add child points\n        let childPoints = [];\n        for(let point of map.getPoints()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                points.push(vector.getPointB());\n            }\n            //if rotation === 0\n            else\n                points.push(new Phaser.Geom.Point(point.x * container.scaleX + offset.x, point.y * container.scaleX + offset.y));\n\n            childPoints.push(points[points.length - 1])\n        }\n\n        //add child segments\n        for(let segment of map.getSegments()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let pointA = segment.getPointA();\n                let pointB = segment.getPointB();\n                let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n                let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n                Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n                segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n            }\n            //if rotation === 0\n            else\n                segments.push(new Phaser.Geom.Line(segment.getPointA().x * container.scaleX + offset.x, segment.getPointA().y * container.scaleY + offset.y, segment.getPointB().x * container.scaleX + offset.x, segment.getPointB().y * container.scaleY + offset.y));\n        }\n\n    }.bind(this));\n\n    //get children intersections\n    for(let i = 0, iLength = container.list.length; i < iLength; i++){\n        let childA = container.list[i];\n        let mapA = childA.data.get('raycasterMap');\n\n        for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n            let childB = container.list[j];\n            let mapB = childB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                continue;\n\n            //find objects intersections\n            for(let segmentA of mapA.getSegments()) {\n                for(let segmentB of mapB.getSegments()) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                     //calculate positions after container's rotation\n                    if(rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, intersection.x * this.object.scaleX + offset.x, intersection.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Ray specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {float}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {float}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {integer}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {(object|bolean)}\n    * @default false\n    * @since 0.8.0\n    */\n    //this.body = false;\n    //this.arcadePhysicsCircle;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    enableArcadePhysics: require('./enableArcadePhysics.js').enableArcadePhysics,\n    overlap: require('./overlap.js').overlap,\n    testOverlap: require('./overlap.js').testOverlap\n};\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {float} [options.angle = 0] - Ray's angle in radians.\n * @param {float} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {float} [options.cone = 0] - Ray's cone angle in radians.\n * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n * @param {float} [angle] - Ray's angle in radians.\n * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.body !== undefined) {\n        this.arcadePhysicsCircle.x = x;\n        this.arcadePhysicsCircle.x = y;\n    }\n\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestDistance = this.rayRange;\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        //check if object is intersected by ray\n        if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\n            continue;\n\n        let map = object.data.get('raycasterMap');\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n            }\n        }\n\n        //check arc intersections if its not\n        if(map.type === 'Arc') {\n           //if arc has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                    }\n                }\n            }\n        }\n    }\n\n    if(!closestIntersection)\n        return (this.ignoreNotIntersectedRays) ? false : this._ray.getPointB();\n    return new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n}\n","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n        }\n\n        for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n            let object = options.objects[i];\n            //if bound in range\n            if(!this.boundsInRange(object))\n                continue;\n            \n            testedObjects.push(object);\n\n            let map = object.data.get('raycasterMap');\n            maps.push(map);\n            //get points and angles\n            for(let point of map.getPoints(this)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n\n            //get objects intersections\n            for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n                let objectB = options.objects[j];\n                let mapB = objectB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\n                    continue;\n                \n                //find objects intersections\n                for(let segmentA of map.getSegments(this)) {\n                    for(let segmentB of mapB.getSegments(this)) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                        });\n                    }\n                }\n            }\n        }\n\n        //sort target points by angle\n        rayTargets.sort(function(a, b){\n            //if rays towards points have the same angles promote closer one\n            if(a.angle == b.angle) {\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                    return 1;\n                else\n                    return -1;\n            }\n\n            return a.angle - b.angle;\n        }.bind(this));\n\n        //cast rays\n        for(let target of rayTargets){\n            this.setAngle(target.angle);\n            let intersection = this.cast({\n                objects: testedObjects,\n                target: target.point\n            });\n            if(intersection){\n                //if intersection hits target point cast two additional rays\n                if(Phaser.Geom.Point.Equals(target.point, intersection)) {\n                    this.setAngle(target.angle - 0.0001);\n                    let intersectionA = this.cast({\n                        objects: testedObjects\n                    });\n                    if(intersectionA)\n                        intersections.push(intersectionA);\n                    \n                    intersections.push(intersection);\n\n                    this.setAngle(target.angle + 0.0001);\n                    let intersectionB = this.cast({\n                        objects: testedObjects\n                    });\n                    if(intersectionB)\n                        intersections.push(intersectionB);\n\n                    continue;\n                }\n                intersections.push(intersection);\n            }\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n\n                let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n                let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                    rayTargets.push({\n                        point: point,\n                        angle: angle,\n                        angleOffsetDeg: -angleOffsetDeg\n                    });\n                }\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map = object.data.get('raycasterMap');\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    //cast rays\n    for(let target of rayTargets){\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            if(Phaser.Geom.Point.Equals(target.point, intersection)) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects\n                });\n                if(intersectionA)\n                    intersections.push(intersectionA);\n                \n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects\n                });\n                if(intersectionB)\n                    intersections.push(intersectionB);\n\n                continue;\n            }\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n\n    return intersections;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\n * Add to ray arcade physics body. Body will be circle with radius equal to {@link Raycaster.Ray#range Ray.range}.\n *\n * @method Raycaster.Ray#enableArcadePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enableArcadePhysics() {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.arcadePhysicsCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y);\n    this.arcadePhysicsCircle.setOrigin(0.5, 0.5);\n    this._raycaster.scene.physics.add.existing(this.arcadePhysicsCircle);\n\n    this.body = this.arcadePhysicsCircle.body;\n    this.body.setCircle(this.collisionRange);\n\n    return this;\n}\n"],"sourceRoot":""}