{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/ray/ray-core.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","PhaserRaycaster","scene","this","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","graphics","boundingBox","mappedObjects","sortedPoints","mapSegmentCount","physics","world","bounds","setOptions","add","lineStyle","width","color","fillStyle","objects","mapGameObjects","setBoundingBox","x","y","height","rectangle","Phaser","Geom","Rectangle","points","segments","Point","left","top","right","bottom","length","push","Line","dynamic","segmentCount","Array","isArray","includes","data","setDataEnabled","map","Map","set","removeMappedObjects","index","indexOf","splice","updateMap","createRay","Ray","type","active","_object","_points","_segments","getPoints","getSegments","getIntersections","config","_getPolygonPoints","_getPolygonSegments","_updatePolygonMap","_getArcPoints","_getArcSegments","_updateArcMap","_getLinePoints","_getLineSegments","_updateLineMap","_getRectanglePoints","_getRectangleSegments","_updateRectangleMap","setSegmentCount","count","line","polygon","arc","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","pointA","geom","getPointA","pointB","getPointB","rotation","vectorA","scaleX","scaleY","SetToAngle","Angle","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","origin","rayLength","Math","sqrt","pow","radius","angle","dAngle","asin","newPoints","raycaster","_ray","range","MAX_SAFE_INTEGER","detectionRange","detectionRangeCircle","Circle","ignoreNotIntersectedRays","intersections","_raycaster","setTo","setRay","setOrigin","setRange","setAngle","setAngleDeg","DegToRad","setDetectionRange","rangeCircle","boundsInRange","objectBounds","getBounds","Intersects","CircleToRectangle","cast","closestIntersection","closestDistance","GetLineToRectangle","intersection","distance","Distance","Between","target","segment","Equals","LineToLine","isTangent","circleIntersections","circle","GetLineToCircle","x1","y1","castCircle","maps","rayTargets","testedObjects","iLength","j","jLength","objectB","mapB","RectangleToRectangle","segmentA","segmentB","sort","a","b","intersectionA","intersectionB"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar PhaserRaycaster = function (scene)\r\n{\r\n    //The Scene that owns this plugin\r\n    this.scene = scene;\r\n\r\n    this.systems = scene.sys;\r\n\r\n    if (!scene.sys.settings.isBooted)\r\n    {\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    }\r\n};\r\n\r\n//Static function called by the PluginFile Loader.\r\nPhaserRaycaster.register = function (PluginManager)\r\n{\r\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\r\n\r\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\r\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\r\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\r\n    //  it has an entry in the InjectionMap.\r\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\r\n};\r\n\r\nPhaserRaycaster.prototype = {\r\n\r\n    //  Called when the Plugin is booted by the PluginManager.\r\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\r\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\r\n\r\n        eventEmitter.on('start', this.start, this);\r\n\r\n        eventEmitter.on('preupdate', this.preUpdate, this);\r\n        eventEmitter.on('update', this.update, this);\r\n        eventEmitter.on('postupdate', this.postUpdate, this);\r\n\r\n        eventEmitter.on('pause', this.pause, this);\r\n        eventEmitter.on('resume', this.resume, this);\r\n\r\n        eventEmitter.on('sleep', this.sleep, this);\r\n        eventEmitter.on('wake', this.wake, this);\r\n\r\n        eventEmitter.on('shutdown', this.shutdown, this);\r\n        eventEmitter.on('destroy', this.destroy, this);\r\n    },\r\n\r\n    //A test method.\r\n    test: function (name)\r\n    {\r\n        console.log('RaycasterPlugin says hello ' + name + '!');\r\n    },\r\n\r\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\r\n    start: function ()\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 1\r\n    preUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 2\r\n    update: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 3\r\n    postUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\r\n    pause: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is resumed from a paused state.\r\n    resume: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\r\n    sleep: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is woken from a sleeping state.\r\n    wake: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\r\n    shutdown: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n    },\r\n\r\n    //Create Raycaster object\r\n    createRaycaster: function(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n\r\n};\r\n\r\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\r\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\r\n\r\n//Make sure you export the plugin for webpack to expose\r\n\r\nmodule.exports = PhaserRaycaster;\r\n","export function Raycaster(options) {\r\n    this.scene;\r\n    this.graphics;\r\n    this.boundingBox = false;\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    this.mapSegmentCount = 0;   //quantity of segments of map of circle\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined)\r\n            options.boundingBox = options.scene.physics.world.bounds;\r\n\r\n        this.setOptions(options);\r\n    }\r\n\r\n    //update event\r\n        this.scene.events.on('update', function() {\r\n            this.update();\r\n        }.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    //set options\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    //set bounding box\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    //map object\r\n    mapGameObjects: function(objects, dynamic = false, segmentCount = this.mapSegmentCount) {\r\n        if(!Array.isArray(objects)) {\r\n            if(this.mappedObjects.includes(objects))\r\n                return this;\r\n\r\n            if(!objects.data)\r\n                objects.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: objects,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            }, this.scene);\r\n\r\n            objects.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(objects);\r\n\r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            if(!object.data)\r\n                object.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: object,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            });\r\n\r\n            object.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    //remove mapped Objects\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            let index = this.mappedObjects.indexOf(objects);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n            return this;\r\n        }\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    //scene update event listener\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map = mapppedObject.data.get('raycasterMap')\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    //ray factory\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","export function Map(options, scene) {\r\n    this.type;\r\n    this.active;\r\n    this.dynamic;\r\n    this._object;\r\n    this._points = [];\r\n    this._segments = [];\r\n    this.getPoints;\r\n    this.getSegments;\r\n    this.getIntersections;\r\n    this.segmentCount = 0;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\n//config\r\nMap.prototype = {\r\n    config: function(options) {\r\n        this.object = options.object;\r\n        //object type\r\n        if(options.type === undefined)\r\n            options.type = options.object.type;\r\n        this.type = options.type;\r\n\r\n        switch(options.type) {\r\n            case 'Polygon':\r\n                this.getPoints = this._getPolygonPoints;\r\n                this.getSegments = this._getPolygonSegments;\r\n                this.updateMap = this._updatePolygonMap;\r\n                break;\r\n            case 'Arc':\r\n                this.getPoints = this._getArcPoints;\r\n                this.getSegments = this._getArcSegments;\r\n                this.updateMap = this._updateArcMap;\r\n                break;\r\n            case 'Line':\r\n                this.getPoints = this._getLinePoints;\r\n                this.getSegments = this._getLineSegments;\r\n                this.updateMap = this._updateLineMap;\r\n                break;\r\n            default:\r\n                this.getPoints = this._getRectanglePoints;\r\n                this.getSegments = this._getRectangleSegments;\r\n                this.updateMap = this._updateRectangleMap;\r\n        }\r\n\r\n        //dynamic map\r\n        this.dynamic = (options.dynamic == true) ? true : false;\r\n        this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    //set segments count for circle map\r\n    setSegmentCount: function(count) {\r\n        this.segmentCount = count;\r\n        this.updateMap();\r\n        return this;\r\n    }\r\n};\r\n//add methods for rectangle maps\r\nlet rectangle = require('./map-rectangle-methods.js');\r\nMap.prototype._getRectanglePoints = rectangle.getPoints;\r\nMap.prototype._getRectangleSegments = rectangle.getSegments;\r\nMap.prototype._updateRectangleMap = rectangle.updateMap;\r\n\r\n//add methods for line maps\r\nlet line = require('./map-line-methods.js');\r\nMap.prototype._getLinePoints = line.getPoints;\r\nMap.prototype._getLineSegments = line.getSegments;\r\nMap.prototype._updateLineMap = line.updateMap;\r\n\r\n//add methods for polygon maps\r\nlet polygon = require('./map-polygon-methods.js');\r\nMap.prototype._getPolygonPoints = polygon.getPoints;\r\nMap.prototype._getPolygonSegments = polygon.getSegments;\r\nMap.prototype._updatePolygonMap = polygon.updateMap;\r\n\r\n//add methods for circle maps\r\nlet arc = require('./map-circle-methods.js');\r\nMap.prototype._getArcPoints = arc.getPoints;\r\nMap.prototype._getArcSegments = arc.getSegments;\r\nMap.prototype._updateArcMap = arc.updateMap;\r\n","/*Map methods for rectangles*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for lines*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x + offset.x, pointA.y + offset.y, pointB.x + offset.x, pointB.y + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for polygons*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for circles*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","export function Ray(options, raycaster) {\r\n    this.origin = new Phaser.Geom.Point();\r\n    this._ray = new Phaser.Geom.Line();\r\n    this.angle = 0;\r\n    this.range = Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.detectionRange = 0;\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    this.ignoreNotIntersectedRays = true;\r\n    this.intersections = [];\r\n    this._raycaster = raycaster ? raycaster : false;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    //config\r\n    config: function(options) {\r\n        this.object = options.object;\r\n        //origin\r\n        if(options.origin)\r\n            this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n        //angle\r\n        if(options.angle)\r\n            this.angle = angle;\r\n\r\n        //range (0 = max)\r\n        if(options.range)\r\n            this.range = options.range;\r\n\r\n        //detection range (0 = max)\r\n        if(options.detectionRange)\r\n            this.detectionRange = options.detectionRange;\r\n\r\n        if(options.ignoreNotIntersectedRays !== undefined)\r\n            this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n        \r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n        return this;\r\n    },\r\n\r\n    //set ray\r\n    setRay: function(x, y, angle, range = Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.origin.setTo(x, y);\r\n        this.angle = angle;\r\n        this.range = range;\r\n\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //set ray's origin point\r\n    setOrigin: function(x, y) {\r\n        this.origin.setTo(x, y);\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //set ray's range\r\n    setRange: function(range = Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.range = range;\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        return this;\r\n    },\r\n\r\n    //set angle (rad)\r\n    setAngle: function(angle = 0) {\r\n        this.angle = angle;\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        return this;\r\n    },\r\n\r\n    //set angle (deg)\r\n    setAngleDeg(angle = 0) {\r\n        this.angle = Phaser.Math.DegToRad(angle);\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        return this;\r\n    },\r\n\r\n    //set detection range\r\n    setDetectionRange: function(detectionRange = 0) {\r\n        this.detectionRange = detectionRange;\r\n        this.rangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //is object (possibly) in range\r\n    boundsInRange(object, bounds = false) {\r\n        if(!this.detectionRange)\r\n            return true;\r\n\r\n        let objectBounds;\r\n        if(bounds)\r\n            objectBounds = bounds;\r\n        else\r\n            objectBounds = object.getBounds();\r\n\r\n        if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n            return true;\r\n\r\n        return false;\r\n    },\r\n\r\n    //cast ray to find closest intersection\r\n    cast(options = {}) {\r\n        let closestIntersection;\r\n        let closestDistance = Phaser.Math.MAX_SAFE_INTEGER;\r\n        //if bounding box is defined check bounding box intersection\r\n        if(this._raycaster && this._raycaster.boundingBox) {\r\n            let intersections = [];\r\n            Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n            if(intersections.length === 1)\r\n                closestIntersection = intersections[0];\r\n            else if(intersections.length > 1) {\r\n                for(let intersection of intersections) {\r\n                    let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    if(distance < closestDistance) {\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                closestDistance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n\r\n        //if no objects to cast ray were passed, use raycasters mapped objects\r\n        if(!options.objects) {\r\n            if(this._raycaster)\r\n                options.objects = this._raycaster.mappedObjects;\r\n            else\r\n                return intersections;\r\n        }\r\n        \r\n        for(let object of options.objects) {\r\n            //check if object is intersected by ray\r\n            if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\r\n                continue;\r\n\r\n            let map = object.data.get('raycasterMap');\r\n            \r\n            //check intersections\r\n            for(let segment of map.getSegments()) {\r\n                let intersection = [];\r\n                //if target point is segmemt point\r\n                if(options.target) {\r\n                    if(\r\n                        Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                        || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                    ) {\r\n                        intersection = options.target;\r\n                    }\r\n                    else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                        continue;\r\n                }\r\n                //if no intersection continue\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                  continue;\r\n                \r\n                //get closest intersection\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n\r\n            //check arc intersections if its not\r\n            if(map.type === 'Arc') {\r\n               //if arc has generated points (besides tangent points to ray)\r\n                if(map._points.length > 0) {\r\n                    continue;\r\n                }\r\n                \r\n                //check if target point is a circle tangent point to ray\r\n                if(options.target) {\r\n                    let points = map.getPoints(this);\r\n                    let isTangent = false;\r\n                    for(let point of points) {\r\n\r\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                            //get closest intersection\r\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                            if(distance < closestDistance) {\r\n                                closestDistance = distance;\r\n                                closestIntersection = point;\r\n                                isTangent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(isTangent)\r\n                        continue;\r\n                }\r\n\r\n                let circleIntersections = [];\r\n                let offset = new Phaser.Geom.Point();\r\n                offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n                offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n                //calculate circle's center after rotation\r\n                let rotation = map.object.rotation;\r\n                if(rotation !== 0) {\r\n                    let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                    Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                    let cB = vector.getPointB();\r\n                    offset.x = cB.x;\r\n                    offset.y = cB.y;\r\n                }\r\n\r\n                //create transformed circle\r\n                let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                    for(let intersection of circleIntersections) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                        if(distance < closestDistance) {\r\n\r\n                            closestDistance = distance;\r\n                            closestIntersection = intersection;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!closestIntersection)\r\n            return (this.ignoreNotIntersectedRays) ? false : this._ray.getPointB();\r\n        return new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n    },\r\n\r\n    //cast ray in all directions\r\n    castCircle: function(options = {}) {\r\n        let intersections = [];\r\n        let maps = [];\r\n        let rayTargets = [];\r\n        let testedObjects = [];\r\n\r\n        //if no objects to cast ray were passed, use raycasters mapped objects\r\n        if(!options.objects) {\r\n            if(this._raycaster)\r\n                options.objects = this._raycaster.mappedObjects;\r\n            else\r\n                return intersections;\r\n\r\n            //if bounding box is defined add bounding box points to \r\n            if(this._raycaster && this._raycaster.boundingBox) {\r\n                for(let point of this._raycaster.boundingBox.points) {\r\n                    rayTargets.push({\r\n                        point: point,\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                    });\r\n                }\r\n            }\r\n\r\n            for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n                let object = options.objects[i];\r\n                //if bound in range\r\n                if(!this.boundsInRange(object))\r\n                    continue;\r\n                \r\n                testedObjects.push(object);\r\n\r\n                let map = object.data.get('raycasterMap');\r\n                maps.push(map);\r\n                //get points and angles\r\n                for(let point of map.getPoints(this)) {\r\n                    rayTargets.push({\r\n                        point: point,\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                    });\r\n                }\r\n\r\n                //get objects intersections\r\n                for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n                    let objectB = options.objects[j];\r\n                    let mapB = objectB.data.get('raycasterMap');\r\n                    //check if bounding boxes overlap\r\n                    if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\r\n                        continue;\r\n                    \r\n                    //find objects intersections\r\n                    for(let segmentA of map.getSegments()) {\r\n                        for(let segmentB of mapB.getSegments()) {\r\n                            let intersection = [];\r\n                            if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                                continue;\r\n                            \r\n                            rayTargets.push({\r\n                                point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            //sort target points by angle\r\n            rayTargets.sort(function(a, b){\r\n                return a.angle - b.angle;\r\n            });\r\n\r\n            //cast rays\r\n            for(let target of rayTargets){\r\n                this.setAngle(target.angle);\r\n                let intersection = this.cast({\r\n                    objects: testedObjects,\r\n                    target: target.point\r\n                });\r\n                if(intersection){\r\n                    //if intersection hits target point cast two additional rays\r\n                    if(Phaser.Geom.Point.Equals(target.point, intersection)) {\r\n                        this.setAngle(target.angle - 0.0001);\r\n                        let intersectionA = this.cast({\r\n                            objects: testedObjects\r\n                        });\r\n                        if(intersectionA)\r\n                            intersections.push(intersectionA);\r\n                        \r\n                        intersections.push(intersection);\r\n\r\n                        this.setAngle(target.angle + 0.0001);\r\n                        let intersectionB = this.cast({\r\n                            objects: testedObjects\r\n                        });\r\n                        if(intersectionB)\r\n                            intersections.push(intersectionB);\r\n\r\n                        continue;\r\n                    }\r\n                    intersections.push(intersection);\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersections;\r\n    }\r\n};\r\n"],"sourceRoot":""}