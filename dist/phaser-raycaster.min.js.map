{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/ray/ray-core.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","PhaserRaycaster","scene","this","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","version","graphics","boundingBox","mappedObjects","sortedPoints","mapSegmentCount","physics","world","bounds","setOptions","add","lineStyle","width","color","fillStyle","objects","mapGameObjects","setBoundingBox","x","y","height","rectangle","Phaser","Geom","Rectangle","points","segments","Point","left","top","right","bottom","length","push","Line","dynamic","segmentCount","Array","isArray","includes","data","setDataEnabled","map","Map","set","removeMappedObjects","index","indexOf","splice","updateMap","createRay","Ray","type","active","_object","_points","_segments","getPoints","getSegments","getIntersections","config","_getPolygonPoints","_getPolygonSegments","_updatePolygonMap","_getArcPoints","_getArcSegments","_updateArcMap","_getLinePoints","_getLineSegments","_updateLineMap","_getRectanglePoints","_getRectangleSegments","_updateRectangleMap","setSegmentCount","count","line","polygon","arc","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","pointA","geom","getPointA","pointB","getPointB","rotation","vectorA","scaleX","scaleY","SetToAngle","Angle","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","origin","rayLength","Math","sqrt","pow","radius","angle","dAngle","asin","newPoints","raycaster","_ray","range","MAX_SAFE_INTEGER","detectionRange","detectionRangeCircle","Circle","ignoreNotIntersectedRays","intersections","_raycaster","setTo","setRay","setOrigin","setRange","setAngle","setAngleDeg","DegToRad","setDetectionRange","rangeCircle","boundsInRange","objectBounds","getBounds","Intersects","CircleToRectangle","cast","closestIntersection","closestDistance","GetLineToRectangle","intersection","distance","Distance","Between","target","segment","Equals","LineToLine","isTangent","circleIntersections","circle","GetLineToCircle","x1","y1","castCircle","maps","rayTargets","testedObjects","iLength","j","jLength","objectB","mapB","RectangleToRectangle","segmentA","segmentB","sort","a","b","intersectionA","intersectionB"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar PhaserRaycaster = function (scene)\r\n{\r\n    //The Scene that owns this plugin\r\n    this.scene = scene;\r\n\r\n    this.systems = scene.sys;\r\n\r\n    if (!scene.sys.settings.isBooted)\r\n    {\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    }\r\n};\r\n\r\n//Static function called by the PluginFile Loader.\r\nPhaserRaycaster.register = function (PluginManager)\r\n{\r\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\r\n\r\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\r\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\r\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\r\n    //  it has an entry in the InjectionMap.\r\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\r\n};\r\n\r\nPhaserRaycaster.prototype = {\r\n\r\n    //  Called when the Plugin is booted by the PluginManager.\r\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\r\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\r\n\r\n        eventEmitter.on('start', this.start, this);\r\n\r\n        eventEmitter.on('preupdate', this.preUpdate, this);\r\n        eventEmitter.on('update', this.update, this);\r\n        eventEmitter.on('postupdate', this.postUpdate, this);\r\n\r\n        eventEmitter.on('pause', this.pause, this);\r\n        eventEmitter.on('resume', this.resume, this);\r\n\r\n        eventEmitter.on('sleep', this.sleep, this);\r\n        eventEmitter.on('wake', this.wake, this);\r\n\r\n        eventEmitter.on('shutdown', this.shutdown, this);\r\n        eventEmitter.on('destroy', this.destroy, this);\r\n    },\r\n\r\n    //A test method.\r\n    test: function (name)\r\n    {\r\n        console.log('RaycasterPlugin says hello ' + name + '!');\r\n    },\r\n\r\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\r\n    start: function ()\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 1\r\n    preUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 2\r\n    update: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 3\r\n    postUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\r\n    pause: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is resumed from a paused state.\r\n    resume: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\r\n    sleep: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is woken from a sleeping state.\r\n    wake: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\r\n    shutdown: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n    },\r\n\r\n    //Create Raycaster object\r\n    createRaycaster: function(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n\r\n};\r\n\r\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\r\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\r\n\r\n//Make sure you export the plugin for webpack to expose\r\n\r\nmodule.exports = PhaserRaycaster;\r\n","export function Raycaster(options) {\r\n    this.version = '0.6.3';\r\n    this.scene;\r\n    this.graphics;\r\n    this.boundingBox = false;\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    this.mapSegmentCount = 0;   //quantity of segments of map of circle\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined && options.scene.physics !== undefined)\r\n            options.boundingBox = options.scene.physics.world.bounds;\r\n\r\n        this.setOptions(options);\r\n    }\r\n\r\n    //update event\r\n        this.scene.events.on('update', function() {\r\n            this.update();\r\n        }.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    //set options\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    //set bounding box\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    //map object\r\n    mapGameObjects: function(objects, dynamic = false, segmentCount = this.mapSegmentCount) {\r\n        if(!Array.isArray(objects)) {\r\n            if(this.mappedObjects.includes(objects))\r\n                return this;\r\n\r\n            if(!objects.data)\r\n                objects.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: objects,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            }, this.scene);\r\n\r\n            objects.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(objects);\r\n\r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            if(!object.data)\r\n                object.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: object,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            });\r\n\r\n            object.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    //remove mapped Objects\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            let index = this.mappedObjects.indexOf(objects);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n            return this;\r\n        }\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    //scene update event listener\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map = mapppedObject.data.get('raycasterMap')\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    //ray factory\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","export function Map(options, scene) {\r\n    this.type;\r\n    this.active;\r\n    this.dynamic;\r\n    this._object;\r\n    this._points = [];\r\n    this._segments = [];\r\n    this.getPoints;\r\n    this.getSegments;\r\n    this.getIntersections;\r\n    this.segmentCount = 0;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\n//config\r\nMap.prototype = {\r\n    config: function(options) {\r\n        this.object = options.object;\r\n        //object type\r\n        if(options.type === undefined)\r\n            options.type = options.object.type;\r\n        this.type = options.type;\r\n\r\n        switch(options.type) {\r\n            case 'Polygon':\r\n                this.getPoints = this._getPolygonPoints;\r\n                this.getSegments = this._getPolygonSegments;\r\n                this.updateMap = this._updatePolygonMap;\r\n                break;\r\n            case 'Arc':\r\n                this.getPoints = this._getArcPoints;\r\n                this.getSegments = this._getArcSegments;\r\n                this.updateMap = this._updateArcMap;\r\n                break;\r\n            case 'Line':\r\n                this.getPoints = this._getLinePoints;\r\n                this.getSegments = this._getLineSegments;\r\n                this.updateMap = this._updateLineMap;\r\n                break;\r\n            default:\r\n                this.getPoints = this._getRectanglePoints;\r\n                this.getSegments = this._getRectangleSegments;\r\n                this.updateMap = this._updateRectangleMap;\r\n        }\r\n\r\n        //dynamic map\r\n        this.dynamic = (options.dynamic == true) ? true : false;\r\n        this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    //set segments count for circle map\r\n    setSegmentCount: function(count) {\r\n        this.segmentCount = count;\r\n        this.updateMap();\r\n        return this;\r\n    }\r\n};\r\n//add methods for rectangle maps\r\nlet rectangle = require('./map-rectangle-methods.js');\r\nMap.prototype._getRectanglePoints = rectangle.getPoints;\r\nMap.prototype._getRectangleSegments = rectangle.getSegments;\r\nMap.prototype._updateRectangleMap = rectangle.updateMap;\r\n\r\n//add methods for line maps\r\nlet line = require('./map-line-methods.js');\r\nMap.prototype._getLinePoints = line.getPoints;\r\nMap.prototype._getLineSegments = line.getSegments;\r\nMap.prototype._updateLineMap = line.updateMap;\r\n\r\n//add methods for polygon maps\r\nlet polygon = require('./map-polygon-methods.js');\r\nMap.prototype._getPolygonPoints = polygon.getPoints;\r\nMap.prototype._getPolygonSegments = polygon.getSegments;\r\nMap.prototype._updatePolygonMap = polygon.updateMap;\r\n\r\n//add methods for circle maps\r\nlet arc = require('./map-circle-methods.js');\r\nMap.prototype._getArcPoints = arc.getPoints;\r\nMap.prototype._getArcSegments = arc.getSegments;\r\nMap.prototype._updateArcMap = arc.updateMap;\r\n","/*Map methods for rectangles*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for lines*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x + offset.x, pointA.y + offset.y, pointB.x + offset.x, pointB.y + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for polygons*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for circles*/\r\n//get points\r\nexport function getPoints(ray = false) {\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n//get segments\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n//map update\r\nexport function updateMap() {\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","export function Ray(options, raycaster) {\r\n    this.origin = new Phaser.Geom.Point();\r\n    this._ray = new Phaser.Geom.Line();\r\n    this.angle = 0;\r\n    this.range = Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.detectionRange = 0;\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    this.ignoreNotIntersectedRays = true;\r\n    this.intersections = [];\r\n    this._raycaster = raycaster ? raycaster : false;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    //config\r\n    config: function(options) {\r\n        this.object = options.object;\r\n        //origin\r\n        if(options.origin)\r\n            this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n        //angle\r\n        if(options.angle)\r\n            this.angle = angle;\r\n\r\n        //range (0 = max)\r\n        if(options.range)\r\n            this.range = options.range;\r\n\r\n        //detection range (0 = max)\r\n        if(options.detectionRange)\r\n            this.detectionRange = options.detectionRange;\r\n\r\n        if(options.ignoreNotIntersectedRays !== undefined)\r\n            this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n        \r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n        return this;\r\n    },\r\n\r\n    //set ray\r\n    setRay: function(x, y, angle, range = Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.origin.setTo(x, y);\r\n        this.angle = angle;\r\n        this.range = range;\r\n\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //set ray's origin point\r\n    setOrigin: function(x, y) {\r\n        this.origin.setTo(x, y);\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //set ray's range\r\n    setRange: function(range = Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.range = range;\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        return this;\r\n    },\r\n\r\n    //set angle (rad)\r\n    setAngle: function(angle = 0) {\r\n        this.angle = angle;\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        return this;\r\n    },\r\n\r\n    //set angle (deg)\r\n    setAngleDeg(angle = 0) {\r\n        this.angle = Phaser.Math.DegToRad(angle);\r\n        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\r\n        return this;\r\n    },\r\n\r\n    //set detection range\r\n    setDetectionRange: function(detectionRange = 0) {\r\n        this.detectionRange = detectionRange;\r\n        this.rangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n        return this;\r\n    },\r\n\r\n    //is object (possibly) in range\r\n    boundsInRange(object, bounds = false) {\r\n        if(!this.detectionRange)\r\n            return true;\r\n\r\n        let objectBounds;\r\n        if(bounds)\r\n            objectBounds = bounds;\r\n        else\r\n            objectBounds = object.getBounds();\r\n\r\n        if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n            return true;\r\n\r\n        return false;\r\n    },\r\n\r\n    //cast ray to find closest intersection\r\n    cast(options = {}) {\r\n        let closestIntersection;\r\n        let closestDistance = Phaser.Math.MAX_SAFE_INTEGER;\r\n        //if bounding box is defined check bounding box intersection\r\n        if(this._raycaster && this._raycaster.boundingBox) {\r\n            let intersections = [];\r\n            Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n            if(intersections.length === 1)\r\n                closestIntersection = intersections[0];\r\n            else if(intersections.length > 1) {\r\n                for(let intersection of intersections) {\r\n                    let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    if(distance < closestDistance) {\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                closestDistance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n\r\n        //if no objects to cast ray were passed, use raycasters mapped objects\r\n        if(!options.objects) {\r\n            if(this._raycaster)\r\n                options.objects = this._raycaster.mappedObjects;\r\n            else\r\n                return intersections;\r\n        }\r\n        \r\n        for(let object of options.objects) {\r\n            //check if object is intersected by ray\r\n            if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\r\n                continue;\r\n\r\n            let map = object.data.get('raycasterMap');\r\n            \r\n            //check intersections\r\n            for(let segment of map.getSegments()) {\r\n                let intersection = [];\r\n                //if target point is segmemt point\r\n                if(options.target) {\r\n                    if(\r\n                        Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                        || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                    ) {\r\n                        intersection = options.target;\r\n                    }\r\n                    else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                        continue;\r\n                }\r\n                //if no intersection continue\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                  continue;\r\n                \r\n                //get closest intersection\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n\r\n            //check arc intersections if its not\r\n            if(map.type === 'Arc') {\r\n               //if arc has generated points (besides tangent points to ray)\r\n                if(map._points.length > 0) {\r\n                    continue;\r\n                }\r\n                \r\n                //check if target point is a circle tangent point to ray\r\n                if(options.target) {\r\n                    let points = map.getPoints(this);\r\n                    let isTangent = false;\r\n                    for(let point of points) {\r\n\r\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                            //get closest intersection\r\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                            if(distance < closestDistance) {\r\n                                closestDistance = distance;\r\n                                closestIntersection = point;\r\n                                isTangent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(isTangent)\r\n                        continue;\r\n                }\r\n\r\n                let circleIntersections = [];\r\n                let offset = new Phaser.Geom.Point();\r\n                offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n                offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n                //calculate circle's center after rotation\r\n                let rotation = map.object.rotation;\r\n                if(rotation !== 0) {\r\n                    let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                    Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                    let cB = vector.getPointB();\r\n                    offset.x = cB.x;\r\n                    offset.y = cB.y;\r\n                }\r\n\r\n                //create transformed circle\r\n                let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                    for(let intersection of circleIntersections) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                        if(distance < closestDistance) {\r\n\r\n                            closestDistance = distance;\r\n                            closestIntersection = intersection;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!closestIntersection)\r\n            return (this.ignoreNotIntersectedRays) ? false : this._ray.getPointB();\r\n        return new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n    },\r\n\r\n    //cast ray in all directions\r\n    castCircle: function(options = {}) {\r\n        let intersections = [];\r\n        let maps = [];\r\n        let rayTargets = [];\r\n        let testedObjects = [];\r\n\r\n        //if no objects to cast ray were passed, use raycasters mapped objects\r\n        if(!options.objects) {\r\n            if(this._raycaster)\r\n                options.objects = this._raycaster.mappedObjects;\r\n            else\r\n                return intersections;\r\n\r\n            //if bounding box is defined add bounding box points to \r\n            if(this._raycaster && this._raycaster.boundingBox) {\r\n                for(let point of this._raycaster.boundingBox.points) {\r\n                    rayTargets.push({\r\n                        point: point,\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                    });\r\n                }\r\n            }\r\n\r\n            for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n                let object = options.objects[i];\r\n                //if bound in range\r\n                if(!this.boundsInRange(object))\r\n                    continue;\r\n                \r\n                testedObjects.push(object);\r\n\r\n                let map = object.data.get('raycasterMap');\r\n                maps.push(map);\r\n                //get points and angles\r\n                for(let point of map.getPoints(this)) {\r\n                    rayTargets.push({\r\n                        point: point,\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                    });\r\n                }\r\n\r\n                //get objects intersections\r\n                for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n                    let objectB = options.objects[j];\r\n                    let mapB = objectB.data.get('raycasterMap');\r\n                    //check if bounding boxes overlap\r\n                    if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\r\n                        continue;\r\n                    \r\n                    //find objects intersections\r\n                    for(let segmentA of map.getSegments()) {\r\n                        for(let segmentB of mapB.getSegments()) {\r\n                            let intersection = [];\r\n                            if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                                continue;\r\n                            \r\n                            rayTargets.push({\r\n                                point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            //sort target points by angle\r\n            rayTargets.sort(function(a, b){\r\n                return a.angle - b.angle;\r\n            });\r\n\r\n            //cast rays\r\n            for(let target of rayTargets){\r\n                this.setAngle(target.angle);\r\n                let intersection = this.cast({\r\n                    objects: testedObjects,\r\n                    target: target.point\r\n                });\r\n                if(intersection){\r\n                    //if intersection hits target point cast two additional rays\r\n                    if(Phaser.Geom.Point.Equals(target.point, intersection)) {\r\n                        this.setAngle(target.angle - 0.0001);\r\n                        let intersectionA = this.cast({\r\n                            objects: testedObjects\r\n                        });\r\n                        if(intersectionA)\r\n                            intersections.push(intersectionA);\r\n                        \r\n                        intersections.push(intersection);\r\n\r\n                        this.setAngle(target.angle + 0.0001);\r\n                        let intersectionB = this.cast({\r\n                            objects: testedObjects\r\n                        });\r\n                        if(intersectionB)\r\n                            intersections.push(intersectionB);\r\n\r\n                        continue;\r\n                    }\r\n                    intersections.push(intersection);\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersections;\r\n    }\r\n};\r\n"],"sourceRoot":""}