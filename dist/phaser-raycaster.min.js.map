{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setRange","range","Phaser","Math","MAX_SAFE_INTEGER","this","Geom","Line","SetToAngle","_ray","origin","x","y","angle","setDetectionRange","detectionRange","detectionRangeCircle","setTo","boundsInRange","objectBounds","bounds","getBounds","Intersects","CircleToRectangle","setAngle","Angle","Normalize","setAngleDeg","DegToRad","setCone","cone","setConeDeg","PhaserRaycaster","scene","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","version","graphics","boundingBox","mappedObjects","sortedPoints","mapSegmentCount","physics","world","setOptions","add","lineStyle","width","color","fillStyle","objects","mapGameObjects","setBoundingBox","height","rectangle","Rectangle","points","segments","Point","left","top","right","bottom","length","push","dynamic","segmentCount","Array","isArray","includes","data","setDataEnabled","map","Map","set","removeMappedObjects","index","indexOf","splice","mapppedObject","updateMap","createRay","Ray","type","active","_object","_points","_segments","getPoints","getSegments","getIntersections","config","line","polygon","arc","setSegmentCount","_getRectanglePoints","_getRectangleSegments","_updateRectangleMap","_getLinePoints","_getLineSegments","_updateLineMap","_getPolygonPoints","_getPolygonSegments","_updatePolygonMap","_getArcPoints","_getArcSegments","_updateArcMap","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","pointA","geom","getPointA","pointB","getPointB","rotation","vectorA","scaleX","scaleY","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","rayLength","sqrt","pow","radius","dAngle","asin","newPoints","count","raycaster","Circle","ignoreNotIntersectedRays","intersections","_raycaster","setRay","setOrigin","cast","castCircle","castCone","angleDeg","coneDeg","closestIntersection","closestDistance","GetLineToRectangle","intersection","distance","Distance","Between","target","segment","Equals","LineToLine","isTangent","circleIntersections","circle","GetLineToCircle","x1","y1","originalAngle","maps","rayTargets","testedObjects","iLength","j","jLength","objectB","mapB","RectangleToRectangle","segmentA","segmentB","sort","a","b","intersectionA","intersectionB","minAngle","maxAngle","angleOffsetDeg","RadToDeg","ShortestBetween","abs"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/**\n * Set ray's range.\n *\n * @function Ray.setRange\n * @since 0.6.0\n *\n * @param {integer} [range] = Phaser.Math.MAX_SAFE_INTEGER - Ray's range.\n *\n * @return {object} Ray object.\n */\nexport function setRange(range = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.range = range;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n\n/**\n * Set ray's range.\n *\n * @function Ray.setRange\n * @since 0.6.0\n *\n * @param {integer} [detectionRange] = Phaser.Math.MAX_SAFE_INTEGER - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {object} Ray object.\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @function Ray.boundsInRange\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {Phaser.Geom. Rectangle} / {boolean} [bounds] = false - Tested object's bounds. If not passed bounds will be generated.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else\n        objectBounds = object.getBounds();\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * Set ray angle in radians.\n *\n * @function Ray.setAngle\n * @since 0.6.0\n *\n * @param {float} [angle] - Ray's angle in radians.\n *\n * @return {object} Ray object.\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n\n/**\n * Set ray angle in degrees.\n *\n * @function Ray.setAngleDeg\n * @since 0.6.1\n *\n * @param {float} [angle] - Ray's angle in degrees.\n *\n * @return {object} Ray object.\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    return this;\n}\n","/**\n * Set ray's cone angle in radians.\n *\n * @function Ray.setAngle\n * @since 0.7.0\n *\n * @param {float} [cone] - Ray's cone angle in radians.\n *\n * @return {object} Ray object.\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle in degrees.\n *\n * @function Ray.setAngleDeg\n * @since 0.7.0\n *\n * @param {float} [cone] - Ray's cone angle in degrees.\n *\n * @return {object} Ray object.\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","var PhaserRaycaster = function (scene)\r\n{\r\n    //The Scene that owns this plugin\r\n    this.scene = scene;\r\n\r\n    this.systems = scene.sys;\r\n\r\n    if (!scene.sys.settings.isBooted)\r\n    {\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    }\r\n};\r\n\r\n//Static function called by the PluginFile Loader.\r\nPhaserRaycaster.register = function (PluginManager)\r\n{\r\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\r\n\r\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\r\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\r\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\r\n    //  it has an entry in the InjectionMap.\r\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\r\n};\r\n\r\nPhaserRaycaster.prototype = {\r\n\r\n    //  Called when the Plugin is booted by the PluginManager.\r\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\r\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\r\n\r\n        eventEmitter.on('start', this.start, this);\r\n\r\n        eventEmitter.on('preupdate', this.preUpdate, this);\r\n        eventEmitter.on('update', this.update, this);\r\n        eventEmitter.on('postupdate', this.postUpdate, this);\r\n\r\n        eventEmitter.on('pause', this.pause, this);\r\n        eventEmitter.on('resume', this.resume, this);\r\n\r\n        eventEmitter.on('sleep', this.sleep, this);\r\n        eventEmitter.on('wake', this.wake, this);\r\n\r\n        eventEmitter.on('shutdown', this.shutdown, this);\r\n        eventEmitter.on('destroy', this.destroy, this);\r\n    },\r\n\r\n    //A test method.\r\n    test: function (name)\r\n    {\r\n        console.log('RaycasterPlugin says hello ' + name + '!');\r\n    },\r\n\r\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\r\n    start: function ()\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 1\r\n    preUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 2\r\n    update: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 3\r\n    postUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\r\n    pause: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is resumed from a paused state.\r\n    resume: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\r\n    sleep: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is woken from a sleeping state.\r\n    wake: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\r\n    shutdown: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n    },\r\n\r\n    //Create Raycaster object\r\n    createRaycaster: function(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n\r\n};\r\n\r\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\r\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\r\n\r\n//Make sure you export the plugin for webpack to expose\r\n\r\nmodule.exports = PhaserRaycaster;\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responible for creating ray objects and managing mapped objects.\r\n *\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Ray specific configuration settings.\r\n */\r\nexport function Raycaster(options) {\r\n    this.version = '0.7.0';\r\n    this.scene;\r\n    this.graphics;\r\n    this.boundingBox = false;\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    this.mapSegmentCount = 0;   //quantity of segments of map of circle\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined && options.scene.physics !== undefined)\r\n            options.boundingBox = options.scene.physics.world.bounds;\r\n\r\n        this.setOptions(options);\r\n    }\r\n\r\n    //update event\r\n    this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    //set options\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    //set bounding box\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    //map object\r\n    mapGameObjects: function(objects, dynamic = false, segmentCount = this.mapSegmentCount) {\r\n        if(!Array.isArray(objects)) {\r\n            if(this.mappedObjects.includes(objects))\r\n                return this;\r\n\r\n            if(!objects.data)\r\n                objects.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: objects,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            });\r\n\r\n            objects.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(objects);\r\n\r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            if(!object.data)\r\n                object.setDataEnabled();\r\n\r\n            let map = new this.Map({\r\n                object: object,\r\n                dynamic: dynamic,\r\n                segmentCount: segmentCount\r\n            });\r\n\r\n            object.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    //remove mapped Objects\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            let index = this.mappedObjects.indexOf(objects);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n            return this;\r\n        }\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    //scene update event listener\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                if(mapppedObject.data === undefined)\r\n                    continue;\r\n\r\n                let map = mapppedObject.data.get('raycasterMap')\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    //ray factory\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responible for mapping game objects.\r\n *\r\n * @class Map\r\n * @memberof Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options) {\r\n    this.type;\r\n    this.active;\r\n    this.dynamic;\r\n    this._object;\r\n    this._points = [];\r\n    this._segments = [];\r\n    this.getPoints;\r\n    this.getSegments;\r\n    this.getIntersections;\r\n    this.segmentCount = 0;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nlet rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config,\r\n    setSegmentCount: require('./segmentsCount.js').setSegmentCount,\r\n    //methods for rectangle maps\r\n    _getRectanglePoints: rectangle.getPoints,\r\n    _getRectangleSegments: rectangle.getSegments,\r\n    _updateRectangleMap: rectangle.updateMap,\r\n    //methods for line maps\r\n    _getLinePoints: line.getPoints,\r\n    _getLineSegments: line.getSegments,\r\n    _updateLineMap: line.updateMap,\r\n    //methods for polygon maps\r\n    _getPolygonPoints: polygon.getPoints,\r\n    _getPolygonSegments: polygon.getSegments,\r\n    _updatePolygonMap: polygon.updateMap,\r\n    //methods for circle maps\r\n    _getArcPoints: arc.getPoints,\r\n    _getArcSegments: arc.getSegments,\r\n    _updateArcMap: arc.updateMap\r\n};\r\n","/*Map methods for rectangles*/\r\n/**\r\n * Get array of rectangle's points.\r\n *\r\n * @function Map._getRectanglePoints\r\n * @since 0.6.0\r\n *\r\n * @param {object} [ray] - Ray object.\r\n *\r\n * @return {array} Array of points.\r\n */\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n/**\r\n * Get array of segments representing rectangle.\r\n *\r\n * @function Map._getRectangleSegments\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {array} Array of Phaser.Geom.Line objects.\r\n */\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n * Update rectangle's map of points and segments.\r\n *\r\n * @function Map._updateRectangleMap\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {object} Map object.\r\n */\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for lines*/\r\n/**\r\n * Get array of points for line.\r\n *\r\n * @function Map._getLinePoints\r\n * @since 0.6.0\r\n *\r\n * @param {object} [ray] - Ray object.\r\n *\r\n * @return {array} Array of points.\r\n */\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n/**\r\n * Get array of segments representing line.\r\n *\r\n * @function Map._getLineSegments\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {array} Array of Phaser.Geom.Line objects.\r\n */\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n * Update line's map of points and segments.\r\n *\r\n * @function Map._updateLineMap\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {object} Map object.\r\n */\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x + offset.x, pointA.y + offset.y, pointB.x + offset.x, pointB.y + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for polygons*/\r\n/**\r\n * Get array of polygon's points.\r\n *\r\n * @function Map._getPolygonPoints\r\n * @since 0.6.0\r\n *\r\n * @param {object} [ray] - Ray object.\r\n *\r\n * @return {array} Array of points.\r\n */\r\nexport function getPoints(ray = false) {\r\n    return this._points;\r\n};\r\n\r\n/**\r\n * Get array of segments representing polygon.\r\n *\r\n * @function Map._getPolygonSegments\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {array} Array of Phaser.Geom.Line objects.\r\n */\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n * Update polygon's map of points and segments.\r\n *\r\n * @function Map._updatePolygonMap\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {object} Map object.\r\n */\r\nexport function updateMap() {\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for circles*/\r\n/**\r\n * Get array of points on circle.\r\n *\r\n * @function Map._getArcPoints\r\n * @since 0.6.0\r\n *\r\n * @param {object} [ray] - Ray object. Used to generate points of rays tangent to circle, from ray origin.\r\n *\r\n * @return {array} Array of Phaser.GeomLine objects.\r\n */\r\nexport function getPoints(ray = false) {\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n * Get array of segments representing circle.\r\n *\r\n * @function Map._getArcSegments\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {array} Array of Phaser.Geom.Line objects.\r\n */\r\nexport function getSegments() {\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n * Update circle's map of points and segments. If segmentCount == 0. Map is generated dynamically by calculating points of rays tangent to circle, from ray origin.\r\n *\r\n * @function Map._updateArcMap\r\n * @since 0.6.0\r\n *\r\n *\r\n * @return {object} Map object.\r\n */\r\nexport function updateMap() {\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/**\n * Configure map on creation.\n *\n * @function Map.config\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * - {object} object - Mapped game object\n * - {string} [type] - Map type. If not defined, will be determined from object\n * - {boolean} [dynamic] = false - If set true, map will be dynamic (updated on scene update event).\n * - {integer} [segmentCount] = 0 - Circle map's segment count. If set to 0, map won't be generating segments and relay only on generated tangent point to actually testing ray.\n *\n * @return {object} Map object.\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    this.type = options.type;\n\n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = this._getPolygonPoints;\n            this.getSegments = this._getPolygonSegments;\n            this.updateMap = this._updatePolygonMap;\n            break;\n        case 'Arc':\n            this.getPoints = this._getArcPoints;\n            this.getSegments = this._getArcSegments;\n            this.updateMap = this._updateArcMap;\n            break;\n        case 'Line':\n            this.getPoints = this._getLinePoints;\n            this.getSegments = this._getLineSegments;\n            this.updateMap = this._updateLineMap;\n            break;\n        default:\n            this.getPoints = this._getRectanglePoints;\n            this.getSegments = this._getRectangleSegments;\n            this.updateMap = this._updateRectangleMap;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n    this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n *\n * @function Map.setSegmentCount\n * @since 0.6.0\n *\n * @param {integer} [count] - Circle's map segments count.\n *\n * @return {object} Map object.\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n        this.updateMap();\n        return this;\n}\n","/**\r\n * @classdesc\r\n *\r\n * Ray class responible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @class Ray\r\n * @memberof Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Ray specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    this.origin = new Phaser.Geom.Point();\r\n    this._ray = new Phaser.Geom.Line();\r\n    this.angle = 0;\r\n    this.cone = 0;\r\n    this.range = Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.detectionRange = 0;\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    this.ignoreNotIntersectedRays = true;\r\n    this.intersections = [];\r\n    this._raycaster = raycaster ? raycaster : false;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRange: require('./range.js').setRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone\r\n};\r\n","/**\n * Configure ray on creation.\n *\n * @function Ray.config\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * - {Phaser.Types.Math.Vector2Like} [origin] = {x:0, y:0} - Ray's position.\n * - {float} [angle] = 0 - Ray's angle in radians.\n * - {float} [angleDeg] = 0 - Ray's angle in degrees.\n * - {float} [cone] = 0 - Ray's cone angle in radians.\n * - {float} [coneDeg] = 0 - Ray's cone angle in degrees.\n * - {integer} [range] = Phaser.Math.MAX_SAFE_INTEGER - Ray's range.\n * - {integer} [detectionRange] = Phaser.Math.MAX_SAFE_INTEGER - Maximum distance between ray's position and tested objects bounding boxes.\n * - {boolean} [ignoreNotIntersectedRays] = true - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target.\n *\n * @return {object} Ray object.\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //range (0 = max)\n    if(options.range)\n        this.range = options.range;\n\n    //detection range (0 = max)\n    if(options.detectionRange)\n        this.detectionRange = options.detectionRange;\n\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @function Ray.setAngle\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n * @param {float} [angle] - Ray's angle in radians.\n * @param {integer} [range] = Phaser.Math.MAX_SAFE_INTEGER - Ray's range.\n *\n * @return {object} Ray object.\n */\nexport function setRay(x, y, angle, range = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.range = range;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n","/**\n * Set ray's position.\n *\n * @function Ray.setOrigin\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {object} Ray object.\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.range);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @function Ray.cast\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n * - {Phaser.Types.Math.Vector2Like} [target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n *\n * @return {Phaser.Types.Math.Vector2Like} / {boolean} - Point object of ray's closest intersection with tested objects. Returns false if no intersection has been found.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestDistance = Phaser.Math.MAX_SAFE_INTEGER;\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        else {\n            closestDistance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            closestIntersection = options.target;\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        //check if object is intersected by ray\n        if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\n            continue;\n\n        let map = object.data.get('raycasterMap');\n        \n        //check intersections\n        for(let segment of map.getSegments()) {\n            let intersection = [];\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n            }\n        }\n\n        //check arc intersections if its not\n        if(map.type === 'Arc') {\n           //if arc has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                    }\n                }\n            }\n        }\n    }\n\n    if(!closestIntersection)\n        return (this.ignoreNotIntersectedRays) ? false : this._ray.getPointB();\n    return new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n}\n","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @function Ray.castCircle\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n *\n * @return {array} - Array of Point objects of ray's closest intersections with tested objects.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n        }\n\n        for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n            let object = options.objects[i];\n            //if bound in range\n            if(!this.boundsInRange(object))\n                continue;\n            \n            testedObjects.push(object);\n\n            let map = object.data.get('raycasterMap');\n            maps.push(map);\n            //get points and angles\n            for(let point of map.getPoints(this)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n\n            //get objects intersections\n            for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n                let objectB = options.objects[j];\n                let mapB = objectB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\n                    continue;\n                \n                //find objects intersections\n                for(let segmentA of map.getSegments()) {\n                    for(let segmentB of mapB.getSegments()) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                        });\n                    }\n                }\n            }\n        }\n\n        //sort target points by angle\n        rayTargets.sort(function(a, b){\n            //if rays towards points have the same angles promote closer one\n            if(a.angle == b.angle) {\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                    return 1;\n                else\n                    return -1;\n            }\n\n            return a.angle - b.angle;\n        }.bind(this));\n\n        //cast rays\n        for(let target of rayTargets){\n            this.setAngle(target.angle);\n            let intersection = this.cast({\n                objects: testedObjects,\n                target: target.point\n            });\n            if(intersection){\n                //if intersection hits target point cast two additional rays\n                if(Phaser.Geom.Point.Equals(target.point, intersection)) {\n                    this.setAngle(target.angle - 0.0001);\n                    let intersectionA = this.cast({\n                        objects: testedObjects\n                    });\n                    if(intersectionA)\n                        intersections.push(intersectionA);\n                    \n                    intersections.push(intersection);\n\n                    this.setAngle(target.angle + 0.0001);\n                    let intersectionB = this.cast({\n                        objects: testedObjects\n                    });\n                    if(intersectionB)\n                        intersections.push(intersectionB);\n\n                    continue;\n                }\n                intersections.push(intersection);\n            }\n        }\n    }\n\n    this.setAngle(originalAngle);\n    return intersections;\n}\n","/**\n * Cast ray in cone to find closest intersections with tested mapped objects.\n *\n * @function Ray.castCone\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * - {array} [objects] - Array of game objects to test. If not provided use all mapped game objects.\n *\n * @return {array} - Array of Point objects of ray's closest intersections with tested objects.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n\n                let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n                let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                    rayTargets.push({\n                        point: point,\n                        angle: angle,\n                        angleOffsetDeg: -angleOffsetDeg\n                    });\n                }\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map = object.data.get('raycasterMap');\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments()) {\n                for(let segmentB of mapB.getSegments()) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    //cast rays\n    for(let target of rayTargets){\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            if(Phaser.Geom.Point.Equals(target.point, intersection)) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects\n                });\n                if(intersectionA)\n                    intersections.push(intersectionA);\n                \n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects\n                });\n                if(intersectionB)\n                    intersections.push(intersectionB);\n\n                continue;\n            }\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    return intersections;\n}\n"],"sourceRoot":""}