!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("PhaserRaycaster",[],e):"object"==typeof exports?exports.PhaserRaycaster=e():t.PhaserRaycaster=e()}(window,(function(){return function(t){var e={};function i(n){if(e[n])return e[n].exports;var s=e[n]={i:n,l:!1,exports:{}};return t[n].call(s.exports,s,s.exports,i),s.l=!0,s.exports}return i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)i.d(n,s,function(e){return t[e]}.bind(null,s));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=0)}([function(t,e,i){
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
var n=function(t){this.scene=t,this.systems=t.sys,t.sys.settings.isBooted||t.sys.events.once("boot",this.boot,this)};n.register=function(t){t.register("PhaserRaycaster",n,"base")},(n.prototype={boot:function(){var t=this.systems.events;t.on("start",this.start,this),t.on("preupdate",this.preUpdate,this),t.on("update",this.update,this),t.on("postupdate",this.postUpdate,this),t.on("pause",this.pause,this),t.on("resume",this.resume,this),t.on("sleep",this.sleep,this),t.on("wake",this.wake,this),t.on("shutdown",this.shutdown,this),t.on("destroy",this.destroy,this)},test:function(t){console.log("RaycasterPlugin says hello "+t+"!")},start:function(){},preUpdate:function(t,e){},update:function(t,e){},postUpdate:function(t,e){},pause:function(){},resume:function(){},sleep:function(){},wake:function(){},shutdown:function(){},destroy:function(){this.shutdown(),this.scene=void 0},createRaycaster:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.scene=this.scene,new this._Raycaster(t)}}).constructor=n,n.prototype._Raycaster=i(1).Raycaster,t.exports=n},function(t,e,i){"use strict";function n(t){return this.version="0.6.3",this.scene,this.graphics,this.boundingBox=!1,this.mappedObjects=[],this.sortedPoints=[],this.mapSegmentCount=0,void 0!==t&&(void 0===t.boundingBox&&void 0!==t.scene&&void 0!==t.scene.physics&&(t.boundingBox=t.scene.physics.world.bounds),this.setOptions(t)),this.scene.events.on("update",function(){this.update()}.bind(this)),this}i.r(e),i.d(e,"Raycaster",(function(){return n})),n.prototype={setOptions:function(t){return void 0!==t.scene&&(this.scene=t.scene,this.graphics=this.scene.add.graphics({lineStyle:{width:1,color:65280},fillStyle:{color:16711935}})),void 0!==t.mapSegmentCount&&(this.mapSegmentCount=t.mapSegmentCount),void 0!==t.objects&&this.mapGameObjects(t.objects),void 0!==t.boundingBox&&this.setBoundingBox(t.boundingBox.x,t.boundingBox.y,t.boundingBox.width,t.boundingBox.height),this},setBoundingBox:function(t,e,i,n){this.boundingBox={rectangle:new Phaser.Geom.Rectangle(t,e,i,n),points:[],segments:[]};var s=[new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.bottom),new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.bottom)];this.boundingBox.points=s;for(var o=0,r=this.boundingBox.points.length;o<r;o++)o+1<r?this.boundingBox.segments.push(new Phaser.Geom.Line(s[o].x,s[o].y,s[o+1].x,s[o+1].y)):this.boundingBox.segments.push(new Phaser.Geom.Line(s[o].x,s[o].y,s[0].x,s[0].y))},mapGameObjects:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.mapSegmentCount;if(!Array.isArray(t)){if(this.mappedObjects.includes(t))return this;t.data||t.setDataEnabled();var n=new this.Map({object:t,dynamic:e,segmentCount:i},this.scene);return t.data.set("raycasterMap",n),this.mappedObjects.push(t),this}var s=!0,o=!1,r=void 0;try{for(var a,h=t[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value;if(!this.mappedObjects.includes(c)){c.data||c.setDataEnabled();var g=new this.Map({object:c,dynamic:e,segmentCount:i});c.data.set("raycasterMap",g),this.mappedObjects.push(c)}}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}return this},removeMappedObjects:function(t){if(!Array.isArray(t)){var e=this.mappedObjects.indexOf(t);return e>=0&&this.mappedObjects.splice(e,1),this}var i=!0,n=!1,s=void 0;try{for(var o,r=t[Symbol.iterator]();!(i=(o=r.next()).done);i=!0){var a=o.value,h=this.mappedObjects.indexOf(a);h>=0&&this.mappedObjects.splice(h,1)}}catch(t){n=!0,s=t}finally{try{i||null==r.return||r.return()}finally{if(n)throw s}}return this},update:function(){if(this.mappedObjects.length>0){var t=!0,e=!1,i=void 0;try{for(var n,s=this.mappedObjects[Symbol.iterator]();!(t=(n=s.next()).done);t=!0){var o=n.value.data.get("raycasterMap");o.dynamic&&o.updateMap()}}catch(t){e=!0,i=t}finally{try{t||null==s.return||s.return()}finally{if(e)throw i}}}},createRay:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new this.Ray(t,this)}},n.prototype.Map=i(2).Map,n.prototype.Ray=i(7).Ray},function(t,e,i){"use strict";function n(t,e){return this.type,this.active,this.dynamic,this._object,this._points=[],this._segments=[],this.getPoints,this.getSegments,this.getIntersections,this.segmentCount=0,this.config(t),this.updateMap(),this}i.r(e),i.d(e,"Map",(function(){return n})),n.prototype={config:function(t){switch(this.object=t.object,void 0===t.type&&(t.type=t.object.type),this.type=t.type,t.type){case"Polygon":this.getPoints=this._getPolygonPoints,this.getSegments=this._getPolygonSegments,this.updateMap=this._updatePolygonMap;break;case"Arc":this.getPoints=this._getArcPoints,this.getSegments=this._getArcSegments,this.updateMap=this._updateArcMap;break;case"Line":this.getPoints=this._getLinePoints,this.getSegments=this._getLineSegments,this.updateMap=this._updateLineMap;break;default:this.getPoints=this._getRectanglePoints,this.getSegments=this._getRectangleSegments,this.updateMap=this._updateRectangleMap}return this.dynamic=1==t.dynamic,this.segmentCount=t.segmentCount?t.segmentCount:0,this},setSegmentCount:function(t){return this.segmentCount=t,this.updateMap(),this}};var s=i(3);n.prototype._getRectanglePoints=s.getPoints,n.prototype._getRectangleSegments=s.getSegments,n.prototype._updateRectangleMap=s.updateMap;var o=i(4);n.prototype._getLinePoints=o.getPoints,n.prototype._getLineSegments=o.getSegments,n.prototype._updateLineMap=o.updateMap;var r=i(5);n.prototype._getPolygonPoints=r.getPoints,n.prototype._getPolygonSegments=r.getSegments,n.prototype._updatePolygonMap=r.updateMap;var a=i(6);n.prototype._getArcPoints=a.getPoints,n.prototype._getArcSegments=a.getSegments,n.prototype._updateArcMap=a.updateMap},function(t,e,i){"use strict";function n(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){for(var t,e=[],i=0,n=(t=[this.object.getTopLeft(),this.object.getTopRight(),this.object.getBottomRight(),this.object.getBottomLeft()]).length;i<n;i++)i+1<n?e.push(new Phaser.Geom.Line(t[i].x,t[i].y,t[i+1].x,t[i+1].y)):e.push(new Phaser.Geom.Line(t[i].x,t[i].y,t[0].x,t[0].y));return this._points=t,this._segments=e,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return o}))},function(t,e,i){"use strict";function n(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){var t=[],e=[],i=new Phaser.Geom.Point;i.x=this.object.x-this.object.displayWidth*this.object.originX,i.y=this.object.y-this.object.displayHeight*this.object.originY;var n=this.object.geom.getPointA(),s=this.object.geom.getPointB(),o=this.object.rotation;if(0!==o){var r=new Phaser.Geom.Line(this.object.x,this.object.y,n.x*this.object.scaleX+i.x,n.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(r,this.object.x,this.object.y,Phaser.Geom.Line.Angle(r)+o,Phaser.Geom.Line.Length(r)),n=r.getPointB();var a=new Phaser.Geom.Line(this.object.x,this.object.y,s.x*this.object.scaleX+i.x,s.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+o,Phaser.Geom.Line.Length(a)),s=a.getPointB(),t.push(new Phaser.Geom.Point(n.x,n.y)),t.push(new Phaser.Geom.Point(s.x,s.y)),e.push(new Phaser.Geom.Line(n.x,n.y,s.x,s.y))}else t.push(new Phaser.Geom.Point(n.x*this.object.scaleX+i.x,n.y*this.object.scaleY+i.y)),t.push(new Phaser.Geom.Point(s.x*this.object.scaleX+i.x,s.y*this.object.scaleY+i.y)),e.push(new Phaser.Geom.Line(n.x+i.x,n.y+i.y,s.x+i.x,s.y+i.y));return this._points=t,this._segments=e,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return o}))},function(t,e,i){"use strict";function n(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){var t=[],e=[],i=new Phaser.Geom.Point;i.x=this.object.x-this.object.displayWidth*this.object.originX,i.y=this.object.y-this.object.displayHeight*this.object.originY;var n=this.object.rotation;if(0!==n){var s=!0,o=!1,r=void 0;try{for(var a,h=this.object.geom.points[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value,g=new Phaser.Geom.Line(this.object.x,this.object.y,c.x*this.object.scaleX+i.x,c.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(g,this.object.x,this.object.y,Phaser.Geom.Line.Angle(g)+n,Phaser.Geom.Line.Length(g)),t.push(g.getPointB())}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}}else{var u=!0,l=!1,y=void 0;try{for(var p,d=this.object.geom.points[Symbol.iterator]();!(u=(p=d.next()).done);u=!0){var f=p.value;t.push(new Phaser.Geom.Point(f.x*this.object.scaleX+i.x,f.y*this.object.scaleY+i.y))}}catch(t){l=!0,y=t}finally{try{u||null==d.return||d.return()}finally{if(l)throw y}}}for(var b=0,m=t.length;b<m;b++)b+1<m&&e.push(new Phaser.Geom.Line(t[b].x,t[b].y,t[b+1].x,t[b+1].y));if(this.object.closePath){var v=t.length-1;e.push(new Phaser.Geom.Line(t[v].x,t[v].y,t[0].x,t[0].y))}return this._points=t,this._segments=e,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return o}))},function(t,e,i){"use strict";function n(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this._points.length>0)return this._points;var e=[],i=new Phaser.Geom.Point;if(i.x=this.object.x-this.object.displayWidth*(this.object.originX-.5),i.y=this.object.y-this.object.displayHeight*(this.object.originY-.5),t){var n,s=new Phaser.Geom.Line,o=new Phaser.Geom.Line,r=this.object.rotation;if(0!==r){var a=new Phaser.Geom.Line(this.object.x,this.object.y,i.x,i.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+r,Phaser.Geom.Line.Length(a));var h=a.getPointB();n=new Phaser.Geom.Line(t.origin.x,t.origin.y,h.x,h.y)}else n=new Phaser.Geom.Line(t.origin.x,t.origin.y,i.x,i.y);var c=Math.sqrt(Math.pow(Phaser.Geom.Line.Length(n),2)-Math.pow(this.object.radius*this.object.scaleX,2)),g=Phaser.Geom.Line.Angle(n),u=Math.asin(this.object.radius*this.object.scaleX/Phaser.Geom.Line.Length(n));Phaser.Geom.Line.SetToAngle(s,t.origin.x,t.origin.y,g-u,c),Phaser.Geom.Line.SetToAngle(o,t.origin.x,t.origin.y,g+u,c),e.push(s.getPointB()),e.push(o.getPointB())}return e}function s(){return this._segments}function o(){if(!this.segmentCount)return this._points=[],this._segments=[],this;var t=new Phaser.Geom.Point;t.x=this.object.x-this.object.displayWidth*this.object.originX+this.object.radius*this.object.scaleX,t.y=this.object.y-this.object.displayHeight*this.object.originY+this.object.radius*this.object.scaleY;var e=this.object.geom.getPoints(this.segmentCount),i=[],n=this.object.rotation;if(0!==n){var s=[],o=!0,r=!1,a=void 0;try{for(var h,c=e[Symbol.iterator]();!(o=(h=c.next()).done);o=!0){var g=h.value,u=new Phaser.Geom.Line(this.object.x,this.object.y,this.object.x+(g.x+this.object.radius)*this.object.scaleX,this.object.y+(g.y+this.object.radius)*this.object.scaleY);Phaser.Geom.Line.SetToAngle(u,this.object.x,this.object.y,Phaser.Geom.Line.Angle(u)+n,Phaser.Geom.Line.Length(u)),s.push(u.getPointB())}}catch(t){r=!0,a=t}finally{try{o||null==c.return||c.return()}finally{if(r)throw a}}e=s}else{var l=!0,y=!1,p=void 0;try{for(var d,f=e[Symbol.iterator]();!(l=(d=f.next()).done);l=!0){var b=d.value;b.x=b.x*this.object.scaleX+t.x,b.y=b.y*this.object.scaleY+t.y}}catch(t){y=!0,p=t}finally{try{l||null==f.return||f.return()}finally{if(y)throw p}}}for(var m=0,v=e.length;m<v;m++)m+1<v?i.push(new Phaser.Geom.Line(e[m].x,e[m].y,e[m+1].x,e[m+1].y)):i.push(new Phaser.Geom.Line(e[m].x,e[m].y,e[0].x,e[0].y));return this._points=e,this._segments=i,this}i.r(e),i.d(e,"getPoints",(function(){return n})),i.d(e,"getSegments",(function(){return s})),i.d(e,"updateMap",(function(){return o}))},function(t,e,i){"use strict";function n(t,e){this.origin=new Phaser.Geom.Point,this._ray=new Phaser.Geom.Line,this.angle=0,this.range=Phaser.Math.MAX_SAFE_INTEGER,this.detectionRange=0,this.detectionRangeCircle=new Phaser.Geom.Circle,this.ignoreNotIntersectedRays=!0,this.intersections=[],this._raycaster=e||!1,this.config(t)}i.r(e),i.d(e,"Ray",(function(){return n})),n.prototype={config:function(t){return this.object=t.object,t.origin&&this.origin.setTo(t.origin.x,t.origin.y),t.angle&&(this.angle=angle),t.range&&(this.range=t.range),t.detectionRange&&(this.detectionRange=t.detectionRange),void 0!==t.ignoreNotIntersectedRays&&(this.ignoreNotIntersectedRays=1==t.ignoreNotIntersectedRays),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this},setRay:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Phaser.Math.MAX_SAFE_INTEGER;return this.origin.setTo(t,e),this.angle=i,this.range=n,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this},setOrigin:function(t,e){return this.origin.setTo(t,e),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this},setRange:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Phaser.Math.MAX_SAFE_INTEGER;return this.range=t,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this},setAngle:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=t,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this},setAngleDeg:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.DegToRad(t),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this},setDetectionRange:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.detectionRange=t,this.rangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this},boundsInRange:function(t){var e,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return!this.detectionRange||(e=i||t.getBounds(),!!Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle,e))},cast:function(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=Phaser.Math.MAX_SAFE_INTEGER;if(this._raycaster&&this._raycaster.boundingBox){var n=[];if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,this._raycaster.boundingBox.rectangle,n),1===n.length)t=n[0];else if(n.length>1){var s=!0,o=!1,r=void 0;try{for(var a,h=n[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value,g=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,c.x,c.y);g<i&&(i=g,t=c)}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}}else i=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.target.x,e.target.y),t=e.target}if(!e.objects){if(!this._raycaster)return intersections;e.objects=this._raycaster.mappedObjects}var u=!0,l=!1,y=void 0;try{for(var p,d=e.objects[Symbol.iterator]();!(u=(p=d.next()).done);u=!0){var f=p.value;if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,f.getBounds())){var b=f.data.get("raycasterMap"),m=!0,v=!1,P=void 0;try{for(var x,j=b.getSegments()[Symbol.iterator]();!(m=(x=j.next()).done);m=!0){var G=x.value,_=[];if(e.target){if(Phaser.Geom.Point.Equals(e.target,G.getPointA())||Phaser.Geom.Point.Equals(e.target,G.getPointB()))_=e.target;else if(!Phaser.Geom.Intersects.LineToLine(this._ray,G,_))continue}else if(!Phaser.Geom.Intersects.LineToLine(this._ray,G,_))continue;var w=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,_.x,_.y);w<i&&(i=w,t=_)}}catch(t){v=!0,P=t}finally{try{m||null==j.return||j.return()}finally{if(v)throw P}}if("Arc"===b.type){if(b._points.length>0)continue;if(e.target){var L=b.getPoints(this),S=!1,M=!0,R=!1,B=void 0;try{for(var A,T=L[Symbol.iterator]();!(M=(A=T.next()).done);M=!0){var O=A.value;if(Phaser.Geom.Point.Equals(e.target,O)){var C=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,O.x,O.y);if(C<i){i=C,t=O,S=!0;break}}}}catch(t){R=!0,B=t}finally{try{M||null==T.return||T.return()}finally{if(R)throw B}}if(S)continue}var X=[],I=new Phaser.Geom.Point;I.x=b.object.x-b.object.displayWidth*(b.object.originX-.5),I.y=b.object.y-b.object.displayHeight*(b.object.originY-.5);var E=b.object.rotation;if(0!==E){var Y=new Phaser.Geom.Line(b.object.x,b.object.y,I.x,I.y);Phaser.Geom.Line.SetToAngle(Y,b.object.x,b.object.y,Phaser.Geom.Line.Angle(Y)+E,Phaser.Geom.Line.Length(Y));var D=Y.getPointB();I.x=D.x,I.y=D.y}var N=new Phaser.Geom.Circle(I.x,I.y,b.object.radius*b.object.scaleX);if(Phaser.Geom.Intersects.GetLineToCircle(this._ray,N,X)){var k=!0,q=!1,H=void 0;try{for(var W,F=X[Symbol.iterator]();!(k=(W=F.next()).done);k=!0){var U=W.value,z=Phaser.Math.Distance.Between(this._ray.x1,this._ray.y1,U.x,U.y);z<i&&(i=z,t=U)}}catch(t){q=!0,H=t}finally{try{k||null==F.return||F.return()}finally{if(q)throw H}}}}}}}catch(t){l=!0,y=t}finally{try{u||null==d.return||d.return()}finally{if(l)throw y}}return t?new Phaser.Geom.Point(t.x,t.y):!this.ignoreNotIntersectedRays&&this._ray.getPointB()},castCircle:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=[],i=[],n=[],s=[];if(!t.objects){if(!this._raycaster)return e;if(t.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var o=!0,r=!1,a=void 0;try{for(var h,c=this._raycaster.boundingBox.points[Symbol.iterator]();!(o=(h=c.next()).done);o=!0){var g=h.value;n.push({point:g,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,g.x,g.y)})}}catch(t){r=!0,a=t}finally{try{o||null==c.return||c.return()}finally{if(r)throw a}}}for(var u=0,l=t.objects.length;u<l;u++){var y=t.objects[u];if(this.boundsInRange(y)){s.push(y);var p=y.data.get("raycasterMap");i.push(p);var d=!0,f=!1,b=void 0;try{for(var m,v=p.getPoints(this)[Symbol.iterator]();!(d=(m=v.next()).done);d=!0){var P=m.value;n.push({point:P,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,P.x,P.y)})}}catch(t){f=!0,b=t}finally{try{d||null==v.return||v.return()}finally{if(f)throw b}}for(var x=u+1,j=t.objects.length;x<j;x++){var G=t.objects[x],_=G.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(y.getBounds(),G.getBounds())){var w=!0,L=!1,S=void 0;try{for(var M,R=p.getSegments()[Symbol.iterator]();!(w=(M=R.next()).done);w=!0){var B=M.value,A=!0,T=!1,O=void 0;try{for(var C,X=_.getSegments()[Symbol.iterator]();!(A=(C=X.next()).done);A=!0){var I=C.value,E=[];Phaser.Geom.Intersects.LineToLine(B,I,E)&&n.push({point:new Phaser.Geom.Point(E.x,E.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,E.x,E.y)})}}catch(t){T=!0,O=t}finally{try{A||null==X.return||X.return()}finally{if(T)throw O}}}}catch(t){L=!0,S=t}finally{try{w||null==R.return||R.return()}finally{if(L)throw S}}}}}}n.sort((function(t,e){return t.angle-e.angle}));var Y=!0,D=!1,N=void 0;try{for(var k,q=n[Symbol.iterator]();!(Y=(k=q.next()).done);Y=!0){var H=k.value;this.setAngle(H.angle);var W=this.cast({objects:s,target:H.point});if(W){if(Phaser.Geom.Point.Equals(H.point,W)){this.setAngle(H.angle-1e-4);var F=this.cast({objects:s});F&&e.push(F),e.push(W),this.setAngle(H.angle+1e-4);var U=this.cast({objects:s});U&&e.push(U);continue}e.push(W)}}}catch(t){D=!0,N=t}finally{try{Y||null==q.return||q.return()}finally{if(D)throw N}}}return e}}}])}));
//# sourceMappingURL=phaser-raycaster.min.js.map