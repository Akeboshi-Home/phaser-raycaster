!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("PhaserRaycaster",[],e):"object"==typeof exports?exports.PhaserRaycaster=e():t.PhaserRaycaster=e()}(window,(function(){return function(t){var e={};function n(i){if(e[i])return e[i].exports;var s=e[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)n.d(i,s,function(e){return t[e]}.bind(null,s));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=3)}([function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Phaser.Math.MAX_SAFE_INTEGER;return this.range=t,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.detectionRange=t,this.rangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}function o(t){var e,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return!this.detectionRange||(e=n||t.getBounds(),!!Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle,e))}n.r(e),n.d(e,"setRange",(function(){return i})),n.d(e,"setDetectionRange",(function(){return s})),n.d(e,"boundsInRange",(function(){return o}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.Angle.Normalize(t),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(t)),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this}n.r(e),n.d(e,"setAngle",(function(){return i})),n.d(e,"setAngleDeg",(function(){return s}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cone=t,this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cone=Phaser.Math.DegToRad(t),this}n.r(e),n.d(e,"setCone",(function(){return i})),n.d(e,"setConeDeg",(function(){return s}))},function(t,e,n){
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
var i=function(t){this.scene=t,this.systems=t.sys,t.sys.settings.isBooted||t.sys.events.once("boot",this.boot,this)};i.register=function(t){t.register("PhaserRaycaster",i,"base")},(i.prototype={boot:function(){var t=this.systems.events;t.on("start",this.start,this),t.on("preupdate",this.preUpdate,this),t.on("update",this.update,this),t.on("postupdate",this.postUpdate,this),t.on("pause",this.pause,this),t.on("resume",this.resume,this),t.on("sleep",this.sleep,this),t.on("wake",this.wake,this),t.on("shutdown",this.shutdown,this),t.on("destroy",this.destroy,this)},test:function(t){console.log("RaycasterPlugin says hello "+t+"!")},start:function(){},preUpdate:function(t,e){},update:function(t,e){},postUpdate:function(t,e){},pause:function(){},resume:function(){},sleep:function(){},wake:function(){},shutdown:function(){},destroy:function(){this.shutdown(),this.scene=void 0},createRaycaster:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.scene=this.scene,new this._Raycaster(t)}}).constructor=i,i.prototype._Raycaster=n(4).Raycaster,t.exports=i},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(t){return this.version="0.7.0",this.scene,this.graphics,this.boundingBox=!1,this.mappedObjects=[],this.sortedPoints=[],this.mapSegmentCount=0,void 0!==t&&(void 0===t.boundingBox&&void 0!==t.scene&&void 0!==t.scene.physics&&(t.boundingBox=t.scene.physics.world.bounds),this.setOptions(t)),this.scene.events.on("update",this.update.bind(this)),this}n.r(e),n.d(e,"Raycaster",(function(){return i})),i.prototype={setOptions:function(t){return void 0!==t.scene&&(this.scene=t.scene,this.graphics=this.scene.add.graphics({lineStyle:{width:1,color:65280},fillStyle:{color:16711935}})),void 0!==t.mapSegmentCount&&(this.mapSegmentCount=t.mapSegmentCount),void 0!==t.objects&&this.mapGameObjects(t.objects),void 0!==t.boundingBox&&this.setBoundingBox(t.boundingBox.x,t.boundingBox.y,t.boundingBox.width,t.boundingBox.height),this},setBoundingBox:function(t,e,n,i){this.boundingBox={rectangle:new Phaser.Geom.Rectangle(t,e,n,i),points:[],segments:[]};var s=[new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.bottom),new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.bottom)];this.boundingBox.points=s;for(var o=0,r=this.boundingBox.points.length;o<r;o++)o+1<r?this.boundingBox.segments.push(new Phaser.Geom.Line(s[o].x,s[o].y,s[o+1].x,s[o+1].y)):this.boundingBox.segments.push(new Phaser.Geom.Line(s[o].x,s[o].y,s[0].x,s[0].y))},mapGameObjects:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.mapSegmentCount;if(!Array.isArray(t)){if(this.mappedObjects.includes(t))return this;t.data||t.setDataEnabled();var i=new this.Map({object:t,dynamic:e,segmentCount:n},this.scene);return t.data.set("raycasterMap",i),this.mappedObjects.push(t),this}var s=!0,o=!1,r=void 0;try{for(var a,h=t[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value;if(!this.mappedObjects.includes(c)){c.data||c.setDataEnabled();var g=new this.Map({object:c,dynamic:e,segmentCount:n});c.data.set("raycasterMap",g),this.mappedObjects.push(c)}}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}return this},removeMappedObjects:function(t){if(!Array.isArray(t)){var e=this.mappedObjects.indexOf(t);return e>=0&&this.mappedObjects.splice(e,1),this}var n=!0,i=!1,s=void 0;try{for(var o,r=t[Symbol.iterator]();!(n=(o=r.next()).done);n=!0){var a=o.value,h=this.mappedObjects.indexOf(a);h>=0&&this.mappedObjects.splice(h,1)}}catch(t){i=!0,s=t}finally{try{n||null==r.return||r.return()}finally{if(i)throw s}}return this},update:function(){if(this.mappedObjects.length>0){var t=!0,e=!1,n=void 0;try{for(var i,s=this.mappedObjects[Symbol.iterator]();!(t=(i=s.next()).done);t=!0){var o=i.value;if(void 0!==o.data){var r=o.data.get("raycasterMap");r.dynamic&&r.updateMap()}}}catch(t){e=!0,n=t}finally{try{t||null==s.return||s.return()}finally{if(e)throw n}}}},createRay:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new this.Ray(t,this)}},i.prototype.Map=n(5).Map,i.prototype.Ray=n(12).Ray},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(t,e){return this.type,this.active,this.dynamic,this._object,this._points=[],this._segments=[],this.getPoints,this.getSegments,this.getIntersections,this.segmentCount=0,this.config(t),this.updateMap(),this}n.r(e),n.d(e,"Map",(function(){return i}));var s=n(6),o=n(7),r=n(8),a=n(9);i.prototype={config:n(10).config,setSegmentCount:n(11).setSegmentCount,_getRectanglePoints:s.getPoints,_getRectangleSegments:s.getSegments,_updateRectangleMap:s.updateMap,_getLinePoints:o.getPoints,_getLineSegments:o.getSegments,_updateLineMap:o.updateMap,_getPolygonPoints:r.getPoints,_getPolygonSegments:r.getSegments,_updatePolygonMap:r.updateMap,_getArcPoints:a.getPoints,_getArcSegments:a.getSegments,_updateArcMap:a.updateMap}},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){for(var t,e=[],n=0,i=(t=[this.object.getTopLeft(),this.object.getTopRight(),this.object.getBottomRight(),this.object.getBottomLeft()]).length;n<i;n++)n+1<i?e.push(new Phaser.Geom.Line(t[n].x,t[n].y,t[n+1].x,t[n+1].y)):e.push(new Phaser.Geom.Line(t[n].x,t[n].y,t[0].x,t[0].y));return this._points=t,this._segments=e,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){var t=[],e=[],n=new Phaser.Geom.Point;n.x=this.object.x-this.object.displayWidth*this.object.originX,n.y=this.object.y-this.object.displayHeight*this.object.originY;var i=this.object.geom.getPointA(),s=this.object.geom.getPointB(),o=this.object.rotation;if(0!==o){var r=new Phaser.Geom.Line(this.object.x,this.object.y,i.x*this.object.scaleX+n.x,i.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(r,this.object.x,this.object.y,Phaser.Geom.Line.Angle(r)+o,Phaser.Geom.Line.Length(r)),i=r.getPointB();var a=new Phaser.Geom.Line(this.object.x,this.object.y,s.x*this.object.scaleX+n.x,s.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+o,Phaser.Geom.Line.Length(a)),s=a.getPointB(),t.push(new Phaser.Geom.Point(i.x,i.y)),t.push(new Phaser.Geom.Point(s.x,s.y)),e.push(new Phaser.Geom.Line(i.x,i.y,s.x,s.y))}else t.push(new Phaser.Geom.Point(i.x*this.object.scaleX+n.x,i.y*this.object.scaleY+n.y)),t.push(new Phaser.Geom.Point(s.x*this.object.scaleX+n.x,s.y*this.object.scaleY+n.y)),e.push(new Phaser.Geom.Line(i.x+n.x,i.y+n.y,s.x+n.x,s.y+n.y));return this._points=t,this._segments=e,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){var t=[],e=[],n=new Phaser.Geom.Point;n.x=this.object.x-this.object.displayWidth*this.object.originX,n.y=this.object.y-this.object.displayHeight*this.object.originY;var i=this.object.rotation;if(0!==i){var s=!0,o=!1,r=void 0;try{for(var a,h=this.object.geom.points[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value,g=new Phaser.Geom.Line(this.object.x,this.object.y,c.x*this.object.scaleX+n.x,c.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(g,this.object.x,this.object.y,Phaser.Geom.Line.Angle(g)+i,Phaser.Geom.Line.Length(g)),t.push(g.getPointB())}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}}else{var u=!0,l=!1,y=void 0;try{for(var d,f=this.object.geom.points[Symbol.iterator]();!(u=(d=f.next()).done);u=!0){var p=d.value;t.push(new Phaser.Geom.Point(p.x*this.object.scaleX+n.x,p.y*this.object.scaleY+n.y))}}catch(t){l=!0,y=t}finally{try{u||null==f.return||f.return()}finally{if(l)throw y}}}for(var b=0,m=t.length;b<m;b++)b+1<m&&e.push(new Phaser.Geom.Line(t[b].x,t[b].y,t[b+1].x,t[b+1].y));if(this.object.closePath){var v=t.length-1;e.push(new Phaser.Geom.Line(t[v].x,t[v].y,t[0].x,t[0].y))}return this._points=t,this._segments=e,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this._points.length>0)return this._points;var e=[],n=new Phaser.Geom.Point;if(n.x=this.object.x-this.object.displayWidth*(this.object.originX-.5),n.y=this.object.y-this.object.displayHeight*(this.object.originY-.5),t){var i,s=new Phaser.Geom.Line,o=new Phaser.Geom.Line,r=this.object.rotation;if(0!==r){var a=new Phaser.Geom.Line(this.object.x,this.object.y,n.x,n.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+r,Phaser.Geom.Line.Length(a));var h=a.getPointB();i=new Phaser.Geom.Line(t.origin.x,t.origin.y,h.x,h.y)}else i=new Phaser.Geom.Line(t.origin.x,t.origin.y,n.x,n.y);var c=Math.sqrt(Math.pow(Phaser.Geom.Line.Length(i),2)-Math.pow(this.object.radius*this.object.scaleX,2)),g=Phaser.Geom.Line.Angle(i),u=Math.asin(this.object.radius*this.object.scaleX/Phaser.Geom.Line.Length(i));Phaser.Geom.Line.SetToAngle(s,t.origin.x,t.origin.y,g-u,c),Phaser.Geom.Line.SetToAngle(o,t.origin.x,t.origin.y,g+u,c),e.push(s.getPointB()),e.push(o.getPointB())}return e}function s(){return this._segments}function o(){if(!this.segmentCount)return this._points=[],this._segments=[],this;var t=new Phaser.Geom.Point;t.x=this.object.x-this.object.displayWidth*this.object.originX+this.object.radius*this.object.scaleX,t.y=this.object.y-this.object.displayHeight*this.object.originY+this.object.radius*this.object.scaleY;var e=this.object.geom.getPoints(this.segmentCount),n=[],i=this.object.rotation;if(0!==i){var s=[],o=!0,r=!1,a=void 0;try{for(var h,c=e[Symbol.iterator]();!(o=(h=c.next()).done);o=!0){var g=h.value,u=new Phaser.Geom.Line(this.object.x,this.object.y,this.object.x+(g.x+this.object.radius)*this.object.scaleX,this.object.y+(g.y+this.object.radius)*this.object.scaleY);Phaser.Geom.Line.SetToAngle(u,this.object.x,this.object.y,Phaser.Geom.Line.Angle(u)+i,Phaser.Geom.Line.Length(u)),s.push(u.getPointB())}}catch(t){r=!0,a=t}finally{try{o||null==c.return||c.return()}finally{if(r)throw a}}e=s}else{var l=!0,y=!1,d=void 0;try{for(var f,p=e[Symbol.iterator]();!(l=(f=p.next()).done);l=!0){var b=f.value;b.x=b.x*this.object.scaleX+t.x,b.y=b.y*this.object.scaleY+t.y}}catch(t){y=!0,d=t}finally{try{l||null==p.return||p.return()}finally{if(y)throw d}}}for(var m=0,v=e.length;m<v;m++)m+1<v?n.push(new Phaser.Geom.Line(e[m].x,e[m].y,e[m+1].x,e[m+1].y)):n.push(new Phaser.Geom.Line(e[m].x,e[m].y,e[0].x,e[0].y));return this._points=e,this._segments=n,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";function i(t){switch(this.object=t.object,void 0===t.type&&(t.type=t.object.type),this.type=t.type,t.type){case"Polygon":this.getPoints=this._getPolygonPoints,this.getSegments=this._getPolygonSegments,this.updateMap=this._updatePolygonMap;break;case"Arc":this.getPoints=this._getArcPoints,this.getSegments=this._getArcSegments,this.updateMap=this._updateArcMap;break;case"Line":this.getPoints=this._getLinePoints,this.getSegments=this._getLineSegments,this.updateMap=this._updateLineMap;break;default:this.getPoints=this._getRectanglePoints,this.getSegments=this._getRectangleSegments,this.updateMap=this._updateRectangleMap}return this.dynamic=1==t.dynamic,this.segmentCount=t.segmentCount?t.segmentCount:0,this}n.r(e),n.d(e,"config",(function(){return i}))},function(t,e,n){"use strict";function i(t){return this.segmentCount=t,this.updateMap(),this}n.r(e),n.d(e,"setSegmentCount",(function(){return i}))},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(t,e){this.origin=new Phaser.Geom.Point,this._ray=new Phaser.Geom.Line,this.angle=0,this.cone=0,this.range=Phaser.Math.MAX_SAFE_INTEGER,this.detectionRange=0,this.detectionRangeCircle=new Phaser.Geom.Circle,this.ignoreNotIntersectedRays=!0,this.intersections=[],this._raycaster=e||!1,this.config(t)}n.r(e),n.d(e,"Ray",(function(){return i})),i.prototype={config:n(13).config,setRay:n(14).setRay,setOrigin:n(15).setOrigin,setRange:n(0).setRange,setAngle:n(1).setAngle,setAngleDeg:n(1).setAngleDeg,setCone:n(2).setCone,setConeDeg:n(2).setConeDeg,setDetectionRange:n(0).setDetectionRange,boundsInRange:n(0).boundsInRange,cast:n(16).cast,castCircle:n(17).castCircle,castCone:n(18).castCone}},function(t,e,n){"use strict";function i(t){return this.object=t.object,t.origin&&this.origin.setTo(t.origin.x,t.origin.y),t.angle&&(this.angle=Phaser.Math.Angle.Normalize(t.angle)),t.angleDeg&&(this.angle=Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(t.angleDeg))),t.cone&&(this.cone=t.cone),t.coneDeg&&(this.cone=Phaser.Math.DegToRad(t.coneDeg)),t.range&&(this.range=t.range),t.detectionRange&&(this.detectionRange=t.detectionRange),void 0!==t.ignoreNotIntersectedRays&&(this.ignoreNotIntersectedRays=1==t.ignoreNotIntersectedRays),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}n.r(e),n.d(e,"config",(function(){return i}))},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Phaser.Math.MAX_SAFE_INTEGER;return this.origin.setTo(t,e),this.angle=Phaser.Math.Angle.Normalize(n),this.range=i,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}n.r(e),n.d(e,"setRay",(function(){return i}))},function(t,e,n){"use strict";function i(t,e){return this.origin.setTo(t,e),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}n.r(e),n.d(e,"setOrigin",(function(){return i}))},function(t,e,n){"use strict";function i(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Phaser.Math.MAX_SAFE_INTEGER;if(this._raycaster&&this._raycaster.boundingBox){var i=[];if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,this._raycaster.boundingBox.rectangle,i),1===i.length)t=i[0];else if(i.length>1){var s=!0,o=!1,r=void 0;try{for(var a,h=i[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value,g=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,c.x,c.y);g<n&&(n=g,t=c)}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}}else n=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.target.x,e.target.y),t=e.target}if(!e.objects){if(!this._raycaster)return intersections;e.objects=this._raycaster.mappedObjects}var u=!0,l=!1,y=void 0;try{for(var d,f=e.objects[Symbol.iterator]();!(u=(d=f.next()).done);u=!0){var p=d.value;if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,p.getBounds())){var b=p.data.get("raycasterMap"),m=!0,v=!1,P=void 0;try{for(var x,j=b.getSegments()[Symbol.iterator]();!(m=(x=j.next()).done);m=!0){var w=x.value,M=[];if(e.target){if(Phaser.Geom.Point.Equals(e.target,w.getPointA())||Phaser.Geom.Point.Equals(e.target,w.getPointB()))M=e.target;else if(!Phaser.Geom.Intersects.LineToLine(this._ray,w,M))continue}else if(!Phaser.Geom.Intersects.LineToLine(this._ray,w,M))continue;var _=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,M.x,M.y);_<n&&(n=_,t=M)}}catch(t){v=!0,P=t}finally{try{m||null==j.return||j.return()}finally{if(v)throw P}}if("Arc"===b.type){if(b._points.length>0)continue;if(e.target){var G=b.getPoints(this),R=!1,S=!0,L=!1,A=void 0;try{for(var B,T=G[Symbol.iterator]();!(S=(B=T.next()).done);S=!0){var D=B.value;if(Phaser.Geom.Point.Equals(e.target,D)){var C=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,D.x,D.y);if(C<n){n=C,t=D,R=!0;break}}}}catch(t){L=!0,A=t}finally{try{S||null==T.return||T.return()}finally{if(L)throw A}}if(R)continue}var O=[],I=new Phaser.Geom.Point;I.x=b.object.x-b.object.displayWidth*(b.object.originX-.5),I.y=b.object.y-b.object.displayHeight*(b.object.originY-.5);var X=b.object.rotation;if(0!==X){var E=new Phaser.Geom.Line(b.object.x,b.object.y,I.x,I.y);Phaser.Geom.Line.SetToAngle(E,b.object.x,b.object.y,Phaser.Geom.Line.Angle(E)+X,Phaser.Geom.Line.Length(E));var N=E.getPointB();I.x=N.x,I.y=N.y}var Y=new Phaser.Geom.Circle(I.x,I.y,b.object.radius*b.object.scaleX);if(Phaser.Geom.Intersects.GetLineToCircle(this._ray,Y,O)){var k=!0,q=!1,z=void 0;try{for(var H,W=O[Symbol.iterator]();!(k=(H=W.next()).done);k=!0){var F=H.value,U=Phaser.Math.Distance.Between(this._ray.x1,this._ray.y1,F.x,F.y);U<n&&(n=U,t=F)}}catch(t){q=!0,z=t}finally{try{k||null==W.return||W.return()}finally{if(q)throw z}}}}}}}catch(t){l=!0,y=t}finally{try{u||null==f.return||f.return()}finally{if(l)throw y}}return t?new Phaser.Geom.Point(t.x,t.y):!this.ignoreNotIntersectedRays&&this._ray.getPointB()}n.r(e),n.d(e,"cast",(function(){return i}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=this.angle,n=[],i=[],s=[],o=[];if(!t.objects){if(!this._raycaster)return n;if(t.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var r=!0,a=!1,h=void 0;try{for(var c,g=this._raycaster.boundingBox.points[Symbol.iterator]();!(r=(c=g.next()).done);r=!0){var u=c.value;s.push({point:u,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,u.x,u.y)})}}catch(t){a=!0,h=t}finally{try{r||null==g.return||g.return()}finally{if(a)throw h}}}for(var l=0,y=t.objects.length;l<y;l++){var d=t.objects[l];if(this.boundsInRange(d)){o.push(d);var f=d.data.get("raycasterMap");i.push(f);var p=!0,b=!1,m=void 0;try{for(var v,P=f.getPoints(this)[Symbol.iterator]();!(p=(v=P.next()).done);p=!0){var x=v.value;s.push({point:x,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,x.x,x.y)})}}catch(t){b=!0,m=t}finally{try{p||null==P.return||P.return()}finally{if(b)throw m}}for(var j=l+1,w=t.objects.length;j<w;j++){var M=t.objects[j],_=M.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(d.getBounds(),M.getBounds())){var G=!0,R=!1,S=void 0;try{for(var L,A=f.getSegments()[Symbol.iterator]();!(G=(L=A.next()).done);G=!0){var B=L.value,T=!0,D=!1,C=void 0;try{for(var O,I=_.getSegments()[Symbol.iterator]();!(T=(O=I.next()).done);T=!0){var X=O.value,E=[];Phaser.Geom.Intersects.LineToLine(B,X,E)&&s.push({point:new Phaser.Geom.Point(E.x,E.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,E.x,E.y)})}}catch(t){D=!0,C=t}finally{try{T||null==I.return||I.return()}finally{if(D)throw C}}}}catch(t){R=!0,S=t}finally{try{G||null==A.return||A.return()}finally{if(R)throw S}}}}}}s.sort(function(t,e){return t.angle==e.angle?Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.point.x,t.point.y)<Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.point.x,e.point.y)?1:-1:t.angle-e.angle}.bind(this));var N=!0,Y=!1,k=void 0;try{for(var q,z=s[Symbol.iterator]();!(N=(q=z.next()).done);N=!0){var H=q.value;this.setAngle(H.angle);var W=this.cast({objects:o,target:H.point});if(W){if(Phaser.Geom.Point.Equals(H.point,W)){this.setAngle(H.angle-1e-4);var F=this.cast({objects:o});F&&n.push(F),n.push(W),this.setAngle(H.angle+1e-4);var U=this.cast({objects:o});U&&n.push(U);continue}n.push(W)}}}catch(t){Y=!0,k=t}finally{try{N||null==z.return||z.return()}finally{if(Y)throw k}}}return this.setAngle(e),n}n.r(e),n.d(e,"castCircle",(function(){return i}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=this.angle,n=[],i=[],s=[],o=[],r=this.cone,a=0,h=0;if(void 0!==t.cone&&(r=t.cone),void 0!==t.coneDeg&&(r=Phaser.Math.DegToRad(t.coneDeg)),a=this.angle-r/2,h=this.angle+r/2,this.setAngle(a),s.push({point:this._ray.getPointB(),angle:a,angleOffsetDeg:Phaser.Math.RadToDeg(-r/2)}),this.setAngle(h),s.push({point:this._ray.getPointB(),angle:h,angleOffsetDeg:Phaser.Math.RadToDeg(r/2)}),!t.objects){if(!this._raycaster)return n;if(t.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var c=!0,g=!1,u=void 0;try{for(var l,y=this._raycaster.boundingBox.points[Symbol.iterator]();!(c=(l=y.next()).done);c=!0){var d=l.value,f=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,d.x,d.y),p=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(f),Phaser.Math.RadToDeg(e));Math.abs(p)<Phaser.Math.RadToDeg(r/2)&&s.push({point:d,angle:f,angleOffsetDeg:-p})}}catch(t){g=!0,u=t}finally{try{c||null==y.return||y.return()}finally{if(g)throw u}}}}for(var b=0,m=t.objects.length;b<m;b++){var v=t.objects[b];if(this.boundsInRange(v)){o.push(v);var P=v.data.get("raycasterMap");i.push(P);var x=!0,j=!1,w=void 0;try{for(var M,_=P.getPoints(this)[Symbol.iterator]();!(x=(M=_.next()).done);x=!0){var G=M.value,R=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,G.x,G.y),S=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(R),Phaser.Math.RadToDeg(e));Math.abs(S)<Phaser.Math.RadToDeg(r/2)&&s.push({point:G,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,G.x,G.y),angleOffsetDeg:-S})}}catch(t){j=!0,w=t}finally{try{x||null==_.return||_.return()}finally{if(j)throw w}}for(var L=b+1,A=t.objects.length;L<A;L++){var B=t.objects[L],T=B.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(v.getBounds(),B.getBounds())){var D=!0,C=!1,O=void 0;try{for(var I,X=P.getSegments()[Symbol.iterator]();!(D=(I=X.next()).done);D=!0){var E=I.value,N=!0,Y=!1,k=void 0;try{for(var q,z=T.getSegments()[Symbol.iterator]();!(N=(q=z.next()).done);N=!0){var H=q.value,W=[];if(Phaser.Geom.Intersects.LineToLine(E,H,W)){var F=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,W.x,W.y),U=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(F),Phaser.Math.RadToDeg(e));Math.abs(U)<Phaser.Math.RadToDeg(r/2)&&s.push({point:new Phaser.Geom.Point(W.x,W.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,W.x,W.y),angleOffsetDeg:-U})}}}catch(t){Y=!0,k=t}finally{try{N||null==z.return||z.return()}finally{if(Y)throw k}}}}catch(t){C=!0,O=t}finally{try{D||null==X.return||X.return()}finally{if(C)throw O}}}}}}s.sort(function(t,e){return t.angle==e.angle?Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.point.x,t.point.y)<Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.point.x,e.point.y)?1:-1:t.angleOffsetDeg-e.angleOffsetDeg}.bind(this));for(var J=0,K=s;J<K.length;J++){var Q=K[J];this.setAngle(Q.angle);var V=this.cast({objects:o,target:Q.point});if(V){if(Phaser.Geom.Point.Equals(Q.point,V)){this.setAngle(Q.angle-1e-4);var Z=this.cast({objects:o});Z&&n.push(Z),n.push(V),this.setAngle(Q.angle+1e-4);var $=this.cast({objects:o});$&&n.push($);continue}n.push(V)}}return this.setAngle(e),n}n.r(e),n.d(e,"castCone",(function(){return i}))}])}));
//# sourceMappingURL=phaser-raycaster.min.js.map