!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("PhaserRaycaster",[],e):"object"==typeof exports?exports.PhaserRaycaster=e():t.PhaserRaycaster=e()}(window,(function(){return function(t){var e={};function n(i){if(e[i])return e[i].exports;var s=e[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)n.d(i,s,function(e){return t[e]}.bind(null,s));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=3)}([function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Phaser.Math.MAX_SAFE_INTEGER;return this.range=t,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.detectionRange=t,this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}function o(t){var e,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return!this.detectionRange||(e=n||t.getBounds(),!!Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle,e))}n.r(e),n.d(e,"setRange",(function(){return i})),n.d(e,"setDetectionRange",(function(){return s})),n.d(e,"boundsInRange",(function(){return o}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.Angle.Normalize(t),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(t)),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this}n.r(e),n.d(e,"setAngle",(function(){return i})),n.d(e,"setAngleDeg",(function(){return s}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cone=t,this}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cone=Phaser.Math.DegToRad(t),this}n.r(e),n.d(e,"setCone",(function(){return i})),n.d(e,"setConeDeg",(function(){return s}))},function(t,e,n){var i=function(t){this.scene=t,this.systems=t.sys,t.sys.settings.isBooted||t.sys.events.once("boot",this.boot,this)};i.register=function(t){t.register("PhaserRaycaster",i,"base")},(i.prototype={boot:function(){var t=this.systems.events;t.on("start",this.start,this),t.on("preupdate",this.preUpdate,this),t.on("update",this.update,this),t.on("postupdate",this.postUpdate,this),t.on("pause",this.pause,this),t.on("resume",this.resume,this),t.on("sleep",this.sleep,this),t.on("wake",this.wake,this),t.on("shutdown",this.shutdown,this),t.on("destroy",this.destroy,this)},test:function(t){console.log("RaycasterPlugin says hello "+t+"!")},start:function(){},preUpdate:function(t,e){},update:function(t,e){},postUpdate:function(t,e){},pause:function(){},resume:function(){},sleep:function(){},wake:function(){},shutdown:function(){},destroy:function(){this.shutdown(),this.scene=void 0},createRaycaster:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.scene=this.scene,new this._Raycaster(t)}}).constructor=i,i.prototype._Raycaster=n(4).Raycaster,t.exports=i},function(t,e,n){"use strict";
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
function i(t){return this.version="0.7.1",this.scene,this.graphics,this.boundingBox=!1,this.mappedObjects=[],this.sortedPoints=[],this.mapSegmentCount=0,void 0!==t?(void 0===t.boundingBox&&void 0!==t.scene&&void 0!==t.scene.physics&&(t.boundingBox=t.scene.physics.world.bounds),this.setOptions(t),(void 0===t.autoUpdate||t.autoUpdate)&&this.scene.events.on("update",this.update.bind(this))):this.scene.events.on("update",this.update.bind(this)),this}n.r(e),n.d(e,"Raycaster",(function(){return i})),i.prototype={setOptions:function(t){return void 0!==t.scene&&(this.scene=t.scene,this.graphics=this.scene.add.graphics({lineStyle:{width:1,color:65280},fillStyle:{color:16711935}})),void 0!==t.mapSegmentCount&&(this.mapSegmentCount=t.mapSegmentCount),void 0!==t.objects&&this.mapGameObjects(t.objects),void 0!==t.boundingBox&&this.setBoundingBox(t.boundingBox.x,t.boundingBox.y,t.boundingBox.width,t.boundingBox.height),this},setBoundingBox:function(t,e,n,i){this.boundingBox={rectangle:new Phaser.Geom.Rectangle(t,e,n,i),points:[],segments:[]};var s=[new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.bottom),new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.bottom)];this.boundingBox.points=s;for(var o=0,r=this.boundingBox.points.length;o<r;o++)o+1<r?this.boundingBox.segments.push(new Phaser.Geom.Line(s[o].x,s[o].y,s[o+1].x,s[o+1].y)):this.boundingBox.segments.push(new Phaser.Geom.Line(s[o].x,s[o].y,s[0].x,s[0].y))},mapGameObjects:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.mapSegmentCount;if(!Array.isArray(t)){if(this.mappedObjects.includes(t))return this;t.data||t.setDataEnabled();var i=new this.Map({object:t,dynamic:e,segmentCount:n});return t.data.set("raycasterMap",i),this.mappedObjects.push(t),this}var s=!0,o=!1,r=void 0;try{for(var a,h=t[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value;if(!this.mappedObjects.includes(c)){c.data||c.setDataEnabled();var g=new this.Map({object:c,dynamic:e,segmentCount:n});c.data.set("raycasterMap",g),this.mappedObjects.push(c)}}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}return this},removeMappedObjects:function(t){if(!Array.isArray(t)){var e=this.mappedObjects.indexOf(t);return e>=0&&this.mappedObjects.splice(e,1),this}var n=!0,i=!1,s=void 0;try{for(var o,r=t[Symbol.iterator]();!(n=(o=r.next()).done);n=!0){var a=o.value,h=this.mappedObjects.indexOf(a);h>=0&&this.mappedObjects.splice(h,1)}}catch(t){i=!0,s=t}finally{try{n||null==r.return||r.return()}finally{if(i)throw s}}return this},update:function(){if(this.mappedObjects.length>0){var t=!0,e=!1,n=void 0;try{for(var i,s=this.mappedObjects[Symbol.iterator]();!(t=(i=s.next()).done);t=!0){var o=i.value;if(void 0!==o.data){var r=o.data.get("raycasterMap");r.dynamic&&r.updateMap()}}}catch(t){e=!0,n=t}finally{try{t||null==s.return||s.return()}finally{if(e)throw n}}}},createRay:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new this.Ray(t,this)}},i.prototype.Map=n(5).Map,i.prototype.Ray=n(13).Ray},function(t,e,n){"use strict";function i(t){return this.type,this.active,this.dynamic,this.object,this._points=[],this._segments=[],this.getPoints,this.getSegments,this.getIntersections,this.segmentCount=0,this.config(t),this.updateMap(),this}n.r(e),n.d(e,"Map",(function(){return i}));var s=n(6),o=n(7),r=n(8),a=n(9),h=n(10);i.prototype={config:n(11).config,setSegmentCount:n(12).setSegmentCount,_getRectanglePoints:s.getPoints,_getRectangleSegments:s.getSegments,_updateRectangleMap:s.updateMap,_getLinePoints:o.getPoints,_getLineSegments:o.getSegments,_updateLineMap:o.updateMap,_getPolygonPoints:r.getPoints,_getPolygonSegments:r.getSegments,_updatePolygonMap:r.updateMap,_getArcPoints:a.getPoints,_getArcSegments:a.getSegments,_updateArcMap:a.updateMap,_getContainerPoints:h.getPoints,_getContainerSegments:h.getSegments,_updateContainerMap:h.updateMap},i.prototype.constructor=i},function(t,e,n){"use strict";function i(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){for(var t,e=[],n=0,i=(t=[this.object.getTopLeft(),this.object.getTopRight(),this.object.getBottomRight(),this.object.getBottomLeft()]).length;n<i;n++)n+1<i?e.push(new Phaser.Geom.Line(t[n].x,t[n].y,t[n+1].x,t[n+1].y)):e.push(new Phaser.Geom.Line(t[n].x,t[n].y,t[0].x,t[0].y));return this._points=t,this._segments=e,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";function i(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){var t=[],e=[],n=new Phaser.Geom.Point;n.x=this.object.x-this.object.displayWidth*this.object.originX,n.y=this.object.y-this.object.displayHeight*this.object.originY;var i=this.object.geom.getPointA(),s=this.object.geom.getPointB(),o=this.object.rotation;if(0!==o){var r=new Phaser.Geom.Line(this.object.x,this.object.y,i.x*this.object.scaleX+n.x,i.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(r,this.object.x,this.object.y,Phaser.Geom.Line.Angle(r)+o,Phaser.Geom.Line.Length(r)),i=r.getPointB();var a=new Phaser.Geom.Line(this.object.x,this.object.y,s.x*this.object.scaleX+n.x,s.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+o,Phaser.Geom.Line.Length(a)),s=a.getPointB(),t.push(new Phaser.Geom.Point(i.x,i.y)),t.push(new Phaser.Geom.Point(s.x,s.y)),e.push(new Phaser.Geom.Line(i.x,i.y,s.x,s.y))}else t.push(new Phaser.Geom.Point(i.x*this.object.scaleX+n.x,i.y*this.object.scaleY+n.y)),t.push(new Phaser.Geom.Point(s.x*this.object.scaleX+n.x,s.y*this.object.scaleY+n.y)),e.push(new Phaser.Geom.Line(i.x*this.object.scaleX+n.x,i.y*this.object.scaleY+n.y,s.x+n.x*this.object.scaleX,s.y*this.object.scaleY+n.y));return this._points=t,this._segments=e,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";function i(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._points}function s(){return this._segments}function o(){var t=[],e=[],n=new Phaser.Geom.Point;n.x=this.object.x-this.object.displayWidth*this.object.originX,n.y=this.object.y-this.object.displayHeight*this.object.originY;var i=this.object.rotation;if(0!==i){var s=!0,o=!1,r=void 0;try{for(var a,h=this.object.geom.points[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value,g=new Phaser.Geom.Line(this.object.x,this.object.y,c.x*this.object.scaleX+n.x,c.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(g,this.object.x,this.object.y,Phaser.Geom.Line.Angle(g)+i,Phaser.Geom.Line.Length(g)),t.push(g.getPointB())}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}}else{var l=!0,u=!1,y=void 0;try{for(var d,f=this.object.geom.points[Symbol.iterator]();!(l=(d=f.next()).done);l=!0){var p=d.value;t.push(new Phaser.Geom.Point(p.x*this.object.scaleX+n.x,p.y*this.object.scaleY+n.y))}}catch(t){u=!0,y=t}finally{try{l||null==f.return||f.return()}finally{if(u)throw y}}}for(var b=0,P=t.length;b<P;b++)b+1<P&&e.push(new Phaser.Geom.Line(t[b].x,t[b].y,t[b+1].x,t[b+1].y));if(this.object.closePath){var m=t.length-1;e.push(new Phaser.Geom.Line(t[m].x,t[m].y,t[0].x,t[0].y))}return this._points=t,this._segments=e,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this._points.length>0)return this._points;var e=[],n=new Phaser.Geom.Point;if(n.x=this.object.x-this.object.displayWidth*(this.object.originX-.5),n.y=this.object.y-this.object.displayHeight*(this.object.originY-.5),t){var i,s=new Phaser.Geom.Line,o=new Phaser.Geom.Line,r=this.object.rotation;if(0!==r){var a=new Phaser.Geom.Line(this.object.x,this.object.y,n.x,n.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+r,Phaser.Geom.Line.Length(a));var h=a.getPointB();i=new Phaser.Geom.Line(t.origin.x,t.origin.y,h.x,h.y)}else i=new Phaser.Geom.Line(t.origin.x,t.origin.y,n.x,n.y);var c=Math.sqrt(Math.pow(Phaser.Geom.Line.Length(i),2)-Math.pow(this.object.radius*this.object.scaleX,2)),g=Phaser.Geom.Line.Angle(i),l=Math.asin(this.object.radius*this.object.scaleX/Phaser.Geom.Line.Length(i));Phaser.Geom.Line.SetToAngle(s,t.origin.x,t.origin.y,g-l,c),Phaser.Geom.Line.SetToAngle(o,t.origin.x,t.origin.y,g+l,c),e.push(s.getPointB()),e.push(o.getPointB())}return e}function s(){return this._segments}function o(){if(!this.segmentCount)return this._points=[],this._segments=[],this;var t=new Phaser.Geom.Point;t.x=this.object.x-this.object.displayWidth*this.object.originX+this.object.radius*this.object.scaleX,t.y=this.object.y-this.object.displayHeight*this.object.originY+this.object.radius*this.object.scaleY;var e=this.object.geom.getPoints(this.segmentCount),n=[],i=this.object.rotation;if(0!==i){var s=[],o=!0,r=!1,a=void 0;try{for(var h,c=e[Symbol.iterator]();!(o=(h=c.next()).done);o=!0){var g=h.value,l=new Phaser.Geom.Line(this.object.x,this.object.y,this.object.x+(g.x+this.object.radius)*this.object.scaleX,this.object.y+(g.y+this.object.radius)*this.object.scaleY);Phaser.Geom.Line.SetToAngle(l,this.object.x,this.object.y,Phaser.Geom.Line.Angle(l)+i,Phaser.Geom.Line.Length(l)),s.push(l.getPointB())}}catch(t){r=!0,a=t}finally{try{o||null==c.return||c.return()}finally{if(r)throw a}}e=s}else{var u=!0,y=!1,d=void 0;try{for(var f,p=e[Symbol.iterator]();!(u=(f=p.next()).done);u=!0){var b=f.value;b.x=b.x*this.object.scaleX+t.x,b.y=b.y*this.object.scaleY+t.y}}catch(t){y=!0,d=t}finally{try{u||null==p.return||p.return()}finally{if(y)throw d}}}for(var P=0,m=e.length;P<m;P++)P+1<m?n.push(new Phaser.Geom.Line(e[P].x,e[P].y,e[P+1].x,e[P+1].y)):n.push(new Phaser.Geom.Line(e[P].x,e[P].y,e[0].x,e[0].y));return this._points=e,this._segments=n,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=[];e||(n=this._points);var i=new Phaser.Geom.Point;if(i.x=this.object.x-this.object.displayWidth*this.object.originX,i.y=this.object.y-this.object.displayHeight*this.object.originY,t){var s=new Phaser.Geom.Line(0,0,t.origin.x-i.x,t.origin.y-i.y);Phaser.Geom.Line.SetToAngle(s,0,0,Phaser.Geom.Line.Angle(s)-this.object.rotation,Phaser.Geom.Line.Length(s));var o=t._raycaster.createRay({origin:{x:s.getPointB().x,y:s.getPointB().y}}),r=!0,a=!1,h=void 0;try{for(var c,g=this.object.list[Symbol.iterator]();!(r=(c=g.next()).done);r=!0){var l=c.value;if("Arc"===l.type){var u=l.data.get("raycasterMap");if(0==u._points.length){var y=!0,d=!1,f=void 0;try{for(var p,b=u.getPoints(o,!0)[Symbol.iterator]();!(y=(p=b.next()).done);y=!0){var P=p.value,m=new Phaser.Geom.Line(0,0,P.x,P.y);Phaser.Geom.Line.SetToAngle(m,0,0,Phaser.Geom.Line.Angle(m)+this.object.rotation,Phaser.Geom.Line.Length(m)),n.push(new Phaser.Geom.Point(m.getPointB().x+i.x,m.getPointB().y+i.y))}}catch(t){d=!0,f=t}finally{try{y||null==b.return||b.return()}finally{if(d)throw f}}}}else if("Container"===l.type){var v=!0,x=!1,j=void 0;try{for(var G,w=l.data.get("raycasterMap").getPoints(o,!0)[Symbol.iterator]();!(v=(G=w.next()).done);v=!0){var L=G.value;if(0!==this.object.rotation){var M=new Phaser.Geom.Line(this.object.x,this.object.y,L.x*this.object.scaleX+i.x,L.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(M,this.object.x,this.object.y,Phaser.Geom.Line.Angle(M)+this.object.rotation,Phaser.Geom.Line.Length(M)),n.push(M.getPointB())}else n.push(new Phaser.Geom.Point(L.x*this.object.scaleX+i.x,L.y*this.object.scaleX+i.y))}}catch(t){x=!0,j=t}finally{try{v||null==w.return||w.return()}finally{if(x)throw j}}}}}catch(t){a=!0,h=t}finally{try{r||null==g.return||g.return()}finally{if(a)throw h}}}return n}function s(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this._segments}function o(){var t=[],e=[],n=this.object,i=new Phaser.Geom.Point;i.x=this.object.x-this.object.displayWidth*this.object.originX,i.y=this.object.y-this.object.displayHeight*this.object.originY;var s=n.rotation;n.iterate(function(o){o.data||o.setDataEnabled();var r=o.data.get("raycasterMap");r?r.updateMap():(r=new this.constructor({object:o,segmentCount:this.segmentCount}),o.data.set("raycasterMap",r));var a=[],h=!0,c=!1,g=void 0;try{for(var l,u=r.getPoints()[Symbol.iterator]();!(h=(l=u.next()).done);h=!0){var y=l.value;if(0!==s){var d=new Phaser.Geom.Line(this.object.x,this.object.y,y.x*this.object.scaleX+i.x,y.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(d,this.object.x,this.object.y,Phaser.Geom.Line.Angle(d)+s,Phaser.Geom.Line.Length(d)),t.push(d.getPointB())}else t.push(new Phaser.Geom.Point(y.x*n.scaleX+i.x,y.y*n.scaleX+i.y));a.push(t[t.length-1])}}catch(t){c=!0,g=t}finally{try{h||null==u.return||u.return()}finally{if(c)throw g}}var f=!0,p=!1,b=void 0;try{for(var P,m=r.getSegments()[Symbol.iterator]();!(f=(P=m.next()).done);f=!0){var v=P.value;if(0!==s){var x=v.getPointA(),j=v.getPointB(),G=new Phaser.Geom.Line(this.object.x,this.object.y,x.x*this.object.scaleX+i.x,x.y*this.object.scaleY+i.y),w=new Phaser.Geom.Line(this.object.x,this.object.y,j.x*this.object.scaleX+i.x,j.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(G,this.object.x,this.object.y,Phaser.Geom.Line.Angle(G)+s,Phaser.Geom.Line.Length(G)),Phaser.Geom.Line.SetToAngle(w,this.object.x,this.object.y,Phaser.Geom.Line.Angle(w)+s,Phaser.Geom.Line.Length(w)),e.push(new Phaser.Geom.Line(G.getPointB().x,G.getPointB().y,w.getPointB().x,w.getPointB().y))}else e.push(new Phaser.Geom.Line(v.getPointA().x*n.scaleX+i.x,v.getPointA().y*n.scaleY+i.y,v.getPointB().x*n.scaleX+i.x,v.getPointB().y*n.scaleY+i.y))}}catch(t){p=!0,b=t}finally{try{f||null==m.return||m.return()}finally{if(p)throw b}}}.bind(this));for(var o=0,r=n.list.length;o<r;o++)for(var a=n.list[o],h=a.data.get("raycasterMap"),c=o+1,g=n.list.length;c<g;c++){var l=n.list[c],u=l.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(a.getBounds(),l.getBounds())){var y=!0,d=!1,f=void 0;try{for(var p,b=h.getSegments()[Symbol.iterator]();!(y=(p=b.next()).done);y=!0){var P=p.value,m=!0,v=!1,x=void 0;try{for(var j,G=u.getSegments()[Symbol.iterator]();!(m=(j=G.next()).done);m=!0){var w=j.value,L=[];if(Phaser.Geom.Intersects.LineToLine(P,w,L))if(0!==s){var M=new Phaser.Geom.Line(this.object.x,this.object.y,L.x*this.object.scaleX+i.x,L.y*this.object.scaleY+i.y);Phaser.Geom.Line.SetToAngle(M,this.object.x,this.object.y,Phaser.Geom.Line.Angle(M)+s,Phaser.Geom.Line.Length(M)),t.push(M.getPointB())}else t.push(new Phaser.Geom.Point(L.x*n.scaleX+i.x,L.y*n.scaleX+i.y))}}catch(t){v=!0,x=t}finally{try{m||null==G.return||G.return()}finally{if(v)throw x}}}}catch(t){d=!0,f=t}finally{try{y||null==b.return||b.return()}finally{if(d)throw f}}}}return this._points=t,this._segments=e,this}n.r(e),n.d(e,"getPoints",(function(){return i})),n.d(e,"getSegments",(function(){return s})),n.d(e,"updateMap",(function(){return o}))},function(t,e,n){"use strict";function i(t){switch(this.object=t.object,void 0===t.type&&(t.type=t.object.type),this.type=t.type,t.type){case"Polygon":this.getPoints=this._getPolygonPoints,this.getSegments=this._getPolygonSegments,this.updateMap=this._updatePolygonMap;break;case"Arc":this.getPoints=this._getArcPoints,this.getSegments=this._getArcSegments,this.updateMap=this._updateArcMap;break;case"Line":this.getPoints=this._getLinePoints,this.getSegments=this._getLineSegments,this.updateMap=this._updateLineMap;break;case"Container":this.getPoints=this._getContainerPoints,this.getSegments=this._getContainerSegments,this.updateMap=this._updateContainerMap;break;default:this.getPoints=this._getRectanglePoints,this.getSegments=this._getRectangleSegments,this.updateMap=this._updateRectangleMap}return this.dynamic=1==t.dynamic,this.segmentCount=t.segmentCount?t.segmentCount:0,this}n.r(e),n.d(e,"config",(function(){return i}))},function(t,e,n){"use strict";function i(t){return this.segmentCount=t,this.updateMap(),this}n.r(e),n.d(e,"setSegmentCount",(function(){return i}))},function(t,e,n){"use strict";function i(t,e){this.origin=new Phaser.Geom.Point,this._ray=new Phaser.Geom.Line,this.angle=0,this.cone=0,this.range=Phaser.Math.MAX_SAFE_INTEGER,this.detectionRange=0,this.detectionRangeCircle=new Phaser.Geom.Circle,this.ignoreNotIntersectedRays=!0,this.intersections=[],this._raycaster=e||!1,this.config(t)}n.r(e),n.d(e,"Ray",(function(){return i})),i.prototype={config:n(14).config,setRay:n(15).setRay,setOrigin:n(16).setOrigin,setRange:n(0).setRange,setAngle:n(1).setAngle,setAngleDeg:n(1).setAngleDeg,setCone:n(2).setCone,setConeDeg:n(2).setConeDeg,setDetectionRange:n(0).setDetectionRange,boundsInRange:n(0).boundsInRange,cast:n(17).cast,castCircle:n(18).castCircle,castCone:n(19).castCone}},function(t,e,n){"use strict";function i(t){return this.object=t.object,t.origin&&this.origin.setTo(t.origin.x,t.origin.y),t.angle&&(this.angle=Phaser.Math.Angle.Normalize(t.angle)),t.angleDeg&&(this.angle=Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(t.angleDeg))),t.cone&&(this.cone=t.cone),t.coneDeg&&(this.cone=Phaser.Math.DegToRad(t.coneDeg)),t.range&&(this.range=t.range),t.detectionRange&&(this.detectionRange=t.detectionRange),void 0!==t.ignoreNotIntersectedRays&&(this.ignoreNotIntersectedRays=1==t.ignoreNotIntersectedRays),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}n.r(e),n.d(e,"config",(function(){return i}))},function(t,e,n){"use strict";function i(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Phaser.Math.MAX_SAFE_INTEGER;return this.origin.setTo(t,e),this.angle=Phaser.Math.Angle.Normalize(n),this.range=i,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}n.r(e),n.d(e,"setRay",(function(){return i}))},function(t,e,n){"use strict";function i(t,e){return this.origin.setTo(t,e),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.range),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}n.r(e),n.d(e,"setOrigin",(function(){return i}))},function(t,e,n){"use strict";function i(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=this.range;if(this._raycaster&&this._raycaster.boundingBox){var i=[];if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,this._raycaster.boundingBox.rectangle,i),1===i.length)t=i[0];else if(i.length>1){var s=!0,o=!1,r=void 0;try{for(var a,h=i[Symbol.iterator]();!(s=(a=h.next()).done);s=!0){var c=a.value,g=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,c.x,c.y);g<n&&(n=g,t=c)}}catch(t){o=!0,r=t}finally{try{s||null==h.return||h.return()}finally{if(o)throw r}}}else if(e.target){var l=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.target.x,e.target.y);this.range>l&&(n=l,t=e.target)}}if(!e.objects){if(!this._raycaster)return intersections;e.objects=this._raycaster.mappedObjects}var u=!0,y=!1,d=void 0;try{for(var f,p=e.objects[Symbol.iterator]();!(u=(f=p.next()).done);u=!0){var b=f.value;if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,b.getBounds())){var P=b.data.get("raycasterMap"),m=!0,v=!1,x=void 0;try{for(var j,G=P.getSegments(this)[Symbol.iterator]();!(m=(j=G.next()).done);m=!0){var w=j.value,L=[];if(e.target){if(Phaser.Geom.Point.Equals(e.target,w.getPointA())||Phaser.Geom.Point.Equals(e.target,w.getPointB()))L=e.target;else if(!Phaser.Geom.Intersects.LineToLine(this._ray,w,L))continue}else if(!Phaser.Geom.Intersects.LineToLine(this._ray,w,L))continue;var M=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,L.x,L.y);M<n&&(n=M,t=L)}}catch(t){v=!0,x=t}finally{try{m||null==G.return||G.return()}finally{if(v)throw x}}if("Arc"===P.type){if(P._points.length>0)continue;if(e.target){var _=P.getPoints(this),S=!1,A=!0,B=!1,R=void 0;try{for(var T,D=_[Symbol.iterator]();!(A=(T=D.next()).done);A=!0){var C=T.value;if(Phaser.Geom.Point.Equals(e.target,C)){var O=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,C.x,C.y);if(O<n){n=O,t=C,S=!0;break}}}}catch(t){B=!0,R=t}finally{try{A||null==D.return||D.return()}finally{if(B)throw R}}if(S)continue}var X=[],I=new Phaser.Geom.Point;I.x=P.object.x-P.object.displayWidth*(P.object.originX-.5),I.y=P.object.y-P.object.displayHeight*(P.object.originY-.5);var Y=P.object.rotation;if(0!==Y){var E=new Phaser.Geom.Line(P.object.x,P.object.y,I.x,I.y);Phaser.Geom.Line.SetToAngle(E,P.object.x,P.object.y,Phaser.Geom.Line.Angle(E)+Y,Phaser.Geom.Line.Length(E));var N=E.getPointB();I.x=N.x,I.y=N.y}var k=new Phaser.Geom.Circle(I.x,I.y,P.object.radius*P.object.scaleX);if(Phaser.Geom.Intersects.GetLineToCircle(this._ray,k,X)){var H=!0,W=!1,q=void 0;try{for(var U,z=X[Symbol.iterator]();!(H=(U=z.next()).done);H=!0){var F=U.value,J=Phaser.Math.Distance.Between(this._ray.x1,this._ray.y1,F.x,F.y);J<n&&(n=J,t=F)}}catch(t){W=!0,q=t}finally{try{H||null==z.return||z.return()}finally{if(W)throw q}}}}}}}catch(t){y=!0,d=t}finally{try{u||null==p.return||p.return()}finally{if(y)throw d}}return t?new Phaser.Geom.Point(t.x,t.y):!this.ignoreNotIntersectedRays&&this._ray.getPointB()}n.r(e),n.d(e,"cast",(function(){return i}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=this.angle,n=[],i=[],s=[],o=[];if(!t.objects){if(!this._raycaster)return n;if(t.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var r=!0,a=!1,h=void 0;try{for(var c,g=this._raycaster.boundingBox.points[Symbol.iterator]();!(r=(c=g.next()).done);r=!0){var l=c.value;s.push({point:l,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,l.x,l.y)})}}catch(t){a=!0,h=t}finally{try{r||null==g.return||g.return()}finally{if(a)throw h}}}for(var u=0,y=t.objects.length;u<y;u++){var d=t.objects[u];if(this.boundsInRange(d)){o.push(d);var f=d.data.get("raycasterMap");i.push(f);var p=!0,b=!1,P=void 0;try{for(var m,v=f.getPoints(this)[Symbol.iterator]();!(p=(m=v.next()).done);p=!0){var x=m.value;s.push({point:x,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,x.x,x.y)})}}catch(t){b=!0,P=t}finally{try{p||null==v.return||v.return()}finally{if(b)throw P}}for(var j=u+1,G=t.objects.length;j<G;j++){var w=t.objects[j],L=w.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(d.getBounds(),w.getBounds())){var M=!0,_=!1,S=void 0;try{for(var A,B=f.getSegments(this)[Symbol.iterator]();!(M=(A=B.next()).done);M=!0){var R=A.value,T=!0,D=!1,C=void 0;try{for(var O,X=L.getSegments(this)[Symbol.iterator]();!(T=(O=X.next()).done);T=!0){var I=O.value,Y=[];Phaser.Geom.Intersects.LineToLine(R,I,Y)&&s.push({point:new Phaser.Geom.Point(Y.x,Y.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,Y.x,Y.y)})}}catch(t){D=!0,C=t}finally{try{T||null==X.return||X.return()}finally{if(D)throw C}}}}catch(t){_=!0,S=t}finally{try{M||null==B.return||B.return()}finally{if(_)throw S}}}}}}s.sort(function(t,e){return t.angle==e.angle?Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.point.x,t.point.y)<Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.point.x,e.point.y)?1:-1:t.angle-e.angle}.bind(this));var E=!0,N=!1,k=void 0;try{for(var H,W=s[Symbol.iterator]();!(E=(H=W.next()).done);E=!0){var q=H.value;this.setAngle(q.angle);var U=this.cast({objects:o,target:q.point});if(U){if(Phaser.Geom.Point.Equals(q.point,U)){this.setAngle(q.angle-1e-4);var z=this.cast({objects:o});z&&n.push(z),n.push(U),this.setAngle(q.angle+1e-4);var F=this.cast({objects:o});F&&n.push(F);continue}n.push(U)}}}catch(t){N=!0,k=t}finally{try{E||null==W.return||W.return()}finally{if(N)throw k}}}return this.setAngle(e),n}n.r(e),n.d(e,"castCircle",(function(){return i}))},function(t,e,n){"use strict";function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=this.angle,n=[],i=[],s=[],o=[],r=this.cone,a=0,h=0;if(void 0!==t.cone&&(r=t.cone),void 0!==t.coneDeg&&(r=Phaser.Math.DegToRad(t.coneDeg)),a=this.angle-r/2,h=this.angle+r/2,this.setAngle(a),s.push({point:this._ray.getPointB(),angle:a,angleOffsetDeg:Phaser.Math.RadToDeg(-r/2)}),this.setAngle(h),s.push({point:this._ray.getPointB(),angle:h,angleOffsetDeg:Phaser.Math.RadToDeg(r/2)}),!t.objects){if(!this._raycaster)return n;if(t.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var c=!0,g=!1,l=void 0;try{for(var u,y=this._raycaster.boundingBox.points[Symbol.iterator]();!(c=(u=y.next()).done);c=!0){var d=u.value,f=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,d.x,d.y),p=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(f),Phaser.Math.RadToDeg(e));Math.abs(p)<Phaser.Math.RadToDeg(r/2)&&s.push({point:d,angle:f,angleOffsetDeg:-p})}}catch(t){g=!0,l=t}finally{try{c||null==y.return||y.return()}finally{if(g)throw l}}}}for(var b=0,P=t.objects.length;b<P;b++){var m=t.objects[b];if(this.boundsInRange(m)){o.push(m);var v=m.data.get("raycasterMap");i.push(v);var x=!0,j=!1,G=void 0;try{for(var w,L=v.getPoints(this)[Symbol.iterator]();!(x=(w=L.next()).done);x=!0){var M=w.value,_=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,M.x,M.y),S=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(_),Phaser.Math.RadToDeg(e));Math.abs(S)<Phaser.Math.RadToDeg(r/2)&&s.push({point:M,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,M.x,M.y),angleOffsetDeg:-S})}}catch(t){j=!0,G=t}finally{try{x||null==L.return||L.return()}finally{if(j)throw G}}for(var A=b+1,B=t.objects.length;A<B;A++){var R=t.objects[A],T=R.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(m.getBounds(),R.getBounds())){var D=!0,C=!1,O=void 0;try{for(var X,I=v.getSegments(this)[Symbol.iterator]();!(D=(X=I.next()).done);D=!0){var Y=X.value,E=!0,N=!1,k=void 0;try{for(var H,W=T.getSegments(this)[Symbol.iterator]();!(E=(H=W.next()).done);E=!0){var q=H.value,U=[];if(Phaser.Geom.Intersects.LineToLine(Y,q,U)){var z=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,U.x,U.y),F=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(z),Phaser.Math.RadToDeg(e));Math.abs(F)<Phaser.Math.RadToDeg(r/2)&&s.push({point:new Phaser.Geom.Point(U.x,U.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,U.x,U.y),angleOffsetDeg:-F})}}}catch(t){N=!0,k=t}finally{try{E||null==W.return||W.return()}finally{if(N)throw k}}}}catch(t){C=!0,O=t}finally{try{D||null==I.return||I.return()}finally{if(C)throw O}}}}}}s.sort(function(t,e){return t.angle==e.angle?Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.point.x,t.point.y)<Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.point.x,e.point.y)?1:-1:t.angleOffsetDeg-e.angleOffsetDeg}.bind(this));for(var J=0,K=s;J<K.length;J++){var Q=K[J];this.setAngle(Q.angle);var V=this.cast({objects:o,target:Q.point});if(V){if(Phaser.Geom.Point.Equals(Q.point,V)){this.setAngle(Q.angle-1e-4);var Z=this.cast({objects:o});Z&&n.push(Z),n.push(V),this.setAngle(Q.angle+1e-4);var $=this.cast({objects:o});$&&n.push($);continue}n.push(V)}}return this.setAngle(e),n}n.r(e),n.d(e,"castCone",(function(){return i}))}])}));
//# sourceMappingURL=phaser-raycaster.min.js.map