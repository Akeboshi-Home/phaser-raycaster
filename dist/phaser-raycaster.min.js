!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("PhaserRaycaster",[],t):"object"==typeof exports?exports.PhaserRaycaster=t():e.PhaserRaycaster=t()}(window,(function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(i,r,function(t){return e[t]}.bind(null,r));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=4)}([function(e,t,n){"use strict";function i(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Phaser.Math.MAX_SAFE_INTEGER;return this.rayRange=e,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this}function r(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.detectionRange=e,this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}function s(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Phaser.Math.MAX_SAFE_INTEGER;return this.collisionRange=e,this.body&&(this.arcadePhysicsCircle.setRadius(this.collisionRange),this.body.setCircle(this.collisionRange)),this}function o(e){var t,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return!this.detectionRange||(t=n||e.getBounds(),!!Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle,t))}n.r(t),n.d(t,"setRayRange",(function(){return i})),n.d(t,"setDetectionRange",(function(){return r})),n.d(t,"setCollisionRange",(function(){return s})),n.d(t,"boundsInRange",(function(){return o}))},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}function s(e){var t=[],n=!1,r=new Phaser.Geom.Circle(this.origin.x,this.origin.y,this.collisionRange);if(void 0===e?(e=this._raycaster.scene.physics.overlapCirc(this.origin.x,this.origin.y,this.collisionRange,!0,!0),n=!0):Array.isArray(e)||(e=[e]),n){var s,o=i(e);try{for(o.s();!(s=o.n()).done;){var a=s.value;if(a!==this.body){var h=void 0;h=a.isCircle?new Phaser.Geom.Circle(a.position.x+a.halfWidth,a.position.y+a.halfWidth,a.halfWidth):new Phaser.Geom.Rectangle(a.x,a.y,a.width,a.height),this.testOverlap(h)&&t.push(a.gameObject)}}}catch(e){o.e(e)}finally{o.f()}}else{var c,l=i(e);try{for(l.s();!(c=l.n()).done;){var u=c.value,g=void 0;if(u.body.isCircle){if(g=new Phaser.Geom.Circle(u.body.position.x+u.body.halfWidth,u.body.position.y+u.body.halfWidth,u.body.halfWidth),!Phaser.Geom.Intersects.CircleToCircle(r,g))continue}else if(g=new Phaser.Geom.Rectangle(u.body.x,u.body.y,u.body.width,u.body.height),!Phaser.Geom.Intersects.CircleToRectangle(r,g))continue;this.testOverlap(g)&&t.push(u)}}catch(e){l.e(e)}finally{l.f()}}return t}function o(e,t){var n;if(e._ray===this)n=t;else{if(t._ray!==this)return!1;n=obj1}return this.overlap(n).length>0}function a(e){var t,n=i(this.slicedIntersections);try{for(n.s();!(t=n.n()).done;){var r=t.value;if(0==e.type?Phaser.Geom.Intersects.TriangleToCircle(r,e):Phaser.Geom.Intersects.RectangleToTriangle(e,r))return!0}}catch(e){n.e(e)}finally{n.f()}return!1}n.r(t),n.d(t,"overlap",(function(){return s})),n.d(t,"processOverlap",(function(){return o})),n.d(t,"testOverlap",(function(){return a}))},function(e,t,n){"use strict";function i(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.Angle.Normalize(e),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this}function r(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.angle=Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(e)),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this}n.r(t),n.d(t,"setAngle",(function(){return i})),n.d(t,"setAngleDeg",(function(){return r}))},function(e,t,n){"use strict";function i(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cone=e,this}function r(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cone=Phaser.Math.DegToRad(e),this}n.r(t),n.d(t,"setCone",(function(){return i})),n.d(t,"setConeDeg",(function(){return r}))},function(e,t,n){var i=function(e){this.scene=e,this.systems=e.sys,e.sys.settings.isBooted||e.sys.events.once("boot",this.boot,this)};i.register=function(e){e.register("PhaserRaycaster",i,"base")},(i.prototype={boot:function(){var e=this.systems.events;e.on("start",this.start,this),e.on("preupdate",this.preUpdate,this),e.on("update",this.update,this),e.on("postupdate",this.postUpdate,this),e.on("pause",this.pause,this),e.on("resume",this.resume,this),e.on("sleep",this.sleep,this),e.on("wake",this.wake,this),e.on("shutdown",this.shutdown,this),e.on("destroy",this.destroy,this)},test:function(e){console.log("RaycasterPlugin says hello "+e+"!")},start:function(){},preUpdate:function(e,t){},update:function(e,t){},postUpdate:function(e,t){},pause:function(){},resume:function(){},sleep:function(){},wake:function(){},shutdown:function(){},destroy:function(){this.shutdown(),this.scene=void 0},createRaycaster:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.scene=this.scene,new this._Raycaster(e)}}).constructor=i,i.prototype._Raycaster=n(5).Raycaster,e.exports=i},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}
/**
* @author       Marcin Walczak <mail@marcinwalczak.pl>
* @copyright    2020 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/function s(e){return this.version="0.8.0",this.scene,this.graphics,this.boundingBox=!1,this.mappedObjects=[],this.sortedPoints=[],this.mapSegmentCount=0,void 0!==e?(void 0===e.boundingBox&&void 0!==e.scene&&void 0!==e.scene.physics&&(e.boundingBox=e.scene.physics.world.bounds),this.setOptions(e),(void 0===e.autoUpdate||e.autoUpdate)&&this.scene.events.on("update",this.update.bind(this))):this.scene.events.on("update",this.update.bind(this)),this}n.r(t),n.d(t,"Raycaster",(function(){return s})),s.prototype={setOptions:function(e){return void 0!==e.scene&&(this.scene=e.scene,this.graphics=this.scene.add.graphics({lineStyle:{width:1,color:65280},fillStyle:{color:16711935}})),void 0!==e.mapSegmentCount&&(this.mapSegmentCount=e.mapSegmentCount),void 0!==e.objects&&this.mapGameObjects(e.objects),void 0!==e.boundingBox&&this.setBoundingBox(e.boundingBox.x,e.boundingBox.y,e.boundingBox.width,e.boundingBox.height),this},setBoundingBox:function(e,t,n,i){this.boundingBox={rectangle:new Phaser.Geom.Rectangle(e,t,n,i),points:[],segments:[]};var r=[new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.top),new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.bottom),new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.bottom)];this.boundingBox.points=r;for(var s=0,o=this.boundingBox.points.length;s<o;s++)s+1<o?this.boundingBox.segments.push(new Phaser.Geom.Line(r[s].x,r[s].y,r[s+1].x,r[s+1].y)):this.boundingBox.segments.push(new Phaser.Geom.Line(r[s].x,r[s].y,r[0].x,r[0].y))},mapGameObjects:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(n.dynamic=t,n.segmentCount=void 0!==n.segmentCount?n.segmentCount:this.segmentCount,!Array.isArray(e)){if(this.mappedObjects.includes(e))return this;e.data||e.setDataEnabled(),n.object=e;var r=new this.Map(n);return e.data.set("raycasterMap",r),this.mappedObjects.push(e),this}var s,o=i(e);try{for(o.s();!(s=o.n()).done;){var a=s.value;if(!this.mappedObjects.includes(a)){a.data||a.setDataEnabled();var h={};for(var c in n)h[c]=n[c];h.object=a;var l=new this.Map(h);a.data.set("raycasterMap",l),this.mappedObjects.push(a)}}}catch(e){o.e(e)}finally{o.f()}return this},removeMappedObjects:function(e){if(!Array.isArray(e)){var t=this.mappedObjects.indexOf(e);return t>=0&&this.mappedObjects.splice(t,1),this}var n,r=i(e);try{for(r.s();!(n=r.n()).done;){var s=n.value,o=this.mappedObjects.indexOf(s);o>=0&&this.mappedObjects.splice(o,1)}}catch(e){r.e(e)}finally{r.f()}return this},enableMaps:function(e){if(!Array.isArray(e)){if(e.data){var t=e.data.get("raycasterMap");t&&(t.active=!0)}return this}var n,r=i(e);try{for(r.s();!(n=r.n()).done;){var s=n.value;if(s.data){var o=s.data.get("raycasterMap");o&&(o.active=!0)}}}catch(e){r.e(e)}finally{r.f()}return this},disableMaps:function(e){if(!Array.isArray(e)){if(e.data){var t=e.data.get("raycasterMap");t&&(t.active=!1)}return this}var n,r=i(e);try{for(r.s();!(n=r.n()).done;){var s=n.value;if(s.data){var o=s.data.get("raycasterMap");o&&(o.active=!1)}}}catch(e){r.e(e)}finally{r.f()}return this},update:function(){if(this.mappedObjects.length>0){var e,t=i(this.mappedObjects);try{for(t.s();!(e=t.n()).done;){var n=e.value;if(void 0!==n.data){var r=n.data.get("raycasterMap");r.dynamic&&r.updateMap()}}}catch(e){t.e(e)}finally{t.f()}}},createRay:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new this.Ray(e,this)}},s.prototype.Map=n(6).Map,s.prototype.Ray=n(15).Ray},function(e,t,n){"use strict";function i(e){return this.type,this.active,this.dynamic,this.object,this._points=[],this._segments=[],this.getPoints,this.getSegments,this.updateMap,this.getIntersections,this.config(e),this.updateMap(),this}n.r(t),n.d(t,"Map",(function(){return i})),i.prototype={config:n(7).config},i.prototype.constructor=i},function(e,t,n){"use strict";n.r(t),n.d(t,"config",(function(){return l}));var i=n(8),r=n(9),s=n(10),o=n(11),a=n(12),h=n(13),c=n(14);function l(e){switch(this.object=e.object,void 0===e.type&&(e.type=e.object.type),this.type=e.type,e.type){case"Polygon":this.getPoints=s.getPoints,this.getSegments=s.getSegments,this.updateMap=s.updateMap;break;case"Arc":this.segmentCount=e.segmentCount?e.segmentCount:0,this.getPoints=o.getPoints,this.getSegments=o.getSegments,this.updateMap=o.updateMap,this.setSegmentCount=a.setSegmentCount;break;case"Line":this.getPoints=r.getPoints,this.getSegments=r.getSegments,this.updateMap=r.updateMap;break;case"Container":this.getPoints=h.getPoints,this.getSegments=h.getSegments,this.updateMap=h.updateMap;break;case"StaticTilemapLayer":case"DynamicTilemapLayer":this.collisionTiles=e.collisionTiles?e.collisionTiles:[],this.getPoints=c.getPoints,this.getSegments=c.getSegments,this.updateMap=c.updateMap,this.setCollisionTiles=c.setCollisionTiles,this.object.setOrigin(0,0);break;default:this.getPoints=i.getPoints,this.getSegments=i.getSegments,this.updateMap=i.updateMap}return this.dynamic=1==e.dynamic,this.active=void 0===e.active||e.active,this}},function(e,t,n){"use strict";function i(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.active?this._points:[]}function r(){return this.active?this._segments:[]}function s(){if(!this.active)return this;for(var e,t=[],n=0,i=(e=[this.object.getTopLeft(),this.object.getTopRight(),this.object.getBottomRight(),this.object.getBottomLeft()]).length;n<i;n++)n+1<i?t.push(new Phaser.Geom.Line(e[n].x,e[n].y,e[n+1].x,e[n+1].y)):t.push(new Phaser.Geom.Line(e[n].x,e[n].y,e[0].x,e[0].y));return this._points=e,this._segments=t,this}n.r(t),n.d(t,"getPoints",(function(){return i})),n.d(t,"getSegments",(function(){return r})),n.d(t,"updateMap",(function(){return s}))},function(e,t,n){"use strict";function i(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.active?this._points:[]}function r(){return this.active?this._segments:[]}function s(){if(!this.active)return this;var e=[],t=[],n=new Phaser.Geom.Point;n.x=this.object.x-this.object.displayWidth*this.object.originX,n.y=this.object.y-this.object.displayHeight*this.object.originY;var i=this.object.geom.getPointA(),r=this.object.geom.getPointB(),s=this.object.rotation;if(0!==s){var o=new Phaser.Geom.Line(this.object.x,this.object.y,i.x*this.object.scaleX+n.x,i.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(o,this.object.x,this.object.y,Phaser.Geom.Line.Angle(o)+s,Phaser.Geom.Line.Length(o)),i=o.getPointB();var a=new Phaser.Geom.Line(this.object.x,this.object.y,r.x*this.object.scaleX+n.x,r.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+s,Phaser.Geom.Line.Length(a)),r=a.getPointB(),e.push(new Phaser.Geom.Point(i.x,i.y)),e.push(new Phaser.Geom.Point(r.x,r.y)),t.push(new Phaser.Geom.Line(i.x,i.y,r.x,r.y))}else e.push(new Phaser.Geom.Point(i.x*this.object.scaleX+n.x,i.y*this.object.scaleY+n.y)),e.push(new Phaser.Geom.Point(r.x*this.object.scaleX+n.x,r.y*this.object.scaleY+n.y)),t.push(new Phaser.Geom.Line(i.x*this.object.scaleX+n.x,i.y*this.object.scaleY+n.y,r.x+n.x*this.object.scaleX,r.y*this.object.scaleY+n.y));return this._points=e,this._segments=t,this}n.r(t),n.d(t,"getPoints",(function(){return i})),n.d(t,"getSegments",(function(){return r})),n.d(t,"updateMap",(function(){return s}))},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}function s(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.active?this._points:[]}function o(){return this.active?this._segments:[]}function a(){if(!this.active)return this;var e=[],t=[],n=new Phaser.Geom.Point;n.x=this.object.x-this.object.displayWidth*this.object.originX,n.y=this.object.y-this.object.displayHeight*this.object.originY;var r=this.object.rotation;if(0!==r){var s,o=i(this.object.geom.points);try{for(o.s();!(s=o.n()).done;){var a=s.value,h=new Phaser.Geom.Line(this.object.x,this.object.y,a.x*this.object.scaleX+n.x,a.y*this.object.scaleY+n.y);Phaser.Geom.Line.SetToAngle(h,this.object.x,this.object.y,Phaser.Geom.Line.Angle(h)+r,Phaser.Geom.Line.Length(h)),e.push(h.getPointB())}}catch(e){o.e(e)}finally{o.f()}}else{var c,l=i(this.object.geom.points);try{for(l.s();!(c=l.n()).done;){var u=c.value;e.push(new Phaser.Geom.Point(u.x*this.object.scaleX+n.x,u.y*this.object.scaleY+n.y))}}catch(e){l.e(e)}finally{l.f()}}for(var g=0,y=e.length;g<y;g++)g+1<y&&t.push(new Phaser.Geom.Line(e[g].x,e[g].y,e[g+1].x,e[g+1].y));if(this.object.closePath){var f=e.length-1;t.push(new Phaser.Geom.Line(e[f].x,e[f].y,e[0].x,e[0].y))}return this._points=e,this._segments=t,this}n.r(t),n.d(t,"getPoints",(function(){return s})),n.d(t,"getSegments",(function(){return o})),n.d(t,"updateMap",(function(){return a}))},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}function s(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this.active)return[];if(this._points.length>0)return this._points;var t=[],n=new Phaser.Geom.Point;if(n.x=this.object.x-this.object.displayWidth*(this.object.originX-.5),n.y=this.object.y-this.object.displayHeight*(this.object.originY-.5),e){var i,r=new Phaser.Geom.Line,s=new Phaser.Geom.Line,o=this.object.rotation;if(0!==o){var a=new Phaser.Geom.Line(this.object.x,this.object.y,n.x,n.y);Phaser.Geom.Line.SetToAngle(a,this.object.x,this.object.y,Phaser.Geom.Line.Angle(a)+o,Phaser.Geom.Line.Length(a));var h=a.getPointB();i=new Phaser.Geom.Line(e.origin.x,e.origin.y,h.x,h.y)}else i=new Phaser.Geom.Line(e.origin.x,e.origin.y,n.x,n.y);var c=Math.sqrt(Math.pow(Phaser.Geom.Line.Length(i),2)-Math.pow(this.object.radius*this.object.scaleX,2)),l=Phaser.Geom.Line.Angle(i),u=Math.asin(this.object.radius*this.object.scaleX/Phaser.Geom.Line.Length(i));Phaser.Geom.Line.SetToAngle(r,e.origin.x,e.origin.y,l-u,c),Phaser.Geom.Line.SetToAngle(s,e.origin.x,e.origin.y,l+u,c),t.push(r.getPointB()),t.push(s.getPointB())}return t}function o(){return this.active?this._segments:[]}function a(){if(!this.active)return this;if(!this.segmentCount)return this._points=[],this._segments=[],this;var e=new Phaser.Geom.Point;e.x=this.object.x-this.object.displayWidth*this.object.originX+this.object.radius*this.object.scaleX,e.y=this.object.y-this.object.displayHeight*this.object.originY+this.object.radius*this.object.scaleY;var t=this.object.geom.getPoints(this.segmentCount),n=[],r=this.object.rotation;if(0!==r){var s,o=[],a=i(t);try{for(a.s();!(s=a.n()).done;){var h=s.value,c=new Phaser.Geom.Line(this.object.x,this.object.y,this.object.x+(h.x+this.object.radius)*this.object.scaleX,this.object.y+(h.y+this.object.radius)*this.object.scaleY);Phaser.Geom.Line.SetToAngle(c,this.object.x,this.object.y,Phaser.Geom.Line.Angle(c)+r,Phaser.Geom.Line.Length(c)),o.push(c.getPointB())}}catch(e){a.e(e)}finally{a.f()}t=o}else{var l,u=i(t);try{for(u.s();!(l=u.n()).done;){var g=l.value;g.x=g.x*this.object.scaleX+e.x,g.y=g.y*this.object.scaleY+e.y}}catch(e){u.e(e)}finally{u.f()}}for(var y=0,f=t.length;y<f;y++)y+1<f?n.push(new Phaser.Geom.Line(t[y].x,t[y].y,t[y+1].x,t[y+1].y)):n.push(new Phaser.Geom.Line(t[y].x,t[y].y,t[0].x,t[0].y));return this._points=t,this._segments=n,this}n.r(t),n.d(t,"getPoints",(function(){return s})),n.d(t,"getSegments",(function(){return o})),n.d(t,"updateMap",(function(){return a}))},function(e,t,n){"use strict";function i(e){return this.segmentCount=e,this.updateMap(),this}n.r(t),n.d(t,"setSegmentCount",(function(){return i}))},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}function s(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.active)return[];var n=[];t||(n=this._points);var r=new Phaser.Geom.Point;if(r.x=this.object.x-this.object.displayWidth*this.object.originX,r.y=this.object.y-this.object.displayHeight*this.object.originY,e){var s=new Phaser.Geom.Line(0,0,e.origin.x-r.x,e.origin.y-r.y);Phaser.Geom.Line.SetToAngle(s,0,0,Phaser.Geom.Line.Angle(s)-this.object.rotation,Phaser.Geom.Line.Length(s));var o,a=e._raycaster.createRay({origin:{x:s.getPointB().x,y:s.getPointB().y}}),h=i(this.object.list);try{for(h.s();!(o=h.n()).done;){var c=o.value;if("Arc"===c.type){var l=c.data.get("raycasterMap");if(0==l._points.length){var u,g=i(l.getPoints(a,!0));try{for(g.s();!(u=g.n()).done;){var y=u.value,f=new Phaser.Geom.Line(0,0,y.x,y.y);Phaser.Geom.Line.SetToAngle(f,0,0,Phaser.Geom.Line.Angle(f)+this.object.rotation,Phaser.Geom.Line.Length(f)),n.push(new Phaser.Geom.Point(f.getPointB().x+r.x,f.getPointB().y+r.y))}}catch(e){g.e(e)}finally{g.f()}}}else if("Container"===c.type){var d,p=i(c.data.get("raycasterMap").getPoints(a,!0));try{for(p.s();!(d=p.n()).done;){var b=d.value;if(0!==this.object.rotation){var v=new Phaser.Geom.Line(this.object.x,this.object.y,b.x*this.object.scaleX+r.x,b.y*this.object.scaleY+r.y);Phaser.Geom.Line.SetToAngle(v,this.object.x,this.object.y,Phaser.Geom.Line.Angle(v)+this.object.rotation,Phaser.Geom.Line.Length(v)),n.push(v.getPointB())}else n.push(new Phaser.Geom.Point(b.x*this.object.scaleX+r.x,b.y*this.object.scaleX+r.y))}}catch(e){p.e(e)}finally{p.f()}}}}catch(e){h.e(e)}finally{h.f()}}return n}function o(){return this.active?this._segments:[]}function a(){if(!this.active)return this;var e=[],t=[],n=this.object,r=new Phaser.Geom.Point;r.x=this.object.x-this.object.displayWidth*this.object.originX,r.y=this.object.y-this.object.displayHeight*this.object.originY;var s=n.rotation;n.iterate(function(o){o.data||o.setDataEnabled();var a=o.data.get("raycasterMap");a?a.updateMap():(a=new this.constructor({object:o,segmentCount:this.segmentCount}),o.data.set("raycasterMap",a));var h,c=[],l=i(a.getPoints());try{for(l.s();!(h=l.n()).done;){var u=h.value;if(0!==s){var g=new Phaser.Geom.Line(this.object.x,this.object.y,u.x*this.object.scaleX+r.x,u.y*this.object.scaleY+r.y);Phaser.Geom.Line.SetToAngle(g,this.object.x,this.object.y,Phaser.Geom.Line.Angle(g)+s,Phaser.Geom.Line.Length(g)),e.push(g.getPointB())}else e.push(new Phaser.Geom.Point(u.x*n.scaleX+r.x,u.y*n.scaleX+r.y));c.push(e[e.length-1])}}catch(e){l.e(e)}finally{l.f()}var y,f=i(a.getSegments());try{for(f.s();!(y=f.n()).done;){var d=y.value;if(0!==s){var p=d.getPointA(),b=d.getPointB(),v=new Phaser.Geom.Line(this.object.x,this.object.y,p.x*this.object.scaleX+r.x,p.y*this.object.scaleY+r.y),m=new Phaser.Geom.Line(this.object.x,this.object.y,b.x*this.object.scaleX+r.x,b.y*this.object.scaleY+r.y);Phaser.Geom.Line.SetToAngle(v,this.object.x,this.object.y,Phaser.Geom.Line.Angle(v)+s,Phaser.Geom.Line.Length(v)),Phaser.Geom.Line.SetToAngle(m,this.object.x,this.object.y,Phaser.Geom.Line.Angle(m)+s,Phaser.Geom.Line.Length(m)),t.push(new Phaser.Geom.Line(v.getPointB().x,v.getPointB().y,m.getPointB().x,m.getPointB().y))}else t.push(new Phaser.Geom.Line(d.getPointA().x*n.scaleX+r.x,d.getPointA().y*n.scaleY+r.y,d.getPointB().x*n.scaleX+r.x,d.getPointB().y*n.scaleY+r.y))}}catch(e){f.e(e)}finally{f.f()}}.bind(this));for(var o=0,a=n.list.length;o<a;o++)for(var h=n.list[o],c=h.data.get("raycasterMap"),l=o+1,u=n.list.length;l<u;l++){var g=n.list[l],y=g.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(h.getBounds(),g.getBounds())){var f,d=i(c.getSegments());try{for(d.s();!(f=d.n()).done;){var p,b=f.value,v=i(y.getSegments());try{for(v.s();!(p=v.n()).done;){var m=p.value,P=[];if(Phaser.Geom.Intersects.LineToLine(b,m,P))if(0!==s){var j=new Phaser.Geom.Line(this.object.x,this.object.y,P.x*this.object.scaleX+r.x,P.y*this.object.scaleY+r.y);Phaser.Geom.Line.SetToAngle(j,this.object.x,this.object.y,Phaser.Geom.Line.Angle(j)+s,Phaser.Geom.Line.Length(j)),e.push(j.getPointB())}else e.push(new Phaser.Geom.Point(P.x*n.scaleX+r.x,P.y*n.scaleX+r.y))}}catch(e){v.e(e)}finally{v.f()}}}catch(e){d.e(e)}finally{d.f()}}}return this._points=e,this._segments=t,this}n.r(t),n.d(t,"getPoints",(function(){return s})),n.d(t,"getSegments",(function(){return o})),n.d(t,"updateMap",(function(){return a}))},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}function s(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this.active)return[];if(!e||e&&(0==e.detectionRange||e.detectionRange>=Phaser.Math.MAX_SAFE_INTEGER))return this._points;var t,n=[],r=i(this._points);try{for(r.s();!(t=r.n()).done;){var s=t.value;Phaser.Math.Distance.Between(e.origin.x,e.origin.y,s.x,s.y)<=e.detectionRange&&n.push(s)}}catch(e){r.e(e)}finally{r.f()}var o,a=this.getSegments(e),h=i(a);try{for(h.s();!(o=h.n()).done;){var c=o.value;Phaser.Math.Distance.Between(e.origin.x,e.origin.y,c.x1,c.y1)>e.detectionRange&&n.push(new Phaser.Geom.Point(c.x1,c.y1)),Phaser.Math.Distance.Between(e.origin.x,e.origin.y,c.x2,c.y2)>e.detectionRange&&n.push(new Phaser.Geom.Point(c.x2,c.y2))}}catch(e){h.e(e)}finally{h.f()}return n}function o(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this.active)return[];if(!e||e&&(0==e.detectionRange||e.detectionRange>=Phaser.Math.MAX_SAFE_INTEGER))return this._segments;var t,n=[],r=i(this._segments);try{for(r.s();!(t=r.n()).done;){var s=t.value;Phaser.Geom.Intersects.LineToCircle(s,e.detectionRangeCircle)&&n.push(s)}}catch(e){r.e(e)}finally{r.f()}return n}function a(){var e=this;if(!this.active)return this;var t=[],n=[],r=new Phaser.Geom.Point;r.x=this.object.x,r.y=this.object.y;for(var s=!1,o=[],a=[],h=0,c=this.object.layer.data.length;h<c;h++){for(var l=this.object.layer.data[h],u=0,g=l.length;u<g;u++){var f=l[u],d=!!(h>0&&this.collisionTiles.includes(this.object.layer.data[h-1][u].index)!=this.collisionTiles.includes(f.index)||0==h&&this.collisionTiles.includes(f.index)),p=!!(u>0&&this.collisionTiles.includes(this.object.layer.data[h][u-1].index)!=this.collisionTiles.includes(f.index)||0==u&&this.collisionTiles.includes(f.index)),b=!1;if(a.length<=u?a[u]=[]:a[u].length>0&&(b=a[u][a[u].length-1]),p&&(b&&b.y+b.height==h?b.height++:a[u].push({x:f.x,y:f.y,height:1})),d)s?s.width++:s={x:f.x,y:f.y,width:1};else if(s){var v=s.x*this.object.layer.tileWidth*this.object.scaleX+r.x,m=s.y*this.object.layer.tileHeight*this.object.scaleY+r.y,P=new Phaser.Geom.Line(v,m,v+this.object.layer.tileWidth*this.object.scaleX*s.width,m);n.push(P),o.push(P),t.push(new Phaser.Geom.Point(v,m)),t.push(new Phaser.Geom.Point(v+this.object.layer.tileWidth*this.object.scaleX*s.width,m)),s=!1}}if(s){var j=s.x*this.object.layer.tileWidth*this.object.scaleX+r.x,x=s.y*this.object.layer.tileHeight*this.object.scaleY+r.y,w=new Phaser.Geom.Line(j,x,j+this.object.layer.tileWidth*this.object.scaleX*s.width,x);n.push(w),o.push(w),t.push(new Phaser.Geom.Point(j,x)),t.push(new Phaser.Geom.Point(j+this.object.layer.tileWidth*this.object.scaleX*s.width,x)),s=!1}}var G,A=i(this.object.layer.data[this.object.layer.data.length-1]);try{for(A.s();!(G=A.n()).done;){var S=G.value;if(this.collisionTiles.includes(S.index))s?s.width++:s={x:S.x,y:S.y+1,width:1};else if(s){var R=s.x*this.object.layer.tileWidth*this.object.scaleX+r.x,M=s.y*this.object.layer.tileHeight*this.object.scaleY+r.y,L=new Phaser.Geom.Line(R,M,R+this.object.layer.tileWidth*this.object.scaleX*s.width,M);n.push(L),o.push(L),t.push(new Phaser.Geom.Point(R,M)),t.push(new Phaser.Geom.Point(R+this.object.layer.tileWidth*this.object.scaleX*s.width,M)),s=!1}}}catch(e){A.e(e)}finally{A.f()}if(s){var T=s.x*this.object.layer.tileWidth*this.object.scaleX+r.x,_=s.y*this.object.layer.tileHeight*this.object.scaleY+r.y,B=new Phaser.Geom.Line(T,_,T+this.object.layer.tileWidth*this.object.scaleX*s.width,_);n.push(B),o.push(B),t.push(new Phaser.Geom.Point(T,_)),t.push(new Phaser.Geom.Point(T+this.object.layer.tileWidth*this.object.scaleX*s.width,_)),s=!1}var C,I=!1,O=[],D=i(this.object.layer.data);try{for(D.s();!(C=D.n()).done;){var X=C.value,E=X[X.length-1];this.collisionTiles.includes(E.index)?I?I.height++:I={x:E.x+1,y:E.y,height:1}:I&&(O.push(I),I=!1)}}catch(e){D.e(e)}finally{D.f()}a.push(O);for(var Y=0,W=a;Y<W.length;Y++){var N=W[Y];if(N){var U,H=i(N);try{var k=function(){var s=U.value,a=s.x*e.object.layer.tileWidth*e.object.scaleX+r.x,h=s.y*e.object.layer.tileHeight*e.object.scaleY+r.y,c=h+e.object.layer.tileHeight*e.object.scaleY*s.height,l=new Phaser.Geom.Line(a,h,a,c);n.push(l),t.filter((function(e){return e.x==a&&e.y==h}))||t.push(new Phaser.Geom.Point(a,y)),t.filter((function(e){return e.x==a&&e.y==c}))||t.push(new Phaser.Geom.Point(a,y));var u,g=i(o);try{for(g.s();!(u=g.n()).done;){var f=u.value;if(l.x1!=f.x1&&l.x1!=f.x2&&l.x2!=f.x1&&l.x2!=f.x2&&(l.y1!=f.y1&&l.y1!=f.y2&&l.y2!=f.y1&&l.y2!=f.y2)){var d=new Phaser.Geom.Point;Phaser.Geom.Intersects.LineToLine(l,f,d)&&t.push(d)}}}catch(e){g.e(e)}finally{g.f()}};for(H.s();!(U=H.n()).done;)k()}catch(e){H.e(e)}finally{H.f()}}}return this._points=t,this._segments=n,this}function h(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return this.collisionTiles=e,this}n.r(t),n.d(t,"getPoints",(function(){return s})),n.d(t,"getSegments",(function(){return o})),n.d(t,"updateMap",(function(){return a})),n.d(t,"setCollisionTiles",(function(){return h}))},function(e,t,n){"use strict";function i(e,t){this._raycaster=t||!1,this.origin=new Phaser.Geom.Point,this._ray=new Phaser.Geom.Line,this.angle=0,this.cone=0,this.rayRange=Phaser.Math.MAX_SAFE_INTEGER,this.detectionRange=0,this.detectionRangeCircle=new Phaser.Geom.Circle,this.collisionRange=Phaser.Math.MAX_SAFE_INTEGER,this.ignoreNotIntersectedRays=!0,this.autoSlice=!1,this.intersections=[],this.slicedIntersections=[],this.config(e)}n.r(t),n.d(t,"Ray",(function(){return i})),i.prototype={config:n(16).config,setRay:n(17).setRay,setOrigin:n(18).setOrigin,setRayRange:n(0).setRayRange,setAngle:n(2).setAngle,setAngleDeg:n(2).setAngleDeg,setCone:n(3).setCone,setConeDeg:n(3).setConeDeg,setDetectionRange:n(0).setDetectionRange,boundsInRange:n(0).boundsInRange,cast:n(19).cast,castCircle:n(20).castCircle,castCone:n(21).castCone,slice:n(22).slice,setCollisionRange:n(0).setCollisionRange,enableArcadePhysics:n(23).enableArcadePhysics,overlap:n(1).overlap,processOverlap:n(1).processOverlap,testOverlap:n(1).testOverlap}},function(e,t,n){"use strict";function i(e){return this.object=e.object,void 0!==e.origin&&this.origin.setTo(e.origin.x,e.origin.y),void 0!==e.angle&&(this.angle=Phaser.Math.Angle.Normalize(e.angle)),void 0!==e.angleDeg&&(this.angle=Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(e.angleDeg))),void 0!==e.cone&&(this.cone=e.cone),void 0!==e.coneDeg&&(this.cone=Phaser.Math.DegToRad(e.coneDeg)),void 0!==e.rayRange&&(this.rayRange=e.rayRange),void 0!==e.collisionRange&&(this.collisionRange=e.collisionRange),void 0!==e.detectionRange&&(this.detectionRange=e.detectionRange),void 0!==e.ignoreNotIntersectedRays&&(this.ignoreNotIntersectedRays=1==e.ignoreNotIntersectedRays),void 0!==e.autoSlice&&(this.autoSlice=1==e.autoSlice),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}n.r(t),n.d(t,"config",(function(){return i}))},function(e,t,n){"use strict";function i(e,t,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Phaser.Math.MAX_SAFE_INTEGER;return this.origin.setTo(e,t),this.angle=Phaser.Math.Angle.Normalize(n),this.rayRange=i,Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),this}n.r(t),n.d(t,"setRay",(function(){return i}))},function(e,t,n){"use strict";function i(e,t){return this.origin.setTo(e,t),Phaser.Geom.Line.SetToAngle(this._ray,this.origin.x,this.origin.y,this.angle,this.rayRange),this.detectionRangeCircle.setTo(this.origin.x,this.origin.y,this.detectionRange),void 0!==this.body&&(this.arcadePhysicsCircle.x=e,this.arcadePhysicsCircle.y=t),this}n.r(t),n.d(t,"setOrigin",(function(){return i}))},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}function s(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=this.rayRange;if(this._raycaster&&this._raycaster.boundingBox){var r=[];if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,this._raycaster.boundingBox.rectangle,r),1===r.length)e=r[0];else if(r.length>1){var s,o=i(r);try{for(o.s();!(s=o.n()).done;){var a=s.value,h=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,a.x,a.y);h<n&&(n=h,e=a)}}catch(e){o.e(e)}finally{o.f()}}else if(t.target){var c=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.target.x,t.target.y);this.rayRange>c&&(n=c,e=t.target)}}if(!t.objects){if(!this._raycaster)return intersections;t.objects=this._raycaster.mappedObjects}var l,u=i(t.objects);try{for(u.s();!(l=u.n()).done;){var g=l.value;if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray,g.getBounds())){var y,f=g.data.get("raycasterMap"),d=i(f.getSegments(this));try{for(d.s();!(y=d.n()).done;){var p=y.value,b=[];if(t.target){if(Phaser.Geom.Point.Equals(t.target,p.getPointA())||Phaser.Geom.Point.Equals(t.target,p.getPointB()))b=t.target;else if(!Phaser.Geom.Intersects.LineToLine(this._ray,p,b))continue}else if(!Phaser.Geom.Intersects.LineToLine(this._ray,p,b))continue;var v=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,b.x,b.y);v<n&&(n=v,e=b)}}catch(e){d.e(e)}finally{d.f()}if("Arc"===f.type){if(f._points.length>0)continue;if(t.target){var m,P=f.getPoints(this),j=!1,x=i(P);try{for(x.s();!(m=x.n()).done;){var w=m.value;if(Phaser.Geom.Point.Equals(t.target,w)){var G=Phaser.Math.Distance.Between(this.origin.x,this.origin.y,w.x,w.y);if(G<n){n=G,e=w,j=!0;break}}}}catch(e){x.e(e)}finally{x.f()}if(j)continue}var A=[],S=new Phaser.Geom.Point;S.x=f.object.x-f.object.displayWidth*(f.object.originX-.5),S.y=f.object.y-f.object.displayHeight*(f.object.originY-.5);var R=f.object.rotation;if(0!==R){var M=new Phaser.Geom.Line(f.object.x,f.object.y,S.x,S.y);Phaser.Geom.Line.SetToAngle(M,f.object.x,f.object.y,Phaser.Geom.Line.Angle(M)+R,Phaser.Geom.Line.Length(M));var L=M.getPointB();S.x=L.x,S.y=L.y}var T=new Phaser.Geom.Circle(S.x,S.y,f.object.radius*f.object.scaleX);if(Phaser.Geom.Intersects.GetLineToCircle(this._ray,T,A)){var _,B=i(A);try{for(B.s();!(_=B.n()).done;){var C=_.value,I=Phaser.Math.Distance.Between(this._ray.x1,this._ray.y1,C.x,C.y);I<n&&(n=I,e=C)}}catch(e){B.e(e)}finally{B.f()}}}}}}catch(e){u.e(e)}finally{u.f()}return e?new Phaser.Geom.Point(e.x,e.y):!this.ignoreNotIntersectedRays&&this._ray.getPointB()}n.r(t),n.d(t,"cast",(function(){return s}))},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}function s(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=this.angle,n=[],r=[],s=[],o=[];if(!e.objects){if(!this._raycaster)return n;if(e.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var a,h=i(this._raycaster.boundingBox.points);try{for(h.s();!(a=h.n()).done;){var c=a.value;s.push({point:c,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,c.x,c.y)})}}catch(e){h.e(e)}finally{h.f()}}for(var l=0,u=e.objects.length;l<u;l++){var g=e.objects[l];if(this.boundsInRange(g)){o.push(g);var y=g.data.get("raycasterMap");r.push(y);var f,d=i(y.getPoints(this));try{for(d.s();!(f=d.n()).done;){var p=f.value;s.push({point:p,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,p.x,p.y)})}}catch(e){d.e(e)}finally{d.f()}for(var b=l+1,v=e.objects.length;b<v;b++){var m=e.objects[b],P=m.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(g.getBounds(),m.getBounds())){var j,x=i(y.getSegments(this));try{for(x.s();!(j=x.n()).done;){var w,G=j.value,A=i(P.getSegments(this));try{for(A.s();!(w=A.n()).done;){var S=w.value,R=[];Phaser.Geom.Intersects.LineToLine(G,S,R)&&s.push({point:new Phaser.Geom.Point(R.x,R.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,R.x,R.y)})}}catch(e){A.e(e)}finally{A.f()}}}catch(e){x.e(e)}finally{x.f()}}}}}s.sort(function(e,t){return e.angle==t.angle?Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.point.x,e.point.y)<Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.point.x,t.point.y)?1:-1:e.angle-t.angle}.bind(this));var M,L=i(s);try{for(L.s();!(M=L.n()).done;){var T=M.value;this.setAngle(T.angle);var _=this.cast({objects:o,target:T.point});if(_){if(Phaser.Geom.Point.Equals(T.point,_)){this.setAngle(T.angle-1e-4);var B=this.cast({objects:o});B&&n.push(B),n.push(_),this.setAngle(T.angle+1e-4);var C=this.cast({objects:o});C&&n.push(C);continue}n.push(_)}}}catch(e){L.e(e)}finally{L.f()}}return this.setAngle(t),this.intersections=n,this.autoSlice&&(this.slicedIntersections=this.slice()),n}n.r(t),n.d(t,"castCircle",(function(){return s}))},function(e,t,n){"use strict";function i(e){if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,t){if(!e)return;if("string"==typeof e)return r(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r(e,t)}(e))){var t=0,n=function(){};return{s:n,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s,o=!0,a=!1;return{s:function(){i=e[Symbol.iterator]()},n:function(){var e=i.next();return o=e.done,e},e:function(e){a=!0,s=e},f:function(){try{o||null==i.return||i.return()}finally{if(a)throw s}}}}function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,i=new Array(t);n<t;n++)i[n]=e[n];return i}function s(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=this.angle,n=[],r=[],s=[],o=[],a=this.cone,h=0,c=0;if(void 0!==e.cone&&(a=e.cone),void 0!==e.coneDeg&&(a=Phaser.Math.DegToRad(e.coneDeg)),h=this.angle-a/2,c=this.angle+a/2,this.setAngle(h),s.push({point:this._ray.getPointB(),angle:h,angleOffsetDeg:Phaser.Math.RadToDeg(-a/2)}),this.setAngle(c),s.push({point:this._ray.getPointB(),angle:c,angleOffsetDeg:Phaser.Math.RadToDeg(a/2)}),!e.objects){if(!this._raycaster)return n;if(e.objects=this._raycaster.mappedObjects,this._raycaster&&this._raycaster.boundingBox){var l,u=i(this._raycaster.boundingBox.points);try{for(u.s();!(l=u.n()).done;){var g=l.value,y=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,g.x,g.y),f=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(y),Phaser.Math.RadToDeg(t));Math.abs(f)<Phaser.Math.RadToDeg(a/2)&&s.push({point:g,angle:y,angleOffsetDeg:-f})}}catch(e){u.e(e)}finally{u.f()}}}for(var d=0,p=e.objects.length;d<p;d++){var b=e.objects[d];if(this.boundsInRange(b)){o.push(b);var v=b.data.get("raycasterMap");r.push(v);var m,P=i(v.getPoints(this));try{for(P.s();!(m=P.n()).done;){var j=m.value,x=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,j.x,j.y),w=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(x),Phaser.Math.RadToDeg(t));Math.abs(w)<Phaser.Math.RadToDeg(a/2)&&s.push({point:j,angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,j.x,j.y),angleOffsetDeg:-w})}}catch(e){P.e(e)}finally{P.f()}for(var G=d+1,A=e.objects.length;G<A;G++){var S=e.objects[G],R=S.data.get("raycasterMap");if(Phaser.Geom.Intersects.RectangleToRectangle(b.getBounds(),S.getBounds())){var M,L=i(v.getSegments(this));try{for(L.s();!(M=L.n()).done;){var T,_=M.value,B=i(R.getSegments(this));try{for(B.s();!(T=B.n()).done;){var C=T.value,I=[];if(Phaser.Geom.Intersects.LineToLine(_,C,I)){var O=Phaser.Math.Angle.Between(this.origin.x,this.origin.y,I.x,I.y),D=Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(O),Phaser.Math.RadToDeg(t));Math.abs(D)<Phaser.Math.RadToDeg(a/2)&&s.push({point:new Phaser.Geom.Point(I.x,I.y),angle:Phaser.Math.Angle.Between(this.origin.x,this.origin.y,I.x,I.y),angleOffsetDeg:-D})}}}catch(e){B.e(e)}finally{B.f()}}}catch(e){L.e(e)}finally{L.f()}}}}}s.sort(function(e,t){return e.angle==t.angle?Phaser.Math.Distance.Between(this.origin.x,this.origin.y,e.point.x,e.point.y)<Phaser.Math.Distance.Between(this.origin.x,this.origin.y,t.point.x,t.point.y)?1:-1:e.angleOffsetDeg-t.angleOffsetDeg}.bind(this));for(var X=0,E=s;X<E.length;X++){var Y=E[X];this.setAngle(Y.angle);var W=this.cast({objects:o,target:Y.point});if(W){if(Phaser.Geom.Point.Equals(Y.point,W)){this.setAngle(Y.angle-1e-4);var N=this.cast({objects:o});N&&n.push(N),n.push(W),this.setAngle(Y.angle+1e-4);var U=this.cast({objects:o});U&&n.push(U);continue}n.push(W)}}return this.setAngle(t),this.intersections=n,this.autoSlice&&(this.slicedIntersections=this.slice(n,!1)),n}n.r(t),n.d(t,"castCone",(function(){return s}))},function(e,t,n){"use strict";function i(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.intersections,t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!Array.isArray(e)){if(4!==e.type)return[];e=e.points}if(0===e.length)return[];for(var n=[],i=0,r=e.length-1;i<r;i++)n.push(new Phaser.Geom.Triangle(this.origin.x,this.origin.y,e[i].x,e[i].y,e[i+1].x,e[i+1].y));return t&&n.push(new Phaser.Geom.Triangle(this.origin.x,this.origin.y,e[0].x,e[0].y,e[e.length-1].x,e[e.length-1].y)),n}n.r(t),n.d(t,"slice",(function(){return i}))},function(e,t,n){"use strict";function i(){return void 0!==this.body||(this.arcadePhysicsCircle=this._raycaster.scene.add.circle(this.origin.x,this.origin.y,this.collisionRange),this.arcadePhysicsCircle._ray=this,this._raycaster.scene.physics.add.existing(this.arcadePhysicsCircle),this.body=this.arcadePhysicsCircle.body,this.body.setCircle(this.collisionRange).setAllowGravity(!1).setImmovable(!0)),this}n.r(t),n.d(t,"enableArcadePhysics",(function(){return i}))}])}));
//# sourceMappingURL=phaser-raycaster.min.js.map