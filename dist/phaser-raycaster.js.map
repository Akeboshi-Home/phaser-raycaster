{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/enableArcadePhysics.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/raycaster-core.js"],"names":["PhaserRaycaster","scene","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","prototype","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","name","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","module","exports","rectangle","line","polygon","arc","segmentCount","container","tilemap","config","object","type","getPoints","getSegments","updateMap","setSegmentCount","collisionTiles","setCollisionTiles","setOrigin","dynamic","active","ray","_points","length","points","offset","Phaser","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","rayA","Line","rayB","c","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","_segments","scaleY","geom","segments","newPoints","point","i","getCircles","tempRay","_raycaster","createRay","list","child","map","data","get","iterate","setDataEnabled","set","childPoints","segment","pointA","getPointA","pointB","vectorA","vectorB","bind","iLength","childA","mapA","j","jLength","childB","mapB","Intersects","RectangleToRectangle","getBounds","segmentA","segmentB","intersection","LineToLine","Map","getIntersections","closePath","last","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","x1","y1","x2","y2","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","index","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestDistance","boundingBox","intersections","GetLineToRectangle","distance","target","objects","mappedObjects","Equals","isTangent","circleIntersections","circle","Circle","GetLineToCircle","ignoreNotIntersectedRays","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","intersectionA","intersectionB","autoSlice","slicedIntersections","slice","castCone","cone","minAngle","maxAngle","angleOffset","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","abs","setCone","setConeDeg","setTo","angleDeg","collisionRange","enableArcadePhysics","body","arcadePhysicsCircle","add","physics","existing","setCircle","setAllowGravity","setImmovable","overlap","targets","bodies","overlapCircle","overlapCirc","Array","isArray","hitbox","isCircle","position","halfWidth","Rectangle","testOverlap","gameObject","CircleToCircle","CircleToRectangle","processOverlap","object1","object2","obj1","TriangleToCircle","RectangleToTriangle","setRayRange","setDetectionRange","setCollisionRange","setRadius","bounds","objectBounds","Ray","raycaster","setRay","closed","slices","Triangle","version","graphics","sortedPoints","mapSegmentCount","world","setOptions","autoUpdate","lineStyle","color","fillStyle","mapGameObjects","setBoundingBox","left","top","right","bottom","option","removeMappedObjects","indexOf","splice","enableMaps","disableMaps","mapppedObject"],"mappings":"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","file":"phaser-raycaster.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/main.js\");\n","var PhaserRaycaster = function (scene)\r\n{\r\n    //The Scene that owns this plugin\r\n    this.scene = scene;\r\n\r\n    this.systems = scene.sys;\r\n\r\n    if (!scene.sys.settings.isBooted)\r\n    {\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    }\r\n};\r\n\r\n//Static function called by the PluginFile Loader.\r\nPhaserRaycaster.register = function (PluginManager)\r\n{\r\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\r\n\r\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\r\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\r\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\r\n    //  it has an entry in the InjectionMap.\r\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\r\n};\r\n\r\nPhaserRaycaster.prototype = {\r\n\r\n    //  Called when the Plugin is booted by the PluginManager.\r\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\r\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\r\n\r\n        eventEmitter.on('start', this.start, this);\r\n\r\n        eventEmitter.on('preupdate', this.preUpdate, this);\r\n        eventEmitter.on('update', this.update, this);\r\n        eventEmitter.on('postupdate', this.postUpdate, this);\r\n\r\n        eventEmitter.on('pause', this.pause, this);\r\n        eventEmitter.on('resume', this.resume, this);\r\n\r\n        eventEmitter.on('sleep', this.sleep, this);\r\n        eventEmitter.on('wake', this.wake, this);\r\n\r\n        eventEmitter.on('shutdown', this.shutdown, this);\r\n        eventEmitter.on('destroy', this.destroy, this);\r\n    },\r\n\r\n    //A test method.\r\n    test: function (name)\r\n    {\r\n        console.log('RaycasterPlugin says hello ' + name + '!');\r\n    },\r\n\r\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\r\n    start: function ()\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 1\r\n    preUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 2\r\n    update: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called every Scene step - phase 3\r\n    postUpdate: function (time, delta)\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\r\n    pause: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is resumed from a paused state.\r\n    resume: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\r\n    sleep: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is woken from a sleeping state.\r\n    wake: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\r\n    shutdown: function ()\r\n    {\r\n    },\r\n\r\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n    },\r\n\r\n    //Create Raycaster object\r\n    createRaycaster: function(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n\r\n};\r\n\r\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\r\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\r\n\r\n//Make sure you export the plugin for webpack to expose\r\n\r\nmodule.exports = PhaserRaycaster;\r\n","let rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet segmentCount = require('./segmentsCount.js');\r\nlet container = require('./map-container-methods.js');\r\nlet tilemap = require('./map-tilemap-methods.js');\r\n\r\n/**\r\n * Configure map.\r\n *\r\n * @method Raycaster.Map#config\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Map's congfiguration options. May include:\r\n * @param {object} options.object - Game object to map\r\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\r\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\r\n * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\r\n * \r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //object type\r\n    if(options.type === undefined)\r\n        options.type = options.object.type;\r\n    this.type = options.type;\r\n    \r\n    switch(options.type) {\r\n        case 'Polygon':\r\n            this.getPoints = polygon.getPoints;\r\n            this.getSegments = polygon.getSegments;\r\n            this.updateMap = polygon.updateMap;\r\n            break;\r\n        case 'Arc':\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            this.getPoints = arc.getPoints;\r\n            this.getSegments = arc.getSegments;\r\n            this.updateMap = arc.updateMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'Line':\r\n            this.getPoints = line.getPoints;\r\n            this.getSegments = line.getSegments;\r\n            this.updateMap = line.updateMap;\r\n            break;\r\n        case 'Container':\r\n            this.getPoints = container.getPoints;\r\n            this.getSegments = container.getSegments;\r\n            this.updateMap = container.updateMap;\r\n            break;\r\n        case 'StaticTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'DynamicTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        default:\r\n            this.getPoints = rectangle.getPoints;\r\n            this.getSegments = rectangle.getSegments;\r\n            this.updateMap = rectangle.updateMap;\r\n    }\r\n\r\n    //dynamic map\r\n    this.dynamic = (options.dynamic == true) ? true : false;\r\n\r\n    //enable/disable map\r\n    this.active = (options.active !== undefined) ? options.active : true;\r\n\r\n    return this;\r\n}\r\n","/*Map methods for circles*/\r\n/**\r\n* Get array of mapped circle's vertices used as rays targets.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\r\n*\r\n* @method Raycaster.Map#arc.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped circle's segments used to test object's intersection with ray.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\r\n*\r\n* @method Raycaster.Map#arc.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update circles's map of points and segments.\r\n*\r\n* @method Raycaster.Map#arc.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for containers*/\r\n/**\r\n* Get array of mapped container's and its children vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#container.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false, getCircles = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let points = [];\r\n    if(!getCircles)\r\n        points = this._points;\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    //get tangent points of container's circles\r\n    if(ray){\r\n        //create temporary ray\r\n        let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n\r\n        let tempRay = ray._raycaster.createRay({\r\n            origin: {\r\n                x: vector.getPointB().x,\r\n                y: vector.getPointB().y\r\n            }\r\n        });\r\n\r\n        for(let child of this.object.list){\r\n            if(child.type === 'Arc'){\r\n\r\n                let map = child.data.get('raycasterMap');\r\n                if(map._points.length == 0){\r\n                    for(let point of map.getPoints(tempRay, true)){\r\n                        let vector = new Phaser.Geom.Line(0, 0, point.x, point.y);\r\n                        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n\r\n                        points.push(new Phaser.Geom.Point(vector.getPointB().x + offset.x, vector.getPointB().y + offset.y));\r\n                    }\r\n                }\r\n            }\r\n            else if(child.type === 'Container') {\r\n                for(let point of child.data.get('raycasterMap').getPoints(tempRay, true)){\r\n                    if(this.object.rotation !== 0) {\r\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n                        points.push(vector.getPointB());\r\n                    }\r\n                    //if rotation === 0\r\n                    else\r\n                        points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#container.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update container's and its children maps of points and segments.\r\n*\r\n* @method Raycaster.Map#container.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let container = this.object;\r\n\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    let rotation = container.rotation;\r\n\r\n    //iterate through container's children\r\n    container.iterate(function(child){\r\n        if(!child.data)\r\n            child.setDataEnabled();\r\n\r\n        //get child map\r\n        let map = child.data.get('raycasterMap');\r\n        if(!map) {\r\n            map = new this.constructor({\r\n                object: child,\r\n                segmentCount: this.segmentCount\r\n            });\r\n            child.data.set('raycasterMap', map);\r\n        }\r\n        else\r\n            map.updateMap();\r\n\r\n        //add child points\r\n        let childPoints = [];\r\n        for(let point of map.getPoints()) {\r\n            //calculate positions after container's rotation\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                points.push(vector.getPointB());\r\n            }\r\n            //if rotation === 0\r\n            else\r\n                points.push(new Phaser.Geom.Point(point.x * container.scaleX + offset.x, point.y * container.scaleX + offset.y));\r\n\r\n            childPoints.push(points[points.length - 1])\r\n        }\r\n\r\n        //add child segments\r\n        for(let segment of map.getSegments()) {\r\n            //calculate positions after container's rotation\r\n            if(rotation !== 0) {\r\n                let pointA = segment.getPointA();\r\n                let pointB = segment.getPointB();\r\n                let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n                let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n                Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n\r\n                segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\r\n            }\r\n            //if rotation === 0\r\n            else\r\n                segments.push(new Phaser.Geom.Line(segment.getPointA().x * container.scaleX + offset.x, segment.getPointA().y * container.scaleY + offset.y, segment.getPointB().x * container.scaleX + offset.x, segment.getPointB().y * container.scaleY + offset.y));\r\n        }\r\n\r\n    }.bind(this));\r\n\r\n    //get children intersections\r\n    for(let i = 0, iLength = container.list.length; i < iLength; i++){\r\n        let childA = container.list[i];\r\n        let mapA = childA.data.get('raycasterMap');\r\n\r\n        for(let j = i+1, jLength = container.list.length; j < jLength; j++){\r\n            let childB = container.list[j];\r\n            let mapB = childB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\r\n                continue;\r\n\r\n            //find objects intersections\r\n            for(let segmentA of mapA.getSegments()) {\r\n                for(let segmentB of mapB.getSegments()) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    \r\n                     //calculate positions after container's rotation\r\n                    if(rotation !== 0) {\r\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, intersection.x * this.object.scaleX + offset.x, intersection.y * this.object.scaleY + offset.y);\r\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                        points.push(vector.getPointB());\r\n                    }\r\n                    //if rotation === 0\r\n                    else\r\n                        points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responsible for mapping game objects.\r\n *\r\n * @namespace Raycaster.Map\r\n * @class Raycaster.Map\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options) {\r\n    /**\r\n    * Mapped object's type\r\n    *\r\n    * @name Raycaster.Map#type\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.type;\r\n    /**\r\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\r\n    *\r\n    * @name Raycaster.Map#active\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.7.2\r\n    */\r\n    this.active;\r\n    /**\r\n    * If set true, map will be automatically updated on scene update event.\r\n    *\r\n    * @name Raycaster.Map#dynamic\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.6.0\r\n    */\r\n    this.dynamic;\r\n    /**\r\n    * Reference to mapped object.\r\n    *\r\n    * @name Raycaster.Map#object\r\n    * @type {object}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.object;\r\n    /**\r\n    * Array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @name Raycaster.Map#_points\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._points = [];\r\n    /**\r\n    * Array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @name Raycaster.Map#_segments\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._segments = [];\r\n    /**\r\n    * Get array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @method Raycaster.Map#getPoints\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n    */\r\n    this.getPoints;\r\n    /**\r\n    * Get array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @method Raycaster.Map#getSegments\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n    */\r\n    this.getSegments;\r\n    /**\r\n    * Update object's map of points and segments.\r\n    *\r\n    * @method Raycaster.Map#updateMap\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n    */\r\n    this.updateMap;\r\n    this.getIntersections;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n","/*Map methods for lines*/\r\n/**\r\n* Get array of mapped line's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#line.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped line's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#line.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update line's map of points and segments.\r\n*\r\n* @method Raycaster.Map#line.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for polygons*/\r\n/**\r\n* Get array of mapped polygon's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#polygon.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped polygon's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#polygon.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update polygon's map of points and segments.\r\n*\r\n* @method Raycaster.Map#polygon.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for rectangles*/\r\n/**\r\n* Get array of mapped rectangle's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#rectangle.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#rectangle.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update rectangle's map of points and segments.\r\n*\r\n* @method Raycaster.Map#rectangle.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n        \r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {integer} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n        this.updateMap();\n        return this;\n}\n","/**\r\n * Set ray's angle (direction) in radians.\r\n *\r\n * @method Raycaster.Ray#setAngle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {float} [angle = 0] - Ray's angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngle(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's angle (direction) in degrees.\r\n *\r\n * @method Raycaster.Ray#setAngleDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.1\r\n *\r\n * @param {float} [angle = 0] - Ray's angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngleDeg(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n","/**\r\n * Cast ray to find closest intersection with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#cast\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\r\n * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\r\n *\r\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found.\r\n */\r\nexport function cast(options = {}) {\r\n    let closestIntersection;\r\n    let closestDistance = this.rayRange;\r\n    //if bounding box is defined check bounding box intersection\r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        let intersections = [];\r\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n        if(intersections.length === 1)\r\n            closestIntersection = intersections[0];\r\n        else if(intersections.length > 1) {\r\n            for(let intersection of intersections) {\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n        }\r\n        //if ray target is declared\r\n        else if(options.target){\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n            //if target is within ray range\r\n            if(this.rayRange > distance) {\r\n                closestDistance = distance;\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n    }\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n    \r\n    for(let object of options.objects) {\r\n        //check if object is intersected by ray\r\n        if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, object.getBounds()))\r\n            continue;\r\n\r\n        let map = object.data.get('raycasterMap');\r\n        \r\n        //check intersections\r\n        for(let segment of map.getSegments(this)) {\r\n            let intersection = [];\r\n\r\n            //if target point is segmemt point\r\n            if(options.target) {\r\n                if(\r\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                ) {\r\n                    intersection = options.target;\r\n                }\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                    continue;\r\n            }\r\n            //if no intersection continue\r\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n              continue;\r\n            \r\n            //get closest intersection\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n            if(distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestIntersection = intersection;\r\n            }\r\n        }\r\n\r\n        //check arc intersections if its not\r\n        if(map.type === 'Arc') {\r\n           //if arc has generated points (besides tangent points to ray)\r\n            if(map._points.length > 0) {\r\n                continue;\r\n            }\r\n            \r\n            //check if target point is a circle tangent point to ray\r\n            if(options.target) {\r\n                let points = map.getPoints(this);\r\n                let isTangent = false;\r\n                for(let point of points) {\r\n\r\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = point;\r\n                            isTangent = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(isTangent)\r\n                    continue;\r\n            }\r\n\r\n            let circleIntersections = [];\r\n            let offset = new Phaser.Geom.Point();\r\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n            //calculate circle's center after rotation\r\n            let rotation = map.object.rotation;\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                let cB = vector.getPointB();\r\n                offset.x = cB.x;\r\n                offset.y = cB.y;\r\n            }\r\n\r\n            //create transformed circle\r\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                for(let intersection of circleIntersections) {\r\n                    //get closest intersection\r\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                    if(distance < closestDistance) {\r\n\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if(!closestIntersection)\r\n        return (this.ignoreNotIntersectedRays) ? false : this._ray.getPointB();\r\n    return new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n}\r\n","/**\r\n * Cast ray in all directions to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCircle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n */\r\nexport function castCircle(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n\r\n        //if bounding box is defined add bounding box points to \r\n        if(this._raycaster && this._raycaster.boundingBox) {\r\n            for(let point of this._raycaster.boundingBox.points) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                });\r\n            }\r\n        }\r\n\r\n        for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n            let object = options.objects[i];\r\n            //if bound in range\r\n            if(!this.boundsInRange(object))\r\n                continue;\r\n            \r\n            testedObjects.push(object);\r\n\r\n            let map = object.data.get('raycasterMap');\r\n            maps.push(map);\r\n            //get points and angles\r\n            for(let point of map.getPoints(this)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n                });\r\n            }\r\n\r\n            //get objects intersections\r\n            for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n                let objectB = options.objects[j];\r\n                let mapB = objectB.data.get('raycasterMap');\r\n                //check if bounding boxes overlap\r\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\r\n                    continue;\r\n                \r\n                //find objects intersections\r\n                for(let segmentA of map.getSegments(this)) {\r\n                    for(let segmentB of mapB.getSegments(this)) {\r\n                        let intersection = [];\r\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                            continue;\r\n                        \r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //sort target points by angle\r\n        rayTargets.sort(function(a, b){\r\n            //if rays towards points have the same angles promote closer one\r\n            if(a.angle == b.angle) {\r\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                    return 1;\r\n                else\r\n                    return -1;\r\n            }\r\n\r\n            return a.angle - b.angle;\r\n        }.bind(this));\r\n\r\n        //cast rays\r\n        for(let target of rayTargets){\r\n            this.setAngle(target.angle);\r\n            let intersection = this.cast({\r\n                objects: testedObjects,\r\n                target: target.point\r\n            });\r\n            if(intersection){\r\n                //if intersection hits target point cast two additional rays\r\n                if(Phaser.Geom.Point.Equals(target.point, intersection)) {\r\n                    this.setAngle(target.angle - 0.0001);\r\n                    let intersectionA = this.cast({\r\n                        objects: testedObjects\r\n                    });\r\n                    if(intersectionA)\r\n                        intersections.push(intersectionA);\r\n                    \r\n                    intersections.push(intersection);\r\n\r\n                    this.setAngle(target.angle + 0.0001);\r\n                    let intersectionB = this.cast({\r\n                        objects: testedObjects\r\n                    });\r\n                    if(intersectionB)\r\n                        intersections.push(intersectionB);\r\n\r\n                    continue;\r\n                }\r\n                intersections.push(intersection);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice();\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Cast ray in a cone to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n */\r\nexport function castCone(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let cone = this.cone;\r\n    let minAngle = 0;\r\n    let maxAngle = 0;\r\n    let angleOffset = 0;\r\n\r\n    //set cone\r\n    if(options.cone !== undefined)\r\n        cone = options.cone;\r\n    if(options.coneDeg !== undefined)\r\n        cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //set cone min and max angle\r\n    minAngle = this.angle - cone / 2;\r\n    maxAngle = this.angle + cone / 2;\r\n\r\n    //add min and max angle points\r\n    this.setAngle(minAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: minAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\r\n    });\r\n\r\n    this.setAngle(maxAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: maxAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\r\n    });\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n\r\n        //if bounding box is defined add bounding box points to \r\n        if(this._raycaster && this._raycaster.boundingBox) {\r\n            for(let point of this._raycaster.boundingBox.points) {\r\n\r\n                let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n                let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                    rayTargets.push({\r\n                        point: point,\r\n                        angle: angle,\r\n                        angleOffsetDeg: -angleOffsetDeg\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map = object.data.get('raycasterMap');\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB = objectB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(object.getBounds(), objectB.getBounds()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\r\n                            angleOffsetDeg: -angleOffsetDeg\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) < Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angleOffsetDeg - b.angleOffsetDeg;\r\n    }.bind(this));\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point\r\n        });\r\n        if(intersection){\r\n            //if intersection hits target point cast two additional rays\r\n            if(Phaser.Geom.Point.Equals(target.point, intersection)) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects\r\n                });\r\n                if(intersectionA)\r\n                    intersections.push(intersectionA);\r\n                \r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects\r\n                });\r\n                if(intersectionB)\r\n                    intersections.push(intersectionB);\r\n\r\n                continue;\r\n            }\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice(intersections, false);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Set ray's cone angle (width) in radians.\r\n *\r\n * @method Raycaster.Ray#setCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {float} [cone = 0] - Ray's cone angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCone(cone = 0) {\r\n    this.cone = cone;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's cone angle (width) in degrees.\r\n *\r\n * @method Raycaster.Ray#setConeDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {float} [cone = 0] - Ray's cone angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setConeDeg(cone = 0) {\r\n    this.cone = Phaser.Math.DegToRad(cone);\r\n    return this;\r\n}\r\n","/**\r\n * Configure ray.\r\n *\r\n * @method Raycaster.Ray#config\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {float} [options.angle = 0] - Ray's angle in radians.\r\n * @param {float} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {float} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //origin\r\n    if(options.origin !== undefined)\r\n        this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n    //angle\r\n    if(options.angle !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\r\n\r\n    //angle deg\r\n    if(options.angleDeg !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\r\n\r\n    //cone angle\r\n    if(options.cone !== undefined)\r\n        this.cone = options.cone;\r\n\r\n    //cone angle deg\r\n    if(options.coneDeg !== undefined)\r\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //ray range (0 = max)\r\n    if(options.rayRange !== undefined)\r\n        this.rayRange = options.rayRange;\r\n\r\n    //collision range (0 = max)\r\n    if(options.collisionRange !== undefined)\r\n        this.collisionRange = options.collisionRange;\r\n\r\n    //detection range (0 = max)\r\n    if(options.detectionRange !== undefined)\r\n        this.detectionRange = options.detectionRange;\r\n\r\n    //ignore not intersected rays\r\n    if(options.ignoreNotIntersectedRays !== undefined)\r\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n\r\n    //auto slice\r\n    if(options.autoSlice !== undefined)\r\n        this.autoSlice = (options.autoSlice == true)\r\n    \r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Add to ray arcade physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}.\r\n *\r\n * @method Raycaster.Ray#enableArcadePhysics\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function enableArcadePhysics() {\r\n    \r\n    if(this.body !== undefined)\r\n        return this;\r\n\r\n    this.arcadePhysicsCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\r\n    this.arcadePhysicsCircle._ray = this;\r\n    this._raycaster.scene.physics.add.existing(this.arcadePhysicsCircle);\r\n\r\n    this.body = this.arcadePhysicsCircle.body;\r\n    this.body\r\n        .setCircle(this.collisionRange)\r\n        .setAllowGravity(false)\r\n        .setImmovable(true);\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Set ray's source position.\r\n *\r\n * @method Raycaster.Ray#setOrigin\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} x - X coordinate.\r\n * @param {integer} y - Y coordinate.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOrigin(x, y) {\r\n    this.origin.setTo(x, y);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this.body !== undefined) {\r\n        this.arcadePhysicsCircle.x = x;\r\n        this.arcadePhysicsCircle.y = y;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Get game objects overlaping field of view.\r\n *\r\n * @method Raycaster.Ray#overlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\r\n *\r\n * @return {object[]} Array of game objects that overlaps with field of view.\r\n */\r\nexport function overlap(objects) {\r\n    let targets = [];\r\n    let bodies = false;\r\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\r\n\r\n    //get bodies in range\r\n    if(objects === undefined) {\r\n        objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\r\n        bodies = true;\r\n    }\r\n    //get object's body\r\n    else if(!Array.isArray(objects)) {\r\n        objects = [objects];\r\n    }\r\n    //if objects are bodies\r\n    if(bodies) {\r\n        for(let body of objects) {\r\n            if(body === this.body)\r\n                continue;\r\n            \r\n            let hitbox;\r\n            //get physics body hitbox\r\n            if(body.isCircle) {\r\n                hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\r\n            }\r\n            else {\r\n                hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\r\n            }\r\n\r\n            if(this.testOverlap(hitbox))\r\n                targets.push(body.gameObject);\r\n        }\r\n    }\r\n    //if objects are game objects\r\n    else {\r\n        for(let object of objects) {\r\n            if(object.body === undefined)\r\n                continue;\r\n\r\n            let hitbox;\r\n            //get physics body hitbox\r\n            if(object.body.isCircle) {\r\n                hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\r\n                if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\r\n                    continue;\r\n            }\r\n            else {\r\n                hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\r\n                if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\r\n                    continue;\r\n            }\r\n\r\n            if(this.testOverlap(hitbox))\r\n                targets.push(object);\r\n        }\r\n    }\r\n\r\n    return targets;\r\n}\r\n\r\n/**\r\n * Process callback for arcade physics collider / overlap.\r\n *\r\n * @method Raycaster.Ray#processOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object} object1 - Game object passed by collider / overlap.\r\n * @param {object} object2 - Game object passed by collider / overlap.\r\n *\r\n * @return {boolean} Return true if game object is overlapping ray's field of view.\r\n */\r\nexport function processOverlap(object1, object2) {\r\n    let target;\r\n\r\n    if(object1._ray === this)\r\n        target = object2;\r\n    else if(object2._ray === this)\r\n        target = obj1;\r\n    else\r\n        return false;\r\n\r\n    return (this.overlap(target).length > 0);\r\n}   \r\n\r\n/**\r\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.8.0\r\n *\r\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testOverlap(hitbox) {\r\n    let overlap = false;\r\n\r\n    //iterate through field of view slices to check collisions with target\r\n    for(let slice of this.slicedIntersections) {\r\n        //if hitbox is a circle\r\n        if(hitbox.type == 0) {\r\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\r\n        }\r\n        //if hitbox is a rectangle\r\n        else {\r\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\r\n        }\r\n\r\n        if(overlap) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n","/**\r\n * Set ray's range.\r\n *\r\n * @method Raycaster.Ray#setRayRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.rayRange = rayRange;\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\r\n * Ray tests all objects when set to 0.\r\n *\r\n * @method Raycaster.Ray#setDetectionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setDetectionRange(detectionRange = 0) {\r\n    this.detectionRange = detectionRange;\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\r\n * Determines ray's physics body radius.\r\n *\r\n * @method Raycaster.Ray#setCollisionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {integer} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.collisionRange = collisionRange;\r\n    if(this.body) {\r\n        this.arcadePhysicsCircle.setRadius(this.collisionRange);\r\n        this.body.setCircle(this.collisionRange);\r\n    }\r\n    return this;\r\n}\r\n\r\n/**\r\n * Test if object's bounding box is in ray's detection range.\r\n *\r\n * @method Raycaster.Ray#boundsInRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} object - Tested object\r\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\r\n *\r\n * @return {boolean} Information if object is in ray's detection range.\r\n */\r\nexport function boundsInRange(object, bounds = false) {\r\n    if(!this.detectionRange)\r\n        return true;\r\n\r\n    let objectBounds;\r\n    if(bounds)\r\n        objectBounds = bounds;\r\n    else\r\n        objectBounds = object.getBounds();\r\n\r\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @namespace Raycaster.Ray\r\n * @class Raycaster.Ray\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Ray specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Ray#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Ray's source position.\r\n    *\r\n    * @name Raycaster.Ray#origin\r\n    * @type {Phaser.Geom.Point}\r\n    * @since 0.6.0\r\n    */\r\n    this.origin = new Phaser.Geom.Point();\r\n    /**\r\n    * Ray's representation used to calculating intersections.\r\n    *\r\n    * @name Raycaster.Ray#_ray\r\n    * @type {Phaser.Geom.Line}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._ray = new Phaser.Geom.Line();\r\n    /**\r\n    * Ray's angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#angle\r\n    * @type {float}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.angle = 0;\r\n    /**\r\n    * Ray's cone width angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#cone\r\n    * @type {float}\r\n    * @default 0\r\n    * @since 0.7.0\r\n    */\r\n    this.cone = 0;\r\n    /**\r\n    * Ray's maximum range\r\n    *\r\n    * @name Raycaster.Ray#rayRange\r\n    * @type {integer}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.6.0\r\n    */\r\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\r\n    * Ray tests all objects when set to 0.\r\n    *\r\n    * @name Raycaster.Ray#detectionRange\r\n    * @type {integer}\r\n    * @default\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRange = 0;\r\n    /**\r\n    * Ray's representation of detection range used in calculating if objects are in range.\r\n    *\r\n    * @name Raycaster.Ray#detectionRangeCircle\r\n    * @type {Phaser.Geom.Circle}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    /**\r\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\r\n    *\r\n    * @name Raycaster.Ray#collisionRange\r\n    * @type {integer}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.8.0\r\n    */\r\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    *\r\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.6.0\r\n    */\r\n    this.ignoreNotIntersectedRays = true;\r\n    /**\r\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    *\r\n    * @name Raycaster.Ray#autoSlice\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.0\r\n    */\r\n    this.autoSlice = false;\r\n    /**\r\n    * Array of intersections from last raycast representing field of view.\r\n    *\r\n    * @name Raycaster.Ray#intersections\r\n    * @type {object[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.intersections = [];\r\n    /**\r\n    * Array of triangles representing slices of field of view from last raycast.\r\n    *\r\n    * @name Raycaster.Ray#slicedIntersections\r\n    * @type {Phaser.Geom.Triangle[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.slicedIntersections = [];\r\n\r\n    /**\r\n    * Physics body for testing field of view collisions.\r\n    *\r\n    * @name Raycaster.Ray#body\r\n    * @type {(object|bolean)}\r\n    * @default undefined\r\n    * @since 0.8.0\r\n    */\r\n    //this.body = false;\r\n    //this.arcadePhysicsCircle;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRayRange: require('./range.js').setRayRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone,\r\n    slice: require('./slice.js').slice,\r\n    setCollisionRange: require('./range.js').setCollisionRange,\r\n    enableArcadePhysics: require('./enableArcadePhysics.js').enableArcadePhysics,\r\n    overlap: require('./overlap.js').overlap,\r\n    processOverlap: require('./overlap.js').processOverlap,\r\n    testOverlap: require('./overlap.js').testOverlap\r\n};\r\n","/**\r\n * Set ray's position, direction (angle) and range.\r\n *\r\n * @method Raycaster.Ray#setRay\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} x - X coordinate.\r\n * @param {integer} y - Y coordinate.\r\n * @param {float} [angle] - Ray's angle in radians.\r\n * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.origin.setTo(x, y);\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    this.rayRange = rayRange;\r\n\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n    return this;\r\n}\r\n","/**\r\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\r\n *\r\n * @method Raycaster.Ray#slice\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\r\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\r\n *\r\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\r\n */\r\nexport function slice(intersections = this.intersections, closed = true) {\r\n    //if intersections is Phaser.Geom.Polygon object\r\n    if(!Array.isArray(intersections)) {\r\n        if(intersections.type === 4)\r\n            intersections = intersections.points;\r\n        else\r\n            return [];\r\n    }\r\n\r\n    if(intersections.length === 0)\r\n        return [];\r\n\r\n    let slices = [];\r\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\r\n    }\r\n\r\n    if(closed)\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\r\n\r\n    return slices;\r\n}\r\n","/**\r\n* @author       Marcin Walczak <mail@marcinwalczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.8.0';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    this.graphics;\r\n\r\n    /**\r\n    * Raycaster's bounding box.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {integer}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined && options.scene.physics !== undefined)\r\n            options.boundingBox = options.scene.physics.world.bounds;\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycatser's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {integer} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {integer} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {integer} width - The width of bounding box.\r\n    * @param {integer} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object or array of game objects to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects)) {\r\n            if(this.mappedObjects.includes(objects))\r\n                return this;\r\n\r\n            if(!objects.data)\r\n                objects.setDataEnabled();\r\n\r\n            options.object = objects;\r\n\r\n            let map = new this.Map(options);\r\n\r\n            objects.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(objects);\r\n\r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            if(!object.data)\r\n                object.setDataEnabled();\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config);\r\n\r\n            object.data.set('raycasterMap', map);\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            let index = this.mappedObjects.indexOf(objects);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n            return this;\r\n        }\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            if(objects.data) {\r\n                let map = objects.data.get('raycasterMap');\r\n                if(map)\r\n                    map.active = true;\r\n            }\r\n                \r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(object.data) {\r\n                let map = object.data.get('raycasterMap');\r\n                if(map)\r\n                    map.active = true;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects)) {\r\n            if(objects.data) {\r\n                let map = objects.data.get('raycasterMap');\r\n                if(map)\r\n                    map.active = false;\r\n            }\r\n                \r\n            return this;\r\n        }\r\n        \r\n        for(let object of objects) {\r\n            if(object.data) {\r\n                let map = object.data.get('raycasterMap');\r\n                if(map)\r\n                    map.active = false;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                if(mapppedObject.data === undefined)\r\n                    continue;\r\n\r\n                let map = mapppedObject.data.get('raycasterMap')\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray options:\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n"],"sourceRoot":""}